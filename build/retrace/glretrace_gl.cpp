
#include <string.h>

#include "glproc.hpp"
#include "glretrace.hpp"
#include "glstate.hpp"


static bool _pipelineHasBeenBound = false;

#include "os_time.hpp"
#include "trace_parser.hpp"
#include "retrace.hpp"
#include "retrace_swizzle.hpp"

static retrace::map<GLuint> _list_map;
static retrace::map<GLuint> _texture_map;
static retrace::map<GLuint> _query_map;
static retrace::map<GLuint> _buffer_map;
static retrace::map<GLuint> _program_map;
static retrace::map<GLuint> _shader_map;
static std::map<GLhandleARB, retrace::map<GLint> > _location_map;
static retrace::map<GLuint> _programARB_map;
static retrace::map<GLhandleARB> _handleARB_map;
static retrace::map<GLuint> _renderbuffer_map;
static retrace::map<GLuint> _framebuffer_map;
static std::map<uintptr_t, retrace::map<GLuint> > _array_map;
static retrace::map<GLsync> _sync_map;
static retrace::map<GLuint> _sampler_map;
static retrace::map<GLuint> _feedback_map;
static retrace::map<GLuint> _pipeline_map;
static retrace::map<GLuint> _fence_map;
static retrace::map<GLuint> _fragmentShaderATI_map;
static retrace::map<GLuint> _arrayAPPLE_map;
static retrace::map<GLuint> _region_map;

static void retrace_glCullFace(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCullFace(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFrontFace(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFrontFace(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glHint(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glHint(target, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLineWidth(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat width;
    width = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLineWidth(width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointSize(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat size;
    size = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointSize(size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPolygonMode(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPolygonMode(face, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glScissor(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glScissor(x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameterf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameterf(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameterfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat75_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat75 = 0; _jGLfloat75 < _a_GLfloat75_0->values.size(); ++_jGLfloat75) {
    params[_jGLfloat75] = (*_a_GLfloat75_0->values[_jGLfloat75]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameterfv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameteri(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameteri(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameteriv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint110_0 = (call.arg(2)).toArray();
        for (size_t _jGLint110 = 0; _jGLint110 < _a_GLint110_0->values.size(); ++_jGLint110) {
    params[_jGLint110] = (*_a_GLint110_0->values[_jGLint110]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameteriv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexImage1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLint border;
    border = (call.arg(4)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(5)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(6)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexImage2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLint border;
    border = (call.arg(5)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(6)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(7)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawBuffer(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClear(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glClear(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glClearColor(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat red;
    red = (call.arg(0)).toFloat();

    GLfloat green;
    green = (call.arg(1)).toFloat();

    GLfloat blue;
    blue = (call.arg(2)).toFloat();

    GLfloat alpha;
    alpha = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearColor(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearStencil(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint s;
    s = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearStencil(s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearDepth(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble depth;
    depth = (call.arg(0)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearDepth(depth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilMask(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilMask(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorMask(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLboolean red;
    red = static_cast<GLboolean>((call.arg(0)).toSInt());

    GLboolean green;
    green = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLboolean blue;
    blue = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLboolean alpha;
    alpha = static_cast<GLboolean>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorMask(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthMask(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLboolean flag;
    flag = static_cast<GLboolean>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthMask(flag);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisable(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum cap;
    cap = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (cap == GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB) return;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisable(cap);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnable(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum cap;
    cap = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (cap == GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB) return;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnable(cap);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFinish(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFinish();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    if (!retrace::doubleBuffer) {
        glretrace::frame_complete(call);
    }
}

static void retrace_glFlush(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlush();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    if (!retrace::doubleBuffer) {
        glretrace::frame_complete(call);
    }
}

static void retrace_glBlendFunc(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum sfactor;
    sfactor = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum dfactor;
    dfactor = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFunc(sfactor, dfactor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLogicOp(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum opcode;
    opcode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLogicOp(opcode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilFunc(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum func;
    func = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint ref;
    ref = (call.arg(1)).toSInt();

    GLuint mask;
    mask = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilFunc(func, ref, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilOp(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum fail;
    fail = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum zfail;
    zfail = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum zpass;
    zpass = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilOp(fail, zfail, zpass);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthFunc(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum func;
    func = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthFunc(func);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelStoref(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelStoref(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelStorei(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelStorei(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReadBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReadBuffer(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReadPixels(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReadPixels(x, y, width, height, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetTexImage(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(4)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetTexImage(target, level, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthRange(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble zNear;
    zNear = (call.arg(0)).toDouble();

    GLdouble zFar;
    zFar = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthRange(zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glViewport(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    glretrace::updateDrawable(x + width, y + height);
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glViewport(x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNewList(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint list;
    list = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "list " << size_t(list) << " <- " << size_t(_list_map[list]) << "\n";
    }
    list = _list_map[list];

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    glretrace::insideList = true;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNewList(list, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndList(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    glretrace::insideList = false;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndList();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCallList(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint list;
    list = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "list " << size_t(list) << " <- " << size_t(_list_map[list]) << "\n";
    }
    list = _list_map[list];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glCallList(list);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glCallLists(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * lists;
    lists = static_cast<GLvoid *>((call.arg(2)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glCallLists(n, type, lists);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDeleteLists(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint list;
    list = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "list " << size_t(list) << " <- " << size_t(_list_map[list]) << "\n";
    }
    list = _list_map[list];

    GLsizei range;
    range = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteLists(list, range);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenLists(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei range;
    range = (call.arg(0)).toSInt();

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGenLists(range);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLuint _origResult;
    _origResult = (*call.ret).toUInt();
    for (GLuint _hPGLuint18 = 0; _hPGLuint18 < range; ++_hPGLuint18) {
        _list_map[_origResult + _hPGLuint18] = _result + _hPGLuint18;
        if (retrace::verbosity >= 2) {
            std::cout << "list " << (_origResult + _hPGLuint18) << " -> " << (_result + _hPGLuint18) << "\n";
        }
    }
}

static void retrace_glListBase(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint base;
    base = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glListBase(base);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBegin(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glBegin(mode);
    glretrace::insideGlBeginEnd = true;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBitmap(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei width;
    width = (call.arg(0)).toSInt();

    GLsizei height;
    height = (call.arg(1)).toSInt();

    GLfloat xorig;
    xorig = (call.arg(2)).toFloat();

    GLfloat yorig;
    yorig = (call.arg(3)).toFloat();

    GLfloat xmove;
    xmove = (call.arg(4)).toFloat();

    GLfloat ymove;
    ymove = (call.arg(5)).toFloat();

    GLubyte * bitmap;
    bitmap = static_cast<GLubyte *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3b(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte red;
    red = (call.arg(0)).toSInt();

    GLbyte green;
    green = (call.arg(1)).toSInt();

    GLbyte blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3b(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3bv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte1_0 = (call.arg(0)).toArray();
        for (size_t _jGLbyte1 = 0; _jGLbyte1 < _a_GLbyte1_0->values.size(); ++_jGLbyte1) {
    v[_jGLbyte1] = (*_a_GLbyte1_0->values[_jGLbyte1]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3bv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble red;
    red = (call.arg(0)).toDouble();

    GLdouble green;
    green = (call.arg(1)).toDouble();

    GLdouble blue;
    blue = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3d(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble23_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble23 = 0; _jGLdouble23 < _a_GLdouble23_0->values.size(); ++_jGLdouble23) {
    v[_jGLdouble23] = (*_a_GLdouble23_0->values[_jGLdouble23]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat red;
    red = (call.arg(0)).toFloat();

    GLfloat green;
    green = (call.arg(1)).toFloat();

    GLfloat blue;
    blue = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3f(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat76_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat76 = 0; _jGLfloat76 < _a_GLfloat76_0->values.size(); ++_jGLfloat76) {
    v[_jGLfloat76] = (*_a_GLfloat76_0->values[_jGLfloat76]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint red;
    red = (call.arg(0)).toSInt();

    GLint green;
    green = (call.arg(1)).toSInt();

    GLint blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3i(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint111_0 = (call.arg(0)).toArray();
        for (size_t _jGLint111 = 0; _jGLint111 < _a_GLint111_0->values.size(); ++_jGLint111) {
    v[_jGLint111] = (*_a_GLint111_0->values[_jGLint111]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort red;
    red = (call.arg(0)).toSInt();

    GLshort green;
    green = (call.arg(1)).toSInt();

    GLshort blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3s(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort1_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort1 = 0; _jGLshort1 < _a_GLshort1_0->values.size(); ++_jGLshort1) {
    v[_jGLshort1] = (*_a_GLshort1_0->values[_jGLshort1]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3ub(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte red;
    red = (call.arg(0)).toUInt();

    GLubyte green;
    green = (call.arg(1)).toUInt();

    GLubyte blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3ub(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3ubv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte5_0 = (call.arg(0)).toArray();
        for (size_t _jGLubyte5 = 0; _jGLubyte5 < _a_GLubyte5_0->values.size(); ++_jGLubyte5) {
    v[_jGLubyte5] = (*_a_GLubyte5_0->values[_jGLubyte5]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3ubv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint red;
    red = (call.arg(0)).toUInt();

    GLuint green;
    green = (call.arg(1)).toUInt();

    GLuint blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3ui(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint63_0 = (call.arg(0)).toArray();
        for (size_t _jGLuint63 = 0; _jGLuint63 < _a_GLuint63_0->values.size(); ++_jGLuint63) {
    v[_jGLuint63] = (*_a_GLuint63_0->values[_jGLuint63]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3uiv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3us(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort red;
    red = (call.arg(0)).toUInt();

    GLushort green;
    green = (call.arg(1)).toUInt();

    GLushort blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3us(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3usv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort2_0 = (call.arg(0)).toArray();
        for (size_t _jGLushort2 = 0; _jGLushort2 < _a_GLushort2_0->values.size(); ++_jGLushort2) {
    v[_jGLushort2] = (*_a_GLushort2_0->values[_jGLushort2]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3usv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4b(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte red;
    red = (call.arg(0)).toSInt();

    GLbyte green;
    green = (call.arg(1)).toSInt();

    GLbyte blue;
    blue = (call.arg(2)).toSInt();

    GLbyte alpha;
    alpha = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4b(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4bv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte2_0 = (call.arg(0)).toArray();
        for (size_t _jGLbyte2 = 0; _jGLbyte2 < _a_GLbyte2_0->values.size(); ++_jGLbyte2) {
    v[_jGLbyte2] = (*_a_GLbyte2_0->values[_jGLbyte2]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4bv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble red;
    red = (call.arg(0)).toDouble();

    GLdouble green;
    green = (call.arg(1)).toDouble();

    GLdouble blue;
    blue = (call.arg(2)).toDouble();

    GLdouble alpha;
    alpha = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4d(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble24_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble24 = 0; _jGLdouble24 < _a_GLdouble24_0->values.size(); ++_jGLdouble24) {
    v[_jGLdouble24] = (*_a_GLdouble24_0->values[_jGLdouble24]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat red;
    red = (call.arg(0)).toFloat();

    GLfloat green;
    green = (call.arg(1)).toFloat();

    GLfloat blue;
    blue = (call.arg(2)).toFloat();

    GLfloat alpha;
    alpha = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4f(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat77_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat77 = 0; _jGLfloat77 < _a_GLfloat77_0->values.size(); ++_jGLfloat77) {
    v[_jGLfloat77] = (*_a_GLfloat77_0->values[_jGLfloat77]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint red;
    red = (call.arg(0)).toSInt();

    GLint green;
    green = (call.arg(1)).toSInt();

    GLint blue;
    blue = (call.arg(2)).toSInt();

    GLint alpha;
    alpha = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4i(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint112_0 = (call.arg(0)).toArray();
        for (size_t _jGLint112 = 0; _jGLint112 < _a_GLint112_0->values.size(); ++_jGLint112) {
    v[_jGLint112] = (*_a_GLint112_0->values[_jGLint112]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort red;
    red = (call.arg(0)).toSInt();

    GLshort green;
    green = (call.arg(1)).toSInt();

    GLshort blue;
    blue = (call.arg(2)).toSInt();

    GLshort alpha;
    alpha = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4s(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort2_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort2 = 0; _jGLshort2 < _a_GLshort2_0->values.size(); ++_jGLshort2) {
    v[_jGLshort2] = (*_a_GLshort2_0->values[_jGLshort2]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4ub(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte red;
    red = (call.arg(0)).toUInt();

    GLubyte green;
    green = (call.arg(1)).toUInt();

    GLubyte blue;
    blue = (call.arg(2)).toUInt();

    GLubyte alpha;
    alpha = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4ub(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4ubv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte6_0 = (call.arg(0)).toArray();
        for (size_t _jGLubyte6 = 0; _jGLubyte6 < _a_GLubyte6_0->values.size(); ++_jGLubyte6) {
    v[_jGLubyte6] = (*_a_GLubyte6_0->values[_jGLubyte6]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4ubv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint red;
    red = (call.arg(0)).toUInt();

    GLuint green;
    green = (call.arg(1)).toUInt();

    GLuint blue;
    blue = (call.arg(2)).toUInt();

    GLuint alpha;
    alpha = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4ui(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint65_0 = (call.arg(0)).toArray();
        for (size_t _jGLuint65 = 0; _jGLuint65 < _a_GLuint65_0->values.size(); ++_jGLuint65) {
    v[_jGLuint65] = (*_a_GLuint65_0->values[_jGLuint65]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4uiv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4us(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort red;
    red = (call.arg(0)).toUInt();

    GLushort green;
    green = (call.arg(1)).toUInt();

    GLushort blue;
    blue = (call.arg(2)).toUInt();

    GLushort alpha;
    alpha = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4us(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4usv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort3_0 = (call.arg(0)).toArray();
        for (size_t _jGLushort3 = 0; _jGLushort3 < _a_GLushort3_0->values.size(); ++_jGLushort3) {
    v[_jGLushort3] = (*_a_GLushort3_0->values[_jGLushort3]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4usv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEdgeFlag(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLboolean flag;
    flag = static_cast<GLboolean>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEdgeFlag(flag);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEdgeFlagv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLboolean * flag;
    flag = static_cast<GLboolean *>(_allocator.alloc(&call.arg(0), sizeof *flag));
    if (flag) {
        const trace::Array *_a_PGLboolean_0 = (call.arg(0)).toArray();
    flag[0] = static_cast<GLboolean>((*_a_PGLboolean_0->values[0]).toSInt());
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEdgeFlagv(flag);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnd(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    glretrace::insideGlBeginEnd = false;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    glEnd();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glIndexd(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble c;
    c = (call.arg(0)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexd(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexdv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * c;
    c = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_PGLdouble1_0 = (call.arg(0)).toArray();
    c[0] = (*_a_PGLdouble1_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexdv(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat c;
    c = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexf(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_PGLfloat11_0 = (call.arg(0)).toArray();
    c[0] = (*_a_PGLfloat11_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexfv(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexi(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint c;
    c = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexi(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * c;
    c = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_PGLint24_0 = (call.arg(0)).toArray();
    c[0] = (*_a_PGLint24_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexiv(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexs(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort c;
    c = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexs(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexsv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * c;
    c = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_PGLshort_0 = (call.arg(0)).toArray();
    c[0] = (*_a_PGLshort_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexsv(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3b(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte nx;
    nx = (call.arg(0)).toSInt();

    GLbyte ny;
    ny = (call.arg(1)).toSInt();

    GLbyte nz;
    nz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3b(nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3bv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte3_0 = (call.arg(0)).toArray();
        for (size_t _jGLbyte3 = 0; _jGLbyte3 < _a_GLbyte3_0->values.size(); ++_jGLbyte3) {
    v[_jGLbyte3] = (*_a_GLbyte3_0->values[_jGLbyte3]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3bv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble nx;
    nx = (call.arg(0)).toDouble();

    GLdouble ny;
    ny = (call.arg(1)).toDouble();

    GLdouble nz;
    nz = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3d(nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble25_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble25 = 0; _jGLdouble25 < _a_GLdouble25_0->values.size(); ++_jGLdouble25) {
    v[_jGLdouble25] = (*_a_GLdouble25_0->values[_jGLdouble25]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat nx;
    nx = (call.arg(0)).toFloat();

    GLfloat ny;
    ny = (call.arg(1)).toFloat();

    GLfloat nz;
    nz = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3f(nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat78_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat78 = 0; _jGLfloat78 < _a_GLfloat78_0->values.size(); ++_jGLfloat78) {
    v[_jGLfloat78] = (*_a_GLfloat78_0->values[_jGLfloat78]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint nx;
    nx = (call.arg(0)).toSInt();

    GLint ny;
    ny = (call.arg(1)).toSInt();

    GLint nz;
    nz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3i(nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint113_0 = (call.arg(0)).toArray();
        for (size_t _jGLint113 = 0; _jGLint113 < _a_GLint113_0->values.size(); ++_jGLint113) {
    v[_jGLint113] = (*_a_GLint113_0->values[_jGLint113]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort nx;
    nx = (call.arg(0)).toSInt();

    GLshort ny;
    ny = (call.arg(1)).toSInt();

    GLshort nz;
    nz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3s(nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort3_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort3 = 0; _jGLshort3 < _a_GLshort3_0->values.size(); ++_jGLshort3) {
    v[_jGLshort3] = (*_a_GLshort3_0->values[_jGLshort3]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos2d(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble26_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble26 = 0; _jGLdouble26 < _a_GLdouble26_0->values.size(); ++_jGLdouble26) {
    v[_jGLdouble26] = (*_a_GLdouble26_0->values[_jGLdouble26]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos2dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos2f(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat79_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat79 = 0; _jGLfloat79 < _a_GLfloat79_0->values.size(); ++_jGLfloat79) {
    v[_jGLfloat79] = (*_a_GLfloat79_0->values[_jGLfloat79]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos2fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos2i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos2i(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos2iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint114_0 = (call.arg(0)).toArray();
        for (size_t _jGLint114 = 0; _jGLint114 < _a_GLint114_0->values.size(); ++_jGLint114) {
    v[_jGLint114] = (*_a_GLint114_0->values[_jGLint114]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos2iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos2s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos2s(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos2sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort4_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort4 = 0; _jGLshort4 < _a_GLshort4_0->values.size(); ++_jGLshort4) {
    v[_jGLshort4] = (*_a_GLshort4_0->values[_jGLshort4]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos2sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos3d(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble27_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble27 = 0; _jGLdouble27 < _a_GLdouble27_0->values.size(); ++_jGLdouble27) {
    v[_jGLdouble27] = (*_a_GLdouble27_0->values[_jGLdouble27]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos3dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos3f(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat80_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat80 = 0; _jGLfloat80 < _a_GLfloat80_0->values.size(); ++_jGLfloat80) {
    v[_jGLfloat80] = (*_a_GLfloat80_0->values[_jGLfloat80]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos3fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos3i(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint115_0 = (call.arg(0)).toArray();
        for (size_t _jGLint115 = 0; _jGLint115 < _a_GLint115_0->values.size(); ++_jGLint115) {
    v[_jGLint115] = (*_a_GLint115_0->values[_jGLint115]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos3iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos3s(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort5_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort5 = 0; _jGLshort5 < _a_GLshort5_0->values.size(); ++_jGLshort5) {
    v[_jGLshort5] = (*_a_GLshort5_0->values[_jGLshort5]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos3sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    GLdouble w;
    w = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos4d(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble28_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble28 = 0; _jGLdouble28 < _a_GLdouble28_0->values.size(); ++_jGLdouble28) {
    v[_jGLdouble28] = (*_a_GLdouble28_0->values[_jGLdouble28]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos4dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos4f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    GLfloat w;
    w = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos4f(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat81_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat81 = 0; _jGLfloat81 < _a_GLfloat81_0->values.size(); ++_jGLfloat81) {
    v[_jGLfloat81] = (*_a_GLfloat81_0->values[_jGLfloat81]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos4fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos4i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    GLint w;
    w = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos4i(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint116_0 = (call.arg(0)).toArray();
        for (size_t _jGLint116 = 0; _jGLint116 < _a_GLint116_0->values.size(); ++_jGLint116) {
    v[_jGLint116] = (*_a_GLint116_0->values[_jGLint116]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos4iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos4s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    GLshort w;
    w = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos4s(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRasterPos4sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort6_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort6 = 0; _jGLshort6 < _a_GLshort6_0->values.size(); ++_jGLshort6) {
    v[_jGLshort6] = (*_a_GLshort6_0->values[_jGLshort6]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRasterPos4sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRectd(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x1;
    x1 = (call.arg(0)).toDouble();

    GLdouble y1;
    y1 = (call.arg(1)).toDouble();

    GLdouble x2;
    x2 = (call.arg(2)).toDouble();

    GLdouble y2;
    y2 = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRectd(x1, y1, x2, y2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRectdv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v1;
    v1 = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v1));
    if (v1) {
        const trace::Array *_a_GLdouble29_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble29 = 0; _jGLdouble29 < _a_GLdouble29_0->values.size(); ++_jGLdouble29) {
    v1[_jGLdouble29] = (*_a_GLdouble29_0->values[_jGLdouble29]).toDouble();
        }
    }

    GLdouble * v2;
    v2 = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v2));
    if (v2) {
        const trace::Array *_a_GLdouble30_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble30 = 0; _jGLdouble30 < _a_GLdouble30_0->values.size(); ++_jGLdouble30) {
    v2[_jGLdouble30] = (*_a_GLdouble30_0->values[_jGLdouble30]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRectdv(v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRectf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x1;
    x1 = (call.arg(0)).toFloat();

    GLfloat y1;
    y1 = (call.arg(1)).toFloat();

    GLfloat x2;
    x2 = (call.arg(2)).toFloat();

    GLfloat y2;
    y2 = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRectf(x1, y1, x2, y2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRectfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v1;
    v1 = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v1));
    if (v1) {
        const trace::Array *_a_GLfloat82_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat82 = 0; _jGLfloat82 < _a_GLfloat82_0->values.size(); ++_jGLfloat82) {
    v1[_jGLfloat82] = (*_a_GLfloat82_0->values[_jGLfloat82]).toFloat();
        }
    }

    GLfloat * v2;
    v2 = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v2));
    if (v2) {
        const trace::Array *_a_GLfloat83_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat83 = 0; _jGLfloat83 < _a_GLfloat83_0->values.size(); ++_jGLfloat83) {
    v2[_jGLfloat83] = (*_a_GLfloat83_0->values[_jGLfloat83]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRectfv(v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRecti(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x1;
    x1 = (call.arg(0)).toSInt();

    GLint y1;
    y1 = (call.arg(1)).toSInt();

    GLint x2;
    x2 = (call.arg(2)).toSInt();

    GLint y2;
    y2 = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRecti(x1, y1, x2, y2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRectiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v1;
    v1 = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v1));
    if (v1) {
        const trace::Array *_a_GLint117_0 = (call.arg(0)).toArray();
        for (size_t _jGLint117 = 0; _jGLint117 < _a_GLint117_0->values.size(); ++_jGLint117) {
    v1[_jGLint117] = (*_a_GLint117_0->values[_jGLint117]).toSInt();
        }
    }

    GLint * v2;
    v2 = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v2));
    if (v2) {
        const trace::Array *_a_GLint118_0 = (call.arg(1)).toArray();
        for (size_t _jGLint118 = 0; _jGLint118 < _a_GLint118_0->values.size(); ++_jGLint118) {
    v2[_jGLint118] = (*_a_GLint118_0->values[_jGLint118]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRectiv(v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRects(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x1;
    x1 = (call.arg(0)).toSInt();

    GLshort y1;
    y1 = (call.arg(1)).toSInt();

    GLshort x2;
    x2 = (call.arg(2)).toSInt();

    GLshort y2;
    y2 = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRects(x1, y1, x2, y2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRectsv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v1;
    v1 = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v1));
    if (v1) {
        const trace::Array *_a_GLshort7_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort7 = 0; _jGLshort7 < _a_GLshort7_0->values.size(); ++_jGLshort7) {
    v1[_jGLshort7] = (*_a_GLshort7_0->values[_jGLshort7]).toSInt();
        }
    }

    GLshort * v2;
    v2 = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v2));
    if (v2) {
        const trace::Array *_a_GLshort8_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort8 = 0; _jGLshort8 < _a_GLshort8_0->values.size(); ++_jGLshort8) {
    v2[_jGLshort8] = (*_a_GLshort8_0->values[_jGLshort8]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRectsv(v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble s;
    s = (call.arg(0)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1d(s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLdouble2_0 = (call.arg(0)).toArray();
    v[0] = (*_a_PGLdouble2_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1f(s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLfloat12_0 = (call.arg(0)).toArray();
    v[0] = (*_a_PGLfloat12_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint s;
    s = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1i(s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLint25_0 = (call.arg(0)).toArray();
    v[0] = (*_a_PGLint25_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort s;
    s = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1s(s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLshort1_0 = (call.arg(0)).toArray();
    v[0] = (*_a_PGLshort1_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble s;
    s = (call.arg(0)).toDouble();

    GLdouble t;
    t = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2d(s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble31_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble31 = 0; _jGLdouble31 < _a_GLdouble31_0->values.size(); ++_jGLdouble31) {
    v[_jGLdouble31] = (*_a_GLdouble31_0->values[_jGLdouble31]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2f(s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat84_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat84 = 0; _jGLfloat84 < _a_GLfloat84_0->values.size(); ++_jGLfloat84) {
    v[_jGLfloat84] = (*_a_GLfloat84_0->values[_jGLfloat84]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint s;
    s = (call.arg(0)).toSInt();

    GLint t;
    t = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2i(s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint119_0 = (call.arg(0)).toArray();
        for (size_t _jGLint119 = 0; _jGLint119 < _a_GLint119_0->values.size(); ++_jGLint119) {
    v[_jGLint119] = (*_a_GLint119_0->values[_jGLint119]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort s;
    s = (call.arg(0)).toSInt();

    GLshort t;
    t = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2s(s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort9_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort9 = 0; _jGLshort9 < _a_GLshort9_0->values.size(); ++_jGLshort9) {
    v[_jGLshort9] = (*_a_GLshort9_0->values[_jGLshort9]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble s;
    s = (call.arg(0)).toDouble();

    GLdouble t;
    t = (call.arg(1)).toDouble();

    GLdouble r;
    r = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3d(s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble32_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble32 = 0; _jGLdouble32 < _a_GLdouble32_0->values.size(); ++_jGLdouble32) {
    v[_jGLdouble32] = (*_a_GLdouble32_0->values[_jGLdouble32]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLfloat r;
    r = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3f(s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat85_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat85 = 0; _jGLfloat85 < _a_GLfloat85_0->values.size(); ++_jGLfloat85) {
    v[_jGLfloat85] = (*_a_GLfloat85_0->values[_jGLfloat85]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint s;
    s = (call.arg(0)).toSInt();

    GLint t;
    t = (call.arg(1)).toSInt();

    GLint r;
    r = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3i(s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint120_0 = (call.arg(0)).toArray();
        for (size_t _jGLint120 = 0; _jGLint120 < _a_GLint120_0->values.size(); ++_jGLint120) {
    v[_jGLint120] = (*_a_GLint120_0->values[_jGLint120]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort s;
    s = (call.arg(0)).toSInt();

    GLshort t;
    t = (call.arg(1)).toSInt();

    GLshort r;
    r = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3s(s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort10_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort10 = 0; _jGLshort10 < _a_GLshort10_0->values.size(); ++_jGLshort10) {
    v[_jGLshort10] = (*_a_GLshort10_0->values[_jGLshort10]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble s;
    s = (call.arg(0)).toDouble();

    GLdouble t;
    t = (call.arg(1)).toDouble();

    GLdouble r;
    r = (call.arg(2)).toDouble();

    GLdouble q;
    q = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4d(s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble33_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble33 = 0; _jGLdouble33 < _a_GLdouble33_0->values.size(); ++_jGLdouble33) {
    v[_jGLdouble33] = (*_a_GLdouble33_0->values[_jGLdouble33]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLfloat r;
    r = (call.arg(2)).toFloat();

    GLfloat q;
    q = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4f(s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat86_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat86 = 0; _jGLfloat86 < _a_GLfloat86_0->values.size(); ++_jGLfloat86) {
    v[_jGLfloat86] = (*_a_GLfloat86_0->values[_jGLfloat86]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint s;
    s = (call.arg(0)).toSInt();

    GLint t;
    t = (call.arg(1)).toSInt();

    GLint r;
    r = (call.arg(2)).toSInt();

    GLint q;
    q = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4i(s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint121_0 = (call.arg(0)).toArray();
        for (size_t _jGLint121 = 0; _jGLint121 < _a_GLint121_0->values.size(); ++_jGLint121) {
    v[_jGLint121] = (*_a_GLint121_0->values[_jGLint121]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort s;
    s = (call.arg(0)).toSInt();

    GLshort t;
    t = (call.arg(1)).toSInt();

    GLshort r;
    r = (call.arg(2)).toSInt();

    GLshort q;
    q = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4s(s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort11_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort11 = 0; _jGLshort11 < _a_GLshort11_0->values.size(); ++_jGLshort11) {
    v[_jGLshort11] = (*_a_GLshort11_0->values[_jGLshort11]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2d(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble34_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble34 = 0; _jGLdouble34 < _a_GLdouble34_0->values.size(); ++_jGLdouble34) {
    v[_jGLdouble34] = (*_a_GLdouble34_0->values[_jGLdouble34]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2f(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat87_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat87 = 0; _jGLfloat87 < _a_GLfloat87_0->values.size(); ++_jGLfloat87) {
    v[_jGLfloat87] = (*_a_GLfloat87_0->values[_jGLfloat87]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2i(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint122_0 = (call.arg(0)).toArray();
        for (size_t _jGLint122 = 0; _jGLint122 < _a_GLint122_0->values.size(); ++_jGLint122) {
    v[_jGLint122] = (*_a_GLint122_0->values[_jGLint122]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2s(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort12_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort12 = 0; _jGLshort12 < _a_GLshort12_0->values.size(); ++_jGLshort12) {
    v[_jGLshort12] = (*_a_GLshort12_0->values[_jGLshort12]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3d(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble35_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble35 = 0; _jGLdouble35 < _a_GLdouble35_0->values.size(); ++_jGLdouble35) {
    v[_jGLdouble35] = (*_a_GLdouble35_0->values[_jGLdouble35]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3f(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat88_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat88 = 0; _jGLfloat88 < _a_GLfloat88_0->values.size(); ++_jGLfloat88) {
    v[_jGLfloat88] = (*_a_GLfloat88_0->values[_jGLfloat88]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3i(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint123_0 = (call.arg(0)).toArray();
        for (size_t _jGLint123 = 0; _jGLint123 < _a_GLint123_0->values.size(); ++_jGLint123) {
    v[_jGLint123] = (*_a_GLint123_0->values[_jGLint123]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3s(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort13_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort13 = 0; _jGLshort13 < _a_GLshort13_0->values.size(); ++_jGLshort13) {
    v[_jGLshort13] = (*_a_GLshort13_0->values[_jGLshort13]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    GLdouble w;
    w = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4d(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble36_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble36 = 0; _jGLdouble36 < _a_GLdouble36_0->values.size(); ++_jGLdouble36) {
    v[_jGLdouble36] = (*_a_GLdouble36_0->values[_jGLdouble36]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    GLfloat w;
    w = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4f(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat89_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat89 = 0; _jGLfloat89 < _a_GLfloat89_0->values.size(); ++_jGLfloat89) {
    v[_jGLfloat89] = (*_a_GLfloat89_0->values[_jGLfloat89]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    GLint w;
    w = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4i(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint124_0 = (call.arg(0)).toArray();
        for (size_t _jGLint124 = 0; _jGLint124 < _a_GLint124_0->values.size(); ++_jGLint124) {
    v[_jGLint124] = (*_a_GLint124_0->values[_jGLint124]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    GLshort w;
    w = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4s(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort14_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort14 = 0; _jGLshort14 < _a_GLshort14_0->values.size(); ++_jGLshort14) {
    v[_jGLshort14] = (*_a_GLshort14_0->values[_jGLshort14]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClipPlane(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum plane;
    plane = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * equation;
    equation = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *equation));
    if (equation) {
        const trace::Array *_a_GLdouble37_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble37 = 0; _jGLdouble37 < _a_GLdouble37_0->values.size(); ++_jGLdouble37) {
    equation[_jGLdouble37] = (*_a_GLdouble37_0->values[_jGLdouble37]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClipPlane(plane, equation);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorMaterial(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorMaterial(face, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogf(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat90_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat90 = 0; _jGLfloat90 < _a_GLfloat90_0->values.size(); ++_jGLfloat90) {
    params[_jGLfloat90] = (*_a_GLfloat90_0->values[_jGLfloat90]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogfv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogi(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogi(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint125_0 = (call.arg(1)).toArray();
        for (size_t _jGLint125 = 0; _jGLint125 < _a_GLint125_0->values.size(); ++_jGLint125) {
    params[_jGLint125] = (*_a_GLint125_0->values[_jGLint125]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogiv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightf(light, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat91_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat91 = 0; _jGLfloat91 < _a_GLfloat91_0->values.size(); ++_jGLfloat91) {
    params[_jGLfloat91] = (*_a_GLfloat91_0->values[_jGLfloat91]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightfv(light, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLighti(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLighti(light, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint126_0 = (call.arg(2)).toArray();
        for (size_t _jGLint126 = 0; _jGLint126 < _a_GLint126_0->values.size(); ++_jGLint126) {
    params[_jGLint126] = (*_a_GLint126_0->values[_jGLint126]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightiv(light, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightModelf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightModelf(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightModelfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat92_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat92 = 0; _jGLfloat92 < _a_GLfloat92_0->values.size(); ++_jGLfloat92) {
    params[_jGLfloat92] = (*_a_GLfloat92_0->values[_jGLfloat92]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightModelfv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightModeli(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightModeli(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightModeliv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint127_0 = (call.arg(1)).toArray();
        for (size_t _jGLint127 = 0; _jGLint127 < _a_GLint127_0->values.size(); ++_jGLint127) {
    params[_jGLint127] = (*_a_GLint127_0->values[_jGLint127]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightModeliv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLineStipple(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint factor;
    factor = (call.arg(0)).toSInt();

    GLushort pattern;
    pattern = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLineStipple(factor, pattern);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMaterialf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMaterialf(face, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMaterialfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat93_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat93 = 0; _jGLfloat93 < _a_GLfloat93_0->values.size(); ++_jGLfloat93) {
    params[_jGLfloat93] = (*_a_GLfloat93_0->values[_jGLfloat93]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMaterialfv(face, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMateriali(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMateriali(face, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMaterialiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint128_0 = (call.arg(2)).toArray();
        for (size_t _jGLint128 = 0; _jGLint128 < _a_GLint128_0->values.size(); ++_jGLint128) {
    params[_jGLint128] = (*_a_GLint128_0->values[_jGLint128]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMaterialiv(face, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPolygonStipple(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * mask;
    mask = static_cast<GLubyte *>(_allocator.alloc(&call.arg(0), sizeof *mask));
    if (mask) {
        const trace::Array *_a_GLubyte7_0 = (call.arg(0)).toArray();
        for (size_t _jGLubyte7 = 0; _jGLubyte7 < _a_GLubyte7_0->values.size(); ++_jGLubyte7) {
    mask[_jGLubyte7] = (*_a_GLubyte7_0->values[_jGLubyte7]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPolygonStipple(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glShadeModel(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glShadeModel(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexEnvf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexEnvf(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexEnvfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat94_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat94 = 0; _jGLfloat94 < _a_GLfloat94_0->values.size(); ++_jGLfloat94) {
    params[_jGLfloat94] = (*_a_GLfloat94_0->values[_jGLfloat94]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexEnvfv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexEnvi(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexEnvi(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexEnviv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint129_0 = (call.arg(2)).toArray();
        for (size_t _jGLint129 = 0; _jGLint129 < _a_GLint129_0->values.size(); ++_jGLint129) {
    params[_jGLint129] = (*_a_GLint129_0->values[_jGLint129]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexEnviv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGend(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLdouble param;
    param = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGend(coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGendv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLdouble * params;
    params = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLdouble38_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble38 = 0; _jGLdouble38 < _a_GLdouble38_0->values.size(); ++_jGLdouble38) {
    params[_jGLdouble38] = (*_a_GLdouble38_0->values[_jGLdouble38]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGendv(coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGenf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGenf(coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGenfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat95_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat95 = 0; _jGLfloat95 < _a_GLfloat95_0->values.size(); ++_jGLfloat95) {
    params[_jGLfloat95] = (*_a_GLfloat95_0->values[_jGLfloat95]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGenfv(coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGeni(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGeni(coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGeniv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint130_0 = (call.arg(2)).toArray();
        for (size_t _jGLint130 = 0; _jGLint130 < _a_GLint130_0->values.size(); ++_jGLint130) {
    params[_jGLint130] = (*_a_GLint130_0->values[_jGLint130]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGeniv(coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFeedbackBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * buffer;
    buffer = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *buffer));
    _allocator.bind(buffer);

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFeedbackBuffer(size, type, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLfloat97 = (call.arg(2)).toArray();
    if (_aGLfloat97) {
        for (size_t _jGLfloat97 = 0; _jGLfloat97 < _aGLfloat97->values.size(); ++_jGLfloat97) {
        }
    }
}

static void retrace_glSelectBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei size;
    size = (call.arg(0)).toSInt();

    GLuint * buffer;
    buffer = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *buffer));
    _allocator.bind(buffer);

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSelectBuffer(size, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint67 = (call.arg(1)).toArray();
    if (_aGLuint67) {
        for (size_t _jGLuint67 = 0; _jGLuint67 < _aGLuint67->values.size(); ++_jGLuint67) {
        }
    }
}

static void retrace_glRenderMode(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glRenderMode(mode);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInitNames(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInitNames();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadName(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint name;
    name = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadName(name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPassThrough(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat token;
    token = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPassThrough(token);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPopName(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPopName();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPushName(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint name;
    name = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPushName(name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearAccum(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat red;
    red = (call.arg(0)).toFloat();

    GLfloat green;
    green = (call.arg(1)).toFloat();

    GLfloat blue;
    blue = (call.arg(2)).toFloat();

    GLfloat alpha;
    alpha = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearAccum(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearIndex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat c;
    c = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearIndex(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexMask(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexMask(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAccum(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat value;
    value = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAccum(op, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPopAttrib(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPopAttrib();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPushAttrib(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPushAttrib(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMap1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble u1;
    u1 = (call.arg(1)).toDouble();

    GLdouble u2;
    u2 = (call.arg(2)).toDouble();

    GLint stride;
    stride = (call.arg(3)).toSInt();

    GLint order;
    order = (call.arg(4)).toSInt();

    GLdouble * points;
    points = static_cast<GLdouble *>(_allocator.alloc(&call.arg(5), sizeof *points));
    if (points) {
        const trace::Array *_a_GLdouble39_0 = (call.arg(5)).toArray();
        for (size_t _jGLdouble39 = 0; _jGLdouble39 < _a_GLdouble39_0->values.size(); ++_jGLdouble39) {
    points[_jGLdouble39] = (*_a_GLdouble39_0->values[_jGLdouble39]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMap1d(target, u1, u2, stride, order, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMap1f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat u1;
    u1 = (call.arg(1)).toFloat();

    GLfloat u2;
    u2 = (call.arg(2)).toFloat();

    GLint stride;
    stride = (call.arg(3)).toSInt();

    GLint order;
    order = (call.arg(4)).toSInt();

    GLfloat * points;
    points = static_cast<GLfloat *>(_allocator.alloc(&call.arg(5), sizeof *points));
    if (points) {
        const trace::Array *_a_GLfloat98_0 = (call.arg(5)).toArray();
        for (size_t _jGLfloat98 = 0; _jGLfloat98 < _a_GLfloat98_0->values.size(); ++_jGLfloat98) {
    points[_jGLfloat98] = (*_a_GLfloat98_0->values[_jGLfloat98]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMap1f(target, u1, u2, stride, order, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMap2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble u1;
    u1 = (call.arg(1)).toDouble();

    GLdouble u2;
    u2 = (call.arg(2)).toDouble();

    GLint ustride;
    ustride = (call.arg(3)).toSInt();

    GLint uorder;
    uorder = (call.arg(4)).toSInt();

    GLdouble v1;
    v1 = (call.arg(5)).toDouble();

    GLdouble v2;
    v2 = (call.arg(6)).toDouble();

    GLint vstride;
    vstride = (call.arg(7)).toSInt();

    GLint vorder;
    vorder = (call.arg(8)).toSInt();

    GLdouble * points;
    points = static_cast<GLdouble *>(_allocator.alloc(&call.arg(9), sizeof *points));
    if (points) {
        const trace::Array *_a_GLdouble40_0 = (call.arg(9)).toArray();
        for (size_t _jGLdouble40 = 0; _jGLdouble40 < _a_GLdouble40_0->values.size(); ++_jGLdouble40) {
    points[_jGLdouble40] = (*_a_GLdouble40_0->values[_jGLdouble40]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMap2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat u1;
    u1 = (call.arg(1)).toFloat();

    GLfloat u2;
    u2 = (call.arg(2)).toFloat();

    GLint ustride;
    ustride = (call.arg(3)).toSInt();

    GLint uorder;
    uorder = (call.arg(4)).toSInt();

    GLfloat v1;
    v1 = (call.arg(5)).toFloat();

    GLfloat v2;
    v2 = (call.arg(6)).toFloat();

    GLint vstride;
    vstride = (call.arg(7)).toSInt();

    GLint vorder;
    vorder = (call.arg(8)).toSInt();

    GLfloat * points;
    points = static_cast<GLfloat *>(_allocator.alloc(&call.arg(9), sizeof *points));
    if (points) {
        const trace::Array *_a_GLfloat99_0 = (call.arg(9)).toArray();
        for (size_t _jGLfloat99 = 0; _jGLfloat99 < _a_GLfloat99_0->values.size(); ++_jGLfloat99) {
    points[_jGLfloat99] = (*_a_GLfloat99_0->values[_jGLfloat99]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapGrid1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint un;
    un = (call.arg(0)).toSInt();

    GLdouble u1;
    u1 = (call.arg(1)).toDouble();

    GLdouble u2;
    u2 = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapGrid1d(un, u1, u2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapGrid1f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint un;
    un = (call.arg(0)).toSInt();

    GLfloat u1;
    u1 = (call.arg(1)).toFloat();

    GLfloat u2;
    u2 = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapGrid1f(un, u1, u2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapGrid2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint un;
    un = (call.arg(0)).toSInt();

    GLdouble u1;
    u1 = (call.arg(1)).toDouble();

    GLdouble u2;
    u2 = (call.arg(2)).toDouble();

    GLint vn;
    vn = (call.arg(3)).toSInt();

    GLdouble v1;
    v1 = (call.arg(4)).toDouble();

    GLdouble v2;
    v2 = (call.arg(5)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapGrid2d(un, u1, u2, vn, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapGrid2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint un;
    un = (call.arg(0)).toSInt();

    GLfloat u1;
    u1 = (call.arg(1)).toFloat();

    GLfloat u2;
    u2 = (call.arg(2)).toFloat();

    GLint vn;
    vn = (call.arg(3)).toSInt();

    GLfloat v1;
    v1 = (call.arg(4)).toFloat();

    GLfloat v2;
    v2 = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapGrid2f(un, u1, u2, vn, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalCoord1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble u;
    u = (call.arg(0)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalCoord1d(u);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalCoord1dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * u;
    u = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *u));
    if (u) {
        const trace::Array *_a_PGLdouble3_0 = (call.arg(0)).toArray();
    u[0] = (*_a_PGLdouble3_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalCoord1dv(u);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalCoord1f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat u;
    u = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalCoord1f(u);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalCoord1fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * u;
    u = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *u));
    if (u) {
        const trace::Array *_a_PGLfloat13_0 = (call.arg(0)).toArray();
    u[0] = (*_a_PGLfloat13_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalCoord1fv(u);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalCoord2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble u;
    u = (call.arg(0)).toDouble();

    GLdouble v;
    v = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalCoord2d(u, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalCoord2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * u;
    u = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *u));
    if (u) {
        const trace::Array *_a_GLdouble41_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble41 = 0; _jGLdouble41 < _a_GLdouble41_0->values.size(); ++_jGLdouble41) {
    u[_jGLdouble41] = (*_a_GLdouble41_0->values[_jGLdouble41]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalCoord2dv(u);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalCoord2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat u;
    u = (call.arg(0)).toFloat();

    GLfloat v;
    v = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalCoord2f(u, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalCoord2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * u;
    u = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *u));
    if (u) {
        const trace::Array *_a_GLfloat100_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat100 = 0; _jGLfloat100 < _a_GLfloat100_0->values.size(); ++_jGLfloat100) {
    u[_jGLfloat100] = (*_a_GLfloat100_0->values[_jGLfloat100]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalCoord2fv(u);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalMesh1(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint i1;
    i1 = (call.arg(1)).toSInt();

    GLint i2;
    i2 = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalMesh1(mode, i1, i2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalPoint1(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint i;
    i = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalPoint1(i);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalMesh2(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint i1;
    i1 = (call.arg(1)).toSInt();

    GLint i2;
    i2 = (call.arg(2)).toSInt();

    GLint j1;
    j1 = (call.arg(3)).toSInt();

    GLint j2;
    j2 = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalMesh2(mode, i1, i2, j1, j2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalPoint2(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint i;
    i = (call.arg(0)).toSInt();

    GLint j;
    j = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalPoint2(i, j);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAlphaFunc(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum func;
    func = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat ref;
    ref = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAlphaFunc(func, ref);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelZoom(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat xfactor;
    xfactor = (call.arg(0)).toFloat();

    GLfloat yfactor;
    yfactor = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelZoom(xfactor, yfactor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTransferf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTransferf(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTransferi(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTransferi(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelMapfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei mapsize;
    mapsize = (call.arg(1)).toSInt();

    GLfloat * values;
    values = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *values));
    if (values) {
        const trace::Array *_a_GLfloat101_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat101 = 0; _jGLfloat101 < _a_GLfloat101_0->values.size(); ++_jGLfloat101) {
    values[_jGLfloat101] = (*_a_GLfloat101_0->values[_jGLfloat101]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelMapfv(map, mapsize, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelMapuiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei mapsize;
    mapsize = (call.arg(1)).toSInt();

    GLuint * values;
    values = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *values));
    if (values) {
        const trace::Array *_a_GLuint68_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint68 = 0; _jGLuint68 < _a_GLuint68_0->values.size(); ++_jGLuint68) {
    values[_jGLuint68] = (*_a_GLuint68_0->values[_jGLuint68]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelMapuiv(map, mapsize, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelMapusv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei mapsize;
    mapsize = (call.arg(1)).toSInt();

    GLushort * values;
    values = static_cast<GLushort *>(_allocator.alloc(&call.arg(2), sizeof *values));
    if (values) {
        const trace::Array *_a_GLushort4_0 = (call.arg(2)).toArray();
        for (size_t _jGLushort4 = 0; _jGLushort4 < _a_GLushort4_0->values.size(); ++_jGLushort4) {
    values[_jGLushort4] = (*_a_GLushort4_0->values[_jGLushort4]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelMapusv(map, mapsize, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyPixels(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyPixels(x, y, width, height, type);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawPixels(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei width;
    width = (call.arg(0)).toSInt();

    GLsizei height;
    height = (call.arg(1)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(4)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawPixels(width, height, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glGetPixelMapfv(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * values;
    values = static_cast<GLfloat *>((call.arg(1)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetPixelMapfv(map, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aPGLfloat1 = (call.arg(1)).toArray();
    if (_aPGLfloat1) {
    }
}

static void retrace_glGetPixelMapuiv(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * values;
    values = static_cast<GLuint *>((call.arg(1)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetPixelMapuiv(map, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aPGLuint19 = (call.arg(1)).toArray();
    if (_aPGLuint19) {
    }
}

static void retrace_glGetPixelMapusv(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLushort * values;
    values = static_cast<GLushort *>((call.arg(1)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetPixelMapusv(map, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aPGLushort = (call.arg(1)).toArray();
    if (_aPGLushort) {
    }
}

static void retrace_glGetPolygonStipple(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * mask;
    mask = static_cast<GLubyte *>((call.arg(0)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetPolygonStipple(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFrustum(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble left;
    left = (call.arg(0)).toDouble();

    GLdouble right;
    right = (call.arg(1)).toDouble();

    GLdouble bottom;
    bottom = (call.arg(2)).toDouble();

    GLdouble top;
    top = (call.arg(3)).toDouble();

    GLdouble zNear;
    zNear = (call.arg(4)).toDouble();

    GLdouble zFar;
    zFar = (call.arg(5)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFrustum(left, right, bottom, top, zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadIdentity(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadIdentity();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadMatrixf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat102_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat102 = 0; _jGLfloat102 < _a_GLfloat102_0->values.size(); ++_jGLfloat102) {
    m[_jGLfloat102] = (*_a_GLfloat102_0->values[_jGLfloat102]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadMatrixf(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadMatrixd(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble42_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble42 = 0; _jGLdouble42 < _a_GLdouble42_0->values.size(); ++_jGLdouble42) {
    m[_jGLdouble42] = (*_a_GLdouble42_0->values[_jGLdouble42]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadMatrixd(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixMode(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixMode(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultMatrixf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat103_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat103 = 0; _jGLfloat103 < _a_GLfloat103_0->values.size(); ++_jGLfloat103) {
    m[_jGLfloat103] = (*_a_GLfloat103_0->values[_jGLfloat103]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultMatrixf(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultMatrixd(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble43_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble43 = 0; _jGLdouble43 < _a_GLdouble43_0->values.size(); ++_jGLdouble43) {
    m[_jGLdouble43] = (*_a_GLdouble43_0->values[_jGLdouble43]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultMatrixd(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glOrtho(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble left;
    left = (call.arg(0)).toDouble();

    GLdouble right;
    right = (call.arg(1)).toDouble();

    GLdouble bottom;
    bottom = (call.arg(2)).toDouble();

    GLdouble top;
    top = (call.arg(3)).toDouble();

    GLdouble zNear;
    zNear = (call.arg(4)).toDouble();

    GLdouble zFar;
    zFar = (call.arg(5)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glOrtho(left, right, bottom, top, zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPopMatrix(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPopMatrix();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPushMatrix(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPushMatrix();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRotated(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble angle;
    angle = (call.arg(0)).toDouble();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRotated(angle, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRotatef(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat angle;
    angle = (call.arg(0)).toFloat();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRotatef(angle, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glScaled(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glScaled(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glScalef(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glScalef(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTranslated(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTranslated(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTranslatef(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTranslatef(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawArrays(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint first;
    first = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawArrays(mode, first, count);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawElements(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElements(mode, count, type, indices);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glPolygonOffset(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat factor;
    factor = (call.arg(0)).toFloat();

    GLfloat units;
    units = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPolygonOffset(factor, units);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexImage1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint x;
    x = (call.arg(3)).toSInt();

    GLint y;
    y = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexImage1D(target, level, internalformat, x, y, width, border);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexImage2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint x;
    x = (call.arg(3)).toSInt();

    GLint y;
    y = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexSubImage1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint x;
    x = (call.arg(3)).toSInt();

    GLint y;
    y = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexSubImage1D(target, level, xoffset, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexSubImage2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint x;
    x = (call.arg(4)).toSInt();

    GLint y;
    y = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexSubImage1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexSubImage2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(6)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(7)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindTexture(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint texture;
    texture = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindTexture(target, texture);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteTextures(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * textures;
    textures = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *textures));
    if (textures) {
        const trace::Array *_a_GLuint69_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint69 = 0; _jGLuint69 < _a_GLuint69_0->values.size(); ++_jGLuint69) {
    textures[_jGLuint69] = (*_a_GLuint69_0->values[_jGLuint69]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(textures[_jGLuint69]) << " <- " << size_t(_texture_map[textures[_jGLuint69]]) << "\n";
    }
    textures[_jGLuint69] = _texture_map[textures[_jGLuint69]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteTextures(n, textures);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenTextures(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * textures;
    textures = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *textures));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenTextures(n, textures);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint71 = (call.arg(1)).toArray();
    if (_aGLuint71) {
        for (size_t _jGLuint71 = 0; _jGLuint71 < _aGLuint71->values.size(); ++_jGLuint71) {
    GLuint _origResult;
    _origResult = (*_aGLuint71->values[_jGLuint71]).toUInt();
    _texture_map[_origResult] = textures[_jGLuint71];
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << _origResult << " -> " << textures[_jGLuint71] << "\n";
    }
        }
    }
}

static void retrace_glArrayElement(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint i;
    i = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glArrayElement(i);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = static_cast<GLint>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(3), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorPointer(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableClientState(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum array;
    array = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableClientState(array);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEdgeFlagPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei stride;
    stride = (call.arg(0)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(1), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEdgeFlagPointer(stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableClientState(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum array;
    array = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableClientState(array);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(2), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexPointer(type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInterleavedArrays(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum format;
    format = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(2), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInterleavedArrays(format, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(2), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalPointer(type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(3), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordPointer(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(3), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexPointer(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPrioritizeTextures(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * textures;
    textures = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *textures));
    if (textures) {
        const trace::Array *_a_GLuint72_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint72 = 0; _jGLuint72 < _a_GLuint72_0->values.size(); ++_jGLuint72) {
    textures[_jGLuint72] = (*_a_GLuint72_0->values[_jGLuint72]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(textures[_jGLuint72]) << " <- " << size_t(_texture_map[textures[_jGLuint72]]) << "\n";
    }
    textures[_jGLuint72] = _texture_map[textures[_jGLuint72]];
        }
    }

    GLclampf * priorities;
    priorities = static_cast<GLclampf *>(_allocator.alloc(&call.arg(2), sizeof *priorities));
    if (priorities) {
        const trace::Array *_a_GLclampf1_0 = (call.arg(2)).toArray();
        for (size_t _jGLclampf1 = 0; _jGLclampf1 < _a_GLclampf1_0->values.size(); ++_jGLclampf1) {
    priorities[_jGLclampf1] = (*_a_GLclampf1_0->values[_jGLclampf1]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPrioritizeTextures(n, textures, priorities);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexub(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte c;
    c = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexub(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexubv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * c;
    c = static_cast<GLubyte *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_PGLubyte1_0 = (call.arg(0)).toArray();
    c[0] = (*_a_PGLubyte1_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexubv(c);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPopClientAttrib(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPopClientAttrib();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPushClientAttrib(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPushClientAttrib(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendColor(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat red;
    red = (call.arg(0)).toFloat();

    GLfloat green;
    green = (call.arg(1)).toFloat();

    GLfloat blue;
    blue = (call.arg(2)).toFloat();

    GLfloat alpha;
    alpha = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendColor(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquation(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquation(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawRangeElements(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint start;
    start = (call.arg(1)).toUInt();

    GLuint end;
    end = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawRangeElements(mode, start, end, count, type, indices);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glTexImage3D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(8)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexSubImage3D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLsizei depth;
    depth = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(9)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(10)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexSubImage3D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLint x;
    x = (call.arg(5)).toSInt();

    GLint y;
    y = (call.arg(6)).toSInt();

    GLsizei width;
    width = (call.arg(7)).toSInt();

    GLsizei height;
    height = (call.arg(8)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorTable(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * table;
    table = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorTable(target, internalformat, width, format, type, table);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorTableParameterfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat104_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat104 = 0; _jGLfloat104 < _a_GLfloat104_0->values.size(); ++_jGLfloat104) {
    params[_jGLfloat104] = (*_a_GLfloat104_0->values[_jGLfloat104]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorTableParameterfv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorTableParameteriv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint131_0 = (call.arg(2)).toArray();
        for (size_t _jGLint131 = 0; _jGLint131 < _a_GLint131_0->values.size(); ++_jGLint131) {
    params[_jGLint131] = (*_a_GLint131_0->values[_jGLint131]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorTableParameteriv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyColorTable(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyColorTable(target, internalformat, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorSubTable(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei start;
    start = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorSubTable(target, start, count, format, type, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyColorSubTable(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei start;
    start = (call.arg(1)).toSInt();

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyColorSubTable(target, start, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionFilter1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * image;
    image = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionFilter1D(target, internalformat, width, format, type, image);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionFilter2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLvoid * image;
    image = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionFilter2D(target, internalformat, width, height, format, type, image);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionParameterf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat params;
    params = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionParameterf(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionParameterfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat105_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat105 = 0; _jGLfloat105 < _a_GLfloat105_0->values.size(); ++_jGLfloat105) {
    params[_jGLfloat105] = (*_a_GLfloat105_0->values[_jGLfloat105]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionParameterfv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionParameteri(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint params;
    params = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionParameteri(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionParameteriv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint132_0 = (call.arg(2)).toArray();
        for (size_t _jGLint132 = 0; _jGLint132 < _a_GLint132_0->values.size(); ++_jGLint132) {
    params[_jGLint132] = (*_a_GLint132_0->values[_jGLint132]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionParameteriv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyConvolutionFilter1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyConvolutionFilter1D(target, internalformat, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyConvolutionFilter2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetConvolutionFilter(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLvoid * image;
    image = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetConvolutionFilter(target, format, type, image);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetSeparableFilter(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLvoid * row;
    row = static_cast<GLvoid *>((call.arg(3)).toPointer());

    GLvoid * column;
    column = static_cast<GLvoid *>((call.arg(4)).toPointer());

    GLvoid * span;
    span = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetSeparableFilter(target, format, type, row, column, span);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSeparableFilter2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLvoid * row;
    row = static_cast<GLvoid *>((call.arg(6)).toPointer());

    GLvoid * column;
    column = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSeparableFilter2D(target, internalformat, width, height, format, type, row, column);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetHistogram(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLboolean reset;
    reset = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLvoid * values;
    values = static_cast<GLvoid *>((call.arg(4)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetHistogram(target, reset, format, type, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetMinmax(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLboolean reset;
    reset = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLvoid * values;
    values = static_cast<GLvoid *>((call.arg(4)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetMinmax(target, reset, format, type, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glHistogram(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei width;
    width = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLboolean sink;
    sink = static_cast<GLboolean>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glHistogram(target, width, internalformat, sink);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMinmax(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean sink;
    sink = static_cast<GLboolean>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMinmax(target, internalformat, sink);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glResetHistogram(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glResetHistogram(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glResetMinmax(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glResetMinmax(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glActiveTexture(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glActiveTexture(texture);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSampleCoverage(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat value;
    value = (call.arg(0)).toFloat();

    GLboolean invert;
    invert = static_cast<GLboolean>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSampleCoverage(value, invert);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexImage3D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(7)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexImage2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLint border;
    border = (call.arg(5)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(6)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexImage1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLint border;
    border = (call.arg(4)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(5)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexSubImage3D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLsizei depth;
    depth = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(9)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(10)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexSubImage2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(6)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(7)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexSubImage1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(5)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetCompressedTexImage(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLvoid * img;
    img = static_cast<GLvoid *>((call.arg(2)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetCompressedTexImage(target, level, img);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClientActiveTexture(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClientActiveTexture(texture);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble s;
    s = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1d(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLdouble4_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLdouble4_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1dv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat s;
    s = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1f(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLfloat14_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLfloat14_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1fv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint s;
    s = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1i(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLint26_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLint26_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1iv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort s;
    s = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1s(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLshort2_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLshort2_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1sv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble s;
    s = (call.arg(1)).toDouble();

    GLdouble t;
    t = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2d(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble44_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble44 = 0; _jGLdouble44 < _a_GLdouble44_0->values.size(); ++_jGLdouble44) {
    v[_jGLdouble44] = (*_a_GLdouble44_0->values[_jGLdouble44]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2dv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2f(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat106_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat106 = 0; _jGLfloat106 < _a_GLfloat106_0->values.size(); ++_jGLfloat106) {
    v[_jGLfloat106] = (*_a_GLfloat106_0->values[_jGLfloat106]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2fv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint s;
    s = (call.arg(1)).toSInt();

    GLint t;
    t = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2i(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint133_0 = (call.arg(1)).toArray();
        for (size_t _jGLint133 = 0; _jGLint133 < _a_GLint133_0->values.size(); ++_jGLint133) {
    v[_jGLint133] = (*_a_GLint133_0->values[_jGLint133]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2iv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort s;
    s = (call.arg(1)).toSInt();

    GLshort t;
    t = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2s(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort15_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort15 = 0; _jGLshort15 < _a_GLshort15_0->values.size(); ++_jGLshort15) {
    v[_jGLshort15] = (*_a_GLshort15_0->values[_jGLshort15]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2sv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble s;
    s = (call.arg(1)).toDouble();

    GLdouble t;
    t = (call.arg(2)).toDouble();

    GLdouble r;
    r = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3d(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble45_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble45 = 0; _jGLdouble45 < _a_GLdouble45_0->values.size(); ++_jGLdouble45) {
    v[_jGLdouble45] = (*_a_GLdouble45_0->values[_jGLdouble45]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3dv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    GLfloat r;
    r = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3f(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat107_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat107 = 0; _jGLfloat107 < _a_GLfloat107_0->values.size(); ++_jGLfloat107) {
    v[_jGLfloat107] = (*_a_GLfloat107_0->values[_jGLfloat107]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3fv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint s;
    s = (call.arg(1)).toSInt();

    GLint t;
    t = (call.arg(2)).toSInt();

    GLint r;
    r = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3i(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint134_0 = (call.arg(1)).toArray();
        for (size_t _jGLint134 = 0; _jGLint134 < _a_GLint134_0->values.size(); ++_jGLint134) {
    v[_jGLint134] = (*_a_GLint134_0->values[_jGLint134]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3iv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort s;
    s = (call.arg(1)).toSInt();

    GLshort t;
    t = (call.arg(2)).toSInt();

    GLshort r;
    r = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3s(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort16_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort16 = 0; _jGLshort16 < _a_GLshort16_0->values.size(); ++_jGLshort16) {
    v[_jGLshort16] = (*_a_GLshort16_0->values[_jGLshort16]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3sv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble s;
    s = (call.arg(1)).toDouble();

    GLdouble t;
    t = (call.arg(2)).toDouble();

    GLdouble r;
    r = (call.arg(3)).toDouble();

    GLdouble q;
    q = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4d(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble46_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble46 = 0; _jGLdouble46 < _a_GLdouble46_0->values.size(); ++_jGLdouble46) {
    v[_jGLdouble46] = (*_a_GLdouble46_0->values[_jGLdouble46]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4dv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    GLfloat r;
    r = (call.arg(3)).toFloat();

    GLfloat q;
    q = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4f(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat108_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat108 = 0; _jGLfloat108 < _a_GLfloat108_0->values.size(); ++_jGLfloat108) {
    v[_jGLfloat108] = (*_a_GLfloat108_0->values[_jGLfloat108]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4fv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint s;
    s = (call.arg(1)).toSInt();

    GLint t;
    t = (call.arg(2)).toSInt();

    GLint r;
    r = (call.arg(3)).toSInt();

    GLint q;
    q = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4i(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint135_0 = (call.arg(1)).toArray();
        for (size_t _jGLint135 = 0; _jGLint135 < _a_GLint135_0->values.size(); ++_jGLint135) {
    v[_jGLint135] = (*_a_GLint135_0->values[_jGLint135]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4iv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort s;
    s = (call.arg(1)).toSInt();

    GLshort t;
    t = (call.arg(2)).toSInt();

    GLshort r;
    r = (call.arg(3)).toSInt();

    GLshort q;
    q = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4s(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort17_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort17 = 0; _jGLshort17 < _a_GLshort17_0->values.size(); ++_jGLshort17) {
    v[_jGLshort17] = (*_a_GLshort17_0->values[_jGLshort17]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4sv(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadTransposeMatrixf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat109_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat109 = 0; _jGLfloat109 < _a_GLfloat109_0->values.size(); ++_jGLfloat109) {
    m[_jGLfloat109] = (*_a_GLfloat109_0->values[_jGLfloat109]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadTransposeMatrixf(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadTransposeMatrixd(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble47_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble47 = 0; _jGLdouble47 < _a_GLdouble47_0->values.size(); ++_jGLdouble47) {
    m[_jGLdouble47] = (*_a_GLdouble47_0->values[_jGLdouble47]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadTransposeMatrixd(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultTransposeMatrixf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat110_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat110 = 0; _jGLfloat110 < _a_GLfloat110_0->values.size(); ++_jGLfloat110) {
    m[_jGLfloat110] = (*_a_GLfloat110_0->values[_jGLfloat110]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultTransposeMatrixf(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultTransposeMatrixd(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble48_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble48 = 0; _jGLdouble48 < _a_GLdouble48_0->values.size(); ++_jGLdouble48) {
    m[_jGLdouble48] = (*_a_GLdouble48_0->values[_jGLdouble48]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultTransposeMatrixd(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFuncSeparate(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum sfactorRGB;
    sfactorRGB = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum dfactorRGB;
    dfactorRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum sfactorAlpha;
    sfactorAlpha = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum dfactorAlpha;
    dfactorAlpha = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiDrawArrays(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * first;
    first = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *first));
    if (first) {
        const trace::Array *_a_GLint136_0 = (call.arg(1)).toArray();
        for (size_t _jGLint136 = 0; _jGLint136 < _a_GLint136_0->values.size(); ++_jGLint136) {
    first[_jGLint136] = (*_a_GLint136_0->values[_jGLint136]).toSInt();
        }
    }

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(2), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei4_0 = (call.arg(2)).toArray();
        for (size_t _jGLsizei4 = 0; _jGLsizei4 < _a_GLsizei4_0->values.size(); ++_jGLsizei4) {
    count[_jGLsizei4] = (*_a_GLsizei4_0->values[_jGLsizei4]).toSInt();
        }
    }

    GLsizei drawcount;
    drawcount = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawArrays(mode, first, count, drawcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glMultiDrawElements(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(1), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei5_0 = (call.arg(1)).toArray();
        for (size_t _jGLsizei5 = 0; _jGLsizei5 < _a_GLsizei5_0->values.size(); ++_jGLsizei5) {
    count[_jGLsizei5] = (*_a_GLsizei5_0->values[_jGLsizei5]).toSInt();
        }
    }

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * * indices;
    indices = static_cast<const GLvoid * *>(_allocator.alloc(&call.arg(3), sizeof *indices));
    if (indices) {
        const trace::Array *_a_constGLvoid164_0 = (call.arg(3)).toArray();
        for (size_t _jconstGLvoid164 = 0; _jconstGLvoid164 < _a_constGLvoid164_0->values.size(); ++_jconstGLvoid164) {
    indices[_jconstGLvoid164] = static_cast<const GLvoid *>((*_a_constGLvoid164_0->values[_jconstGLvoid164]).toPointer());
        }
    }

    GLsizei drawcount;
    drawcount = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawElements(mode, count, type, indices, drawcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glPointParameterf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterf(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat111_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat111 = 0; _jGLfloat111 < _a_GLfloat111_0->values.size(); ++_jGLfloat111) {
    params[_jGLfloat111] = (*_a_GLfloat111_0->values[_jGLfloat111]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterfv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameteri(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameteri(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameteriv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint137_0 = (call.arg(1)).toArray();
        for (size_t _jGLint137 = 0; _jGLint137 < _a_GLint137_0->values.size(); ++_jGLint137) {
    params[_jGLint137] = (*_a_GLint137_0->values[_jGLint137]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameteriv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat coord;
    coord = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordf(coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * coord;
    coord = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *coord));
    if (coord) {
        const trace::Array *_a_PGLfloat15_0 = (call.arg(0)).toArray();
    coord[0] = (*_a_PGLfloat15_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordfv(coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordd(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble coord;
    coord = (call.arg(0)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordd(coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoorddv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * coord;
    coord = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *coord));
    if (coord) {
        const trace::Array *_a_PGLdouble5_0 = (call.arg(0)).toArray();
    coord[0] = (*_a_PGLdouble5_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoorddv(coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(2), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordPointer(type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3b(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte red;
    red = (call.arg(0)).toSInt();

    GLbyte green;
    green = (call.arg(1)).toSInt();

    GLbyte blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3b(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3bv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte4_0 = (call.arg(0)).toArray();
        for (size_t _jGLbyte4 = 0; _jGLbyte4 < _a_GLbyte4_0->values.size(); ++_jGLbyte4) {
    v[_jGLbyte4] = (*_a_GLbyte4_0->values[_jGLbyte4]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3bv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble red;
    red = (call.arg(0)).toDouble();

    GLdouble green;
    green = (call.arg(1)).toDouble();

    GLdouble blue;
    blue = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3d(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble49_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble49 = 0; _jGLdouble49 < _a_GLdouble49_0->values.size(); ++_jGLdouble49) {
    v[_jGLdouble49] = (*_a_GLdouble49_0->values[_jGLdouble49]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat red;
    red = (call.arg(0)).toFloat();

    GLfloat green;
    green = (call.arg(1)).toFloat();

    GLfloat blue;
    blue = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3f(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat112_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat112 = 0; _jGLfloat112 < _a_GLfloat112_0->values.size(); ++_jGLfloat112) {
    v[_jGLfloat112] = (*_a_GLfloat112_0->values[_jGLfloat112]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint red;
    red = (call.arg(0)).toSInt();

    GLint green;
    green = (call.arg(1)).toSInt();

    GLint blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3i(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint138_0 = (call.arg(0)).toArray();
        for (size_t _jGLint138 = 0; _jGLint138 < _a_GLint138_0->values.size(); ++_jGLint138) {
    v[_jGLint138] = (*_a_GLint138_0->values[_jGLint138]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort red;
    red = (call.arg(0)).toSInt();

    GLshort green;
    green = (call.arg(1)).toSInt();

    GLshort blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3s(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort18_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort18 = 0; _jGLshort18 < _a_GLshort18_0->values.size(); ++_jGLshort18) {
    v[_jGLshort18] = (*_a_GLshort18_0->values[_jGLshort18]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3ub(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte red;
    red = (call.arg(0)).toUInt();

    GLubyte green;
    green = (call.arg(1)).toUInt();

    GLubyte blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3ub(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3ubv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte8_0 = (call.arg(0)).toArray();
        for (size_t _jGLubyte8 = 0; _jGLubyte8 < _a_GLubyte8_0->values.size(); ++_jGLubyte8) {
    v[_jGLubyte8] = (*_a_GLubyte8_0->values[_jGLubyte8]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3ubv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint red;
    red = (call.arg(0)).toUInt();

    GLuint green;
    green = (call.arg(1)).toUInt();

    GLuint blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3ui(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint73_0 = (call.arg(0)).toArray();
        for (size_t _jGLuint73 = 0; _jGLuint73 < _a_GLuint73_0->values.size(); ++_jGLuint73) {
    v[_jGLuint73] = (*_a_GLuint73_0->values[_jGLuint73]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3uiv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3us(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort red;
    red = (call.arg(0)).toUInt();

    GLushort green;
    green = (call.arg(1)).toUInt();

    GLushort blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3us(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3usv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort5_0 = (call.arg(0)).toArray();
        for (size_t _jGLushort5 = 0; _jGLushort5 < _a_GLushort5_0->values.size(); ++_jGLushort5) {
    v[_jGLushort5] = (*_a_GLushort5_0->values[_jGLushort5]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3usv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColorPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = static_cast<GLint>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(3), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColorPointer(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2d(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble50_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble50 = 0; _jGLdouble50 < _a_GLdouble50_0->values.size(); ++_jGLdouble50) {
    v[_jGLdouble50] = (*_a_GLdouble50_0->values[_jGLdouble50]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2f(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat113_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat113 = 0; _jGLfloat113 < _a_GLfloat113_0->values.size(); ++_jGLfloat113) {
    v[_jGLfloat113] = (*_a_GLfloat113_0->values[_jGLfloat113]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2i(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint139_0 = (call.arg(0)).toArray();
        for (size_t _jGLint139 = 0; _jGLint139 < _a_GLint139_0->values.size(); ++_jGLint139) {
    v[_jGLint139] = (*_a_GLint139_0->values[_jGLint139]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2s(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort19_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort19 = 0; _jGLshort19 < _a_GLshort19_0->values.size(); ++_jGLshort19) {
    v[_jGLshort19] = (*_a_GLshort19_0->values[_jGLshort19]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3d(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble51_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble51 = 0; _jGLdouble51 < _a_GLdouble51_0->values.size(); ++_jGLdouble51) {
    v[_jGLdouble51] = (*_a_GLdouble51_0->values[_jGLdouble51]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3dv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3f(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat114_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat114 = 0; _jGLfloat114 < _a_GLfloat114_0->values.size(); ++_jGLfloat114) {
    v[_jGLfloat114] = (*_a_GLfloat114_0->values[_jGLfloat114]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3fv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3i(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint140_0 = (call.arg(0)).toArray();
        for (size_t _jGLint140 = 0; _jGLint140 < _a_GLint140_0->values.size(); ++_jGLint140) {
    v[_jGLint140] = (*_a_GLint140_0->values[_jGLint140]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3iv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3s(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort20_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort20 = 0; _jGLshort20 < _a_GLshort20_0->values.size(); ++_jGLshort20) {
    v[_jGLshort20] = (*_a_GLshort20_0->values[_jGLshort20]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3sv(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenQueries(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenQueries(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint75 = (call.arg(1)).toArray();
    if (_aGLuint75) {
        for (size_t _jGLuint75 = 0; _jGLuint75 < _aGLuint75->values.size(); ++_jGLuint75) {
    GLuint _origResult;
    _origResult = (*_aGLuint75->values[_jGLuint75]).toUInt();
    _query_map[_origResult] = ids[_jGLuint75];
    if (retrace::verbosity >= 2) {
        std::cout << "query " << _origResult << " -> " << ids[_jGLuint75] << "\n";
    }
        }
    }
}

static void retrace_glDeleteQueries(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint76_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint76 = 0; _jGLuint76 < _a_GLuint76_0->values.size(); ++_jGLuint76) {
    ids[_jGLuint76] = (*_a_GLuint76_0->values[_jGLuint76]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(ids[_jGLuint76]) << " <- " << size_t(_query_map[ids[_jGLuint76]]) << "\n";
    }
    ids[_jGLuint76] = _query_map[ids[_jGLuint76]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteQueries(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginQuery(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(id) << " <- " << size_t(_query_map[id]) << "\n";
    }
    id = _query_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginQuery(target, id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndQuery(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndQuery(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBuffer(target, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteBuffers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * buffer;
    buffer = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *buffer));
    if (buffer) {
        const trace::Array *_a_GLuint77_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint77 = 0; _jGLuint77 < _a_GLuint77_0->values.size(); ++_jGLuint77) {
    buffer[_jGLuint77] = (*_a_GLuint77_0->values[_jGLuint77]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer[_jGLuint77]) << " <- " << size_t(_buffer_map[buffer[_jGLuint77]]) << "\n";
    }
    buffer[_jGLuint77] = _buffer_map[buffer[_jGLuint77]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteBuffers(n, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenBuffers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * buffer;
    buffer = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *buffer));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenBuffers(n, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint79 = (call.arg(1)).toArray();
    if (_aGLuint79) {
        for (size_t _jGLuint79 = 0; _jGLuint79 < _aGLuint79->values.size(); ++_jGLuint79) {
    GLuint _origResult;
    _origResult = (*_aGLuint79->values[_jGLuint79]).toUInt();
    _buffer_map[_origResult] = buffer[_jGLuint79];
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << _origResult << " -> " << buffer[_jGLuint79] << "\n";
    }
        }
    }
}

static void retrace_glBufferData(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizeiptr size;
    size = (call.arg(1)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLenum usage;
    usage = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBufferData(target, size, data, usage);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBufferSubData(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLintptr offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptr size;
    size = (call.arg(2)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBufferSubData(target, offset, size, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum access;
    access = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glMapBuffer(target, access);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to map buffer\n";
        }
    }
    GLint length = 0;
    glGetBufferParameteriv(target, GL_BUFFER_SIZE, &length);
    retrace::addRegion((*call.ret).toUIntPtr(), _result, length);
}

static void retrace_glUnmapBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLboolean _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
        GLvoid *ptr = NULL;
            glGetBufferPointerv(target, GL_BUFFER_MAP_POINTER, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "no current context\n";
        }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glUnmapBuffer(target);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to unmap buffer\n";
        }
    }
}

static void retrace_glBlendEquationSeparate(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum modeRGB;
    modeRGB = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum modeAlpha;
    modeAlpha = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationSeparate(modeRGB, modeAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawBuffers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLenum * bufs;
    bufs = static_cast<GLenum *>(_allocator.alloc(&call.arg(1), sizeof *bufs));
    if (bufs) {
        const trace::Array *_a_GLenum10_0 = (call.arg(1)).toArray();
        for (size_t _jGLenum10 = 0; _jGLenum10 < _a_GLenum10_0->values.size(); ++_jGLenum10) {
    bufs[_jGLenum10] = static_cast<GLenum>((*_a_GLenum10_0->values[_jGLenum10]).toSInt());
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawBuffers(n, bufs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilOpSeparate(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum sfail;
    sfail = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum dpfail;
    dpfail = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum dppass;
    dppass = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilOpSeparate(face, sfail, dpfail, dppass);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilFuncSeparate(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum func;
    func = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint ref;
    ref = (call.arg(2)).toSInt();

    GLuint mask;
    mask = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilFuncSeparate(face, func, ref, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilMaskSeparate(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint mask;
    mask = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilMaskSeparate(face, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAttachShader(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLuint shader;
    shader = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "shader " << size_t(shader) << " <- " << size_t(_shader_map[shader]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAttachShader(program, shader);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindAttribLocation(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLuint index;
    index = (call.arg(1)).toUInt();

    const GLchar * name;
    name = (const GLchar *)((call.arg(2)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindAttribLocation(program, index, name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompileShader(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint shader;
    shader = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "shader " << size_t(shader) << " <- " << size_t(_shader_map[shader]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompileShader(shader);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        GLint compile_status = 0;
        glGetShaderiv(shader, GL_COMPILE_STATUS, &compile_status);
        if (!compile_status) {
             GLint info_log_length = 0;
             glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_log_length);
             GLchar *infoLog = new GLchar[info_log_length];
             glGetShaderInfoLog(shader, info_log_length, NULL, infoLog);
             retrace::warning(call) << infoLog << "\n";
             delete [] infoLog;
        }
    }
}

static void retrace_glCreateProgram(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCreateProgram();
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLuint _origResult;
    _origResult = (*call.ret).toUInt();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _program_map[_origResult] = _result;
}
    if (retrace::verbosity >= 2) {
        std::cout << "program " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glCreateShader(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCreateShader(type);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLuint _origResult;
    _origResult = (*call.ret).toUInt();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _shader_map[_origResult] = _result;
}
    if (retrace::verbosity >= 2) {
        std::cout << "shader " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glDeleteProgram(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteProgram(program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteShader(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint shader;
    shader = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "shader " << size_t(shader) << " <- " << size_t(_shader_map[shader]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteShader(shader);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDetachShader(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLuint shader;
    shader = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "shader " << size_t(shader) << " <- " << size_t(_shader_map[shader]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDetachShader(program, shader);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableVertexAttribArray(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableVertexAttribArray(index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableVertexAttribArray(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableVertexAttribArray(index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetAttribLocation(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    const GLchar * name;
    name = (const GLchar *)((call.arg(1)).toString());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetAttribLocation(program, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    GLint _origResult = call.ret->toSInt();
    if (_result != _origResult) {
        retrace::warning(call) << "vertex attrib location mismatch " << _origResult << " -> " << _result << "\n";
    }
    }
}

static void retrace_glGetUniformLocation(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    const GLchar * name;
    name = (const GLchar *)((call.arg(1)).toString());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetUniformLocation(program, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLint _origResult;
    _origResult = (*call.ret).toSInt();
    _location_map[program][_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "location " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glLinkProgram(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLinkProgram(program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        GLint link_status = 0;
        glGetProgramiv(program, GL_LINK_STATUS, &link_status);
        if (!link_status) {
             GLint info_log_length = 0;
             glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
             GLchar *infoLog = new GLchar[info_log_length];
             glGetProgramInfoLog(program, info_log_length, NULL, infoLog);
             retrace::warning(call) << infoLog << "\n";
             delete [] infoLog;
        }
    }
}

static void retrace_glShaderSource(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint shader;
    shader = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "shader " << size_t(shader) << " <- " << size_t(_shader_map[shader]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    GLsizei count;
    count = (call.arg(1)).toSInt();

    const GLchar * * string;
    string = static_cast<const GLchar * *>(_allocator.alloc(&call.arg(2), sizeof *string));
    if (string) {
        const trace::Array *_a_constGLchar21_0 = (call.arg(2)).toArray();
        for (size_t _jconstGLchar21 = 0; _jconstGLchar21 < _a_constGLchar21_0->values.size(); ++_jconstGLchar21) {
    string[_jconstGLchar21] = (const GLchar *)((*_a_constGLchar21_0->values[_jconstGLchar21]).toString());
        }
    }

    GLint * length;
    length = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *length));
    if (length) {
        const trace::Array *_a_GLint141_0 = (call.arg(3)).toArray();
        for (size_t _jGLint141 = 0; _jGLint141 < _a_GLint141_0->values.size(); ++_jGLint141) {
    length[_jGLint141] = (*_a_GLint141_0->values[_jGLint141]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glShaderSource(shader, count, string, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUseProgram(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    glretrace::Context *currentContext = glretrace::getCurrentContext();
    if (currentContext) {
        currentContext->activeProgram = call.arg(0).toUInt();
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUseProgram(program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1f(location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(1)).toFloat();

    GLfloat v1;
    v1 = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2f(location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(1)).toFloat();

    GLfloat v1;
    v1 = (call.arg(2)).toFloat();

    GLfloat v2;
    v2 = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3f(location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(1)).toFloat();

    GLfloat v1;
    v1 = (call.arg(2)).toFloat();

    GLfloat v2;
    v2 = (call.arg(3)).toFloat();

    GLfloat v3;
    v3 = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4f(location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1i(location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(1)).toSInt();

    GLint v1;
    v1 = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2i(location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(1)).toSInt();

    GLint v1;
    v1 = (call.arg(2)).toSInt();

    GLint v2;
    v2 = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3i(location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(1)).toSInt();

    GLint v1;
    v1 = (call.arg(2)).toSInt();

    GLint v2;
    v2 = (call.arg(3)).toSInt();

    GLint v3;
    v3 = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4i(location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat115_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat115 = 0; _jGLfloat115 < _a_GLfloat115_0->values.size(); ++_jGLfloat115) {
    value[_jGLfloat115] = (*_a_GLfloat115_0->values[_jGLfloat115]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1fv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat116_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat116 = 0; _jGLfloat116 < _a_GLfloat116_0->values.size(); ++_jGLfloat116) {
    value[_jGLfloat116] = (*_a_GLfloat116_0->values[_jGLfloat116]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2fv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat117_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat117 = 0; _jGLfloat117 < _a_GLfloat117_0->values.size(); ++_jGLfloat117) {
    value[_jGLfloat117] = (*_a_GLfloat117_0->values[_jGLfloat117]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3fv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat118_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat118 = 0; _jGLfloat118 < _a_GLfloat118_0->values.size(); ++_jGLfloat118) {
    value[_jGLfloat118] = (*_a_GLfloat118_0->values[_jGLfloat118]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4fv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint142_0 = (call.arg(2)).toArray();
        for (size_t _jGLint142 = 0; _jGLint142 < _a_GLint142_0->values.size(); ++_jGLint142) {
    value[_jGLint142] = (*_a_GLint142_0->values[_jGLint142]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1iv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint143_0 = (call.arg(2)).toArray();
        for (size_t _jGLint143 = 0; _jGLint143 < _a_GLint143_0->values.size(); ++_jGLint143) {
    value[_jGLint143] = (*_a_GLint143_0->values[_jGLint143]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2iv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint144_0 = (call.arg(2)).toArray();
        for (size_t _jGLint144 = 0; _jGLint144 < _a_GLint144_0->values.size(); ++_jGLint144) {
    value[_jGLint144] = (*_a_GLint144_0->values[_jGLint144]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3iv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint145_0 = (call.arg(2)).toArray();
        for (size_t _jGLint145 = 0; _jGLint145 < _a_GLint145_0->values.size(); ++_jGLint145) {
    value[_jGLint145] = (*_a_GLint145_0->values[_jGLint145]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4iv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat119_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat119 = 0; _jGLfloat119 < _a_GLfloat119_0->values.size(); ++_jGLfloat119) {
    value[_jGLfloat119] = (*_a_GLfloat119_0->values[_jGLfloat119]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix2fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat120_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat120 = 0; _jGLfloat120 < _a_GLfloat120_0->values.size(); ++_jGLfloat120) {
    value[_jGLfloat120] = (*_a_GLfloat120_0->values[_jGLfloat120]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix3fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat121_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat121 = 0; _jGLfloat121 < _a_GLfloat121_0->values.size(); ++_jGLfloat121) {
    value[_jGLfloat121] = (*_a_GLfloat121_0->values[_jGLfloat121]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix4fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glValidateProgram(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glValidateProgram(program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1d(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLdouble6_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLdouble6_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1dv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1f(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLfloat16_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLfloat16_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1fv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1s(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLshort3_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLshort3_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1sv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2d(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble52_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble52 = 0; _jGLdouble52 < _a_GLdouble52_0->values.size(); ++_jGLdouble52) {
    v[_jGLdouble52] = (*_a_GLdouble52_0->values[_jGLdouble52]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2dv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2f(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat122_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat122 = 0; _jGLfloat122 < _a_GLfloat122_0->values.size(); ++_jGLfloat122) {
    v[_jGLfloat122] = (*_a_GLfloat122_0->values[_jGLfloat122]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2fv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2s(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort21_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort21 = 0; _jGLshort21 < _a_GLshort21_0->values.size(); ++_jGLshort21) {
    v[_jGLshort21] = (*_a_GLshort21_0->values[_jGLshort21]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2sv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3d(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble53_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble53 = 0; _jGLdouble53 < _a_GLdouble53_0->values.size(); ++_jGLdouble53) {
    v[_jGLdouble53] = (*_a_GLdouble53_0->values[_jGLdouble53]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3dv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3f(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat123_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat123 = 0; _jGLfloat123 < _a_GLfloat123_0->values.size(); ++_jGLfloat123) {
    v[_jGLfloat123] = (*_a_GLfloat123_0->values[_jGLfloat123]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3fv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    GLshort z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3s(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort22_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort22 = 0; _jGLshort22 < _a_GLshort22_0->values.size(); ++_jGLshort22) {
    v[_jGLshort22] = (*_a_GLshort22_0->values[_jGLshort22]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3sv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4Nbv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte5_0 = (call.arg(1)).toArray();
        for (size_t _jGLbyte5 = 0; _jGLbyte5 < _a_GLbyte5_0->values.size(); ++_jGLbyte5) {
    v[_jGLbyte5] = (*_a_GLbyte5_0->values[_jGLbyte5]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4Nbv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4Niv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint146_0 = (call.arg(1)).toArray();
        for (size_t _jGLint146 = 0; _jGLint146 < _a_GLint146_0->values.size(); ++_jGLint146) {
    v[_jGLint146] = (*_a_GLint146_0->values[_jGLint146]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4Niv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4Nsv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort23_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort23 = 0; _jGLshort23 < _a_GLshort23_0->values.size(); ++_jGLshort23) {
    v[_jGLshort23] = (*_a_GLshort23_0->values[_jGLshort23]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4Nsv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4Nub(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte x;
    x = (call.arg(1)).toUInt();

    GLubyte y;
    y = (call.arg(2)).toUInt();

    GLubyte z;
    z = (call.arg(3)).toUInt();

    GLubyte w;
    w = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4Nub(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4Nubv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte9_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte9 = 0; _jGLubyte9 < _a_GLubyte9_0->values.size(); ++_jGLubyte9) {
    v[_jGLubyte9] = (*_a_GLubyte9_0->values[_jGLubyte9]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4Nubv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4Nuiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint80_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint80 = 0; _jGLuint80 < _a_GLuint80_0->values.size(); ++_jGLuint80) {
    v[_jGLuint80] = (*_a_GLuint80_0->values[_jGLuint80]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4Nuiv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4Nusv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort6_0 = (call.arg(1)).toArray();
        for (size_t _jGLushort6 = 0; _jGLushort6 < _a_GLushort6_0->values.size(); ++_jGLushort6) {
    v[_jGLushort6] = (*_a_GLushort6_0->values[_jGLushort6]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4Nusv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4bv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte6_0 = (call.arg(1)).toArray();
        for (size_t _jGLbyte6 = 0; _jGLbyte6 < _a_GLbyte6_0->values.size(); ++_jGLbyte6) {
    v[_jGLbyte6] = (*_a_GLbyte6_0->values[_jGLbyte6]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4bv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    GLdouble w;
    w = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4d(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble54_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble54 = 0; _jGLdouble54 < _a_GLdouble54_0->values.size(); ++_jGLdouble54) {
    v[_jGLdouble54] = (*_a_GLdouble54_0->values[_jGLdouble54]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4dv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    GLfloat w;
    w = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4f(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat124_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat124 = 0; _jGLfloat124 < _a_GLfloat124_0->values.size(); ++_jGLfloat124) {
    v[_jGLfloat124] = (*_a_GLfloat124_0->values[_jGLfloat124]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4fv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint147_0 = (call.arg(1)).toArray();
        for (size_t _jGLint147 = 0; _jGLint147 < _a_GLint147_0->values.size(); ++_jGLint147) {
    v[_jGLint147] = (*_a_GLint147_0->values[_jGLint147]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4iv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4s(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    GLshort z;
    z = (call.arg(3)).toSInt();

    GLshort w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4s(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort24_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort24 = 0; _jGLshort24 < _a_GLshort24_0->values.size(); ++_jGLshort24) {
    v[_jGLshort24] = (*_a_GLshort24_0->values[_jGLshort24]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4sv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4ubv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte10_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte10 = 0; _jGLubyte10 < _a_GLubyte10_0->values.size(); ++_jGLubyte10) {
    v[_jGLubyte10] = (*_a_GLubyte10_0->values[_jGLubyte10]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4ubv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint81_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint81 = 0; _jGLuint81 < _a_GLuint81_0->values.size(); ++_jGLuint81) {
    v[_jGLuint81] = (*_a_GLuint81_0->values[_jGLuint81]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4uiv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4usv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort7_0 = (call.arg(1)).toArray();
        for (size_t _jGLushort7 = 0; _jGLushort7 < _a_GLushort7_0->values.size(); ++_jGLushort7) {
    v[_jGLushort7] = (*_a_GLushort7_0->values[_jGLushort7]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4usv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = static_cast<GLint>((call.arg(1)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(5), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribPointer(index, size, type, normalized, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix2x3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat125_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat125 = 0; _jGLfloat125 < _a_GLfloat125_0->values.size(); ++_jGLfloat125) {
    value[_jGLfloat125] = (*_a_GLfloat125_0->values[_jGLfloat125]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix2x3fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix3x2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat126_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat126 = 0; _jGLfloat126 < _a_GLfloat126_0->values.size(); ++_jGLfloat126) {
    value[_jGLfloat126] = (*_a_GLfloat126_0->values[_jGLfloat126]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix3x2fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix2x4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat127_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat127 = 0; _jGLfloat127 < _a_GLfloat127_0->values.size(); ++_jGLfloat127) {
    value[_jGLfloat127] = (*_a_GLfloat127_0->values[_jGLfloat127]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix2x4fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix4x2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat128_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat128 = 0; _jGLfloat128 < _a_GLfloat128_0->values.size(); ++_jGLfloat128) {
    value[_jGLfloat128] = (*_a_GLfloat128_0->values[_jGLfloat128]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix4x2fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix3x4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat129_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat129 = 0; _jGLfloat129 < _a_GLfloat129_0->values.size(); ++_jGLfloat129) {
    value[_jGLfloat129] = (*_a_GLfloat129_0->values[_jGLfloat129]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix3x4fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix4x3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat130_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat130 = 0; _jGLfloat130 < _a_GLfloat130_0->values.size(); ++_jGLfloat130) {
    value[_jGLfloat130] = (*_a_GLfloat130_0->values[_jGLfloat130]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix4x3fv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorMaski(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLboolean r;
    r = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLboolean g;
    g = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLboolean b;
    b = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLboolean a;
    a = static_cast<GLboolean>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorMaski(index, r, g, b, a);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnablei(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnablei(target, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisablei(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisablei(target, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginTransformFeedback(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum primitiveMode;
    primitiveMode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginTransformFeedback(primitiveMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndTransformFeedback(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndTransformFeedback();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferRange(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(3)).toSInt();

    GLsizeiptr size;
    size = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferRange(target, index, buffer, offset, size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferBase(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferBase(target, index, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTransformFeedbackVaryings(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLsizei count;
    count = (call.arg(1)).toSInt();

    const GLchar * * varyings;
    varyings = static_cast<const GLchar * *>(_allocator.alloc(&call.arg(2), sizeof *varyings));
    if (varyings) {
        const trace::Array *_a_constGLchar22_0 = (call.arg(2)).toArray();
        for (size_t _jconstGLchar22 = 0; _jconstGLchar22 < _a_constGLchar22_0->values.size(); ++_jconstGLchar22) {
    varyings[_jconstGLchar22] = (const GLchar *)((*_a_constGLchar22_0->values[_jconstGLchar22]).toString());
        }
    }

    GLenum bufferMode;
    bufferMode = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTransformFeedbackVaryings(program, count, varyings, bufferMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClampColor(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum clamp;
    clamp = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClampColor(target, clamp);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginConditionalRender(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(id) << " <- " << size_t(_query_map[id]) << "\n";
    }
    id = _query_map[id];

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginConditionalRender(id, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndConditionalRender(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndConditionalRender();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribIPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(4), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribIPointer(index, size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI1i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI1i(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI2i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI2i(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    GLint z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI3i(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    GLint z;
    z = (call.arg(3)).toSInt();

    GLint w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4i(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI1ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint x;
    x = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI1ui(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI2ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint x;
    x = (call.arg(1)).toUInt();

    GLuint y;
    y = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI2ui(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint x;
    x = (call.arg(1)).toUInt();

    GLuint y;
    y = (call.arg(2)).toUInt();

    GLuint z;
    z = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI3ui(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint x;
    x = (call.arg(1)).toUInt();

    GLuint y;
    y = (call.arg(2)).toUInt();

    GLuint z;
    z = (call.arg(3)).toUInt();

    GLuint w;
    w = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4ui(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI1iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLint27_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLint27_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI1iv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI2iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint148_0 = (call.arg(1)).toArray();
        for (size_t _jGLint148 = 0; _jGLint148 < _a_GLint148_0->values.size(); ++_jGLint148) {
    v[_jGLint148] = (*_a_GLint148_0->values[_jGLint148]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI2iv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint149_0 = (call.arg(1)).toArray();
        for (size_t _jGLint149 = 0; _jGLint149 < _a_GLint149_0->values.size(); ++_jGLint149) {
    v[_jGLint149] = (*_a_GLint149_0->values[_jGLint149]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI3iv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint150_0 = (call.arg(1)).toArray();
        for (size_t _jGLint150 = 0; _jGLint150 < _a_GLint150_0->values.size(); ++_jGLint150) {
    v[_jGLint150] = (*_a_GLint150_0->values[_jGLint150]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4iv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI1uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLuint27_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLuint27_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI1uiv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI2uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint82_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint82 = 0; _jGLuint82 < _a_GLuint82_0->values.size(); ++_jGLuint82) {
    v[_jGLuint82] = (*_a_GLuint82_0->values[_jGLuint82]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI2uiv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint83_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint83 = 0; _jGLuint83 < _a_GLuint83_0->values.size(); ++_jGLuint83) {
    v[_jGLuint83] = (*_a_GLuint83_0->values[_jGLuint83]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI3uiv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint84_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint84 = 0; _jGLuint84 < _a_GLuint84_0->values.size(); ++_jGLuint84) {
    v[_jGLuint84] = (*_a_GLuint84_0->values[_jGLuint84]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4uiv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4bv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte7_0 = (call.arg(1)).toArray();
        for (size_t _jGLbyte7 = 0; _jGLbyte7 < _a_GLbyte7_0->values.size(); ++_jGLbyte7) {
    v[_jGLbyte7] = (*_a_GLbyte7_0->values[_jGLbyte7]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4bv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4sv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort25_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort25 = 0; _jGLshort25 < _a_GLshort25_0->values.size(); ++_jGLshort25) {
    v[_jGLshort25] = (*_a_GLshort25_0->values[_jGLshort25]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4sv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4ubv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte11_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte11 = 0; _jGLubyte11 < _a_GLubyte11_0->values.size(); ++_jGLubyte11) {
    v[_jGLubyte11] = (*_a_GLubyte11_0->values[_jGLubyte11]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4ubv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4usv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort8_0 = (call.arg(1)).toArray();
        for (size_t _jGLushort8 = 0; _jGLushort8 < _a_GLushort8_0->values.size(); ++_jGLushort8) {
    v[_jGLushort8] = (*_a_GLushort8_0->values[_jGLushort8]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4usv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindFragDataLocation(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLuint color;
    color = (call.arg(1)).toUInt();

    const GLchar * name;
    name = (const GLchar *)((call.arg(2)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindFragDataLocation(program, color, name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetFragDataLocation(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    const GLchar * name;
    name = (const GLchar *)((call.arg(1)).toString());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetFragDataLocation(program, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLint _origResult;
    _origResult = (*call.ret).toSInt();
    _location_map[program][_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "location " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glUniform1ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1ui(location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(1)).toUInt();

    GLuint v1;
    v1 = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2ui(location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(1)).toUInt();

    GLuint v1;
    v1 = (call.arg(2)).toUInt();

    GLuint v2;
    v2 = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3ui(location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(1)).toUInt();

    GLuint v1;
    v1 = (call.arg(2)).toUInt();

    GLuint v2;
    v2 = (call.arg(3)).toUInt();

    GLuint v3;
    v3 = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4ui(location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint85_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint85 = 0; _jGLuint85 < _a_GLuint85_0->values.size(); ++_jGLuint85) {
    value[_jGLuint85] = (*_a_GLuint85_0->values[_jGLuint85]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1uiv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint86_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint86 = 0; _jGLuint86 < _a_GLuint86_0->values.size(); ++_jGLuint86) {
    value[_jGLuint86] = (*_a_GLuint86_0->values[_jGLuint86]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2uiv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint87_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint87 = 0; _jGLuint87 < _a_GLuint87_0->values.size(); ++_jGLuint87) {
    value[_jGLuint87] = (*_a_GLuint87_0->values[_jGLuint87]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3uiv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint88_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint88 = 0; _jGLuint88 < _a_GLuint88_0->values.size(); ++_jGLuint88) {
    value[_jGLuint88] = (*_a_GLuint88_0->values[_jGLuint88]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4uiv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameterIiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint151_0 = (call.arg(2)).toArray();
        for (size_t _jGLint151 = 0; _jGLint151 < _a_GLint151_0->values.size(); ++_jGLint151) {
    params[_jGLint151] = (*_a_GLint151_0->values[_jGLint151]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameterIiv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameterIuiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint89_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint89 = 0; _jGLuint89 < _a_GLuint89_0->values.size(); ++_jGLuint89) {
    params[_jGLuint89] = (*_a_GLuint89_0->values[_jGLuint89]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameterIuiv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearBufferiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum buffer;
    buffer = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint drawbuffer;
    drawbuffer = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint152_0 = (call.arg(2)).toArray();
        for (size_t _jGLint152 = 0; _jGLint152 < _a_GLint152_0->values.size(); ++_jGLint152) {
    value[_jGLint152] = (*_a_GLint152_0->values[_jGLint152]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearBufferiv(buffer, drawbuffer, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearBufferuiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum buffer;
    buffer = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint drawbuffer;
    drawbuffer = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint90_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint90 = 0; _jGLuint90 < _a_GLuint90_0->values.size(); ++_jGLuint90) {
    value[_jGLuint90] = (*_a_GLuint90_0->values[_jGLuint90]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearBufferuiv(buffer, drawbuffer, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearBufferfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum buffer;
    buffer = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint drawbuffer;
    drawbuffer = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat131_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat131 = 0; _jGLfloat131 < _a_GLfloat131_0->values.size(); ++_jGLfloat131) {
    value[_jGLfloat131] = (*_a_GLfloat131_0->values[_jGLfloat131]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearBufferfv(buffer, drawbuffer, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearBufferfi(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum buffer;
    buffer = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint drawbuffer;
    drawbuffer = (call.arg(1)).toSInt();

    GLfloat depth;
    depth = (call.arg(2)).toFloat();

    GLint stencil;
    stencil = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearBufferfi(buffer, drawbuffer, depth, stencil);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawArraysInstanced(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint first;
    first = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawArraysInstanced(mode, first, count, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawElementsInstanced(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(3)).toPointer());

    GLsizei primcount;
    primcount = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElementsInstanced(mode, count, type, indices, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glTexBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexBuffer(target, internalformat, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPrimitiveRestartIndex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPrimitiveRestartIndex(index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture(target, attachment, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribDivisor(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint divisor;
    divisor = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribDivisor(index, divisor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMinSampleShading(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat value;
    value = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMinSampleShading(value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationi(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationi(buf, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationSeparatei(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum modeRGB;
    modeRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum modeAlpha;
    modeAlpha = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFunci(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum src;
    src = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum dst;
    dst = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFunci(buf, src, dst);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFuncSeparatei(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum srcRGB;
    srcRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum dstRGB;
    dstRGB = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum srcAlpha;
    srcAlpha = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum dstAlpha;
    dstAlpha = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glActiveTextureARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glActiveTextureARB(texture);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClientActiveTextureARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClientActiveTextureARB(texture);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble s;
    s = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1dARB(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLdouble7_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLdouble7_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1dvARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat s;
    s = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1fARB(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLfloat17_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLfloat17_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1fvARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint s;
    s = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1iARB(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLint28_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLint28_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1ivARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort s;
    s = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1sARB(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLshort4_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLshort4_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1svARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble s;
    s = (call.arg(1)).toDouble();

    GLdouble t;
    t = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2dARB(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble55_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble55 = 0; _jGLdouble55 < _a_GLdouble55_0->values.size(); ++_jGLdouble55) {
    v[_jGLdouble55] = (*_a_GLdouble55_0->values[_jGLdouble55]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2dvARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2fARB(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat132_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat132 = 0; _jGLfloat132 < _a_GLfloat132_0->values.size(); ++_jGLfloat132) {
    v[_jGLfloat132] = (*_a_GLfloat132_0->values[_jGLfloat132]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2fvARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint s;
    s = (call.arg(1)).toSInt();

    GLint t;
    t = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2iARB(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint153_0 = (call.arg(1)).toArray();
        for (size_t _jGLint153 = 0; _jGLint153 < _a_GLint153_0->values.size(); ++_jGLint153) {
    v[_jGLint153] = (*_a_GLint153_0->values[_jGLint153]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2ivARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort s;
    s = (call.arg(1)).toSInt();

    GLshort t;
    t = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2sARB(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort26_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort26 = 0; _jGLshort26 < _a_GLshort26_0->values.size(); ++_jGLshort26) {
    v[_jGLshort26] = (*_a_GLshort26_0->values[_jGLshort26]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2svARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble s;
    s = (call.arg(1)).toDouble();

    GLdouble t;
    t = (call.arg(2)).toDouble();

    GLdouble r;
    r = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3dARB(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble56_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble56 = 0; _jGLdouble56 < _a_GLdouble56_0->values.size(); ++_jGLdouble56) {
    v[_jGLdouble56] = (*_a_GLdouble56_0->values[_jGLdouble56]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3dvARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    GLfloat r;
    r = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3fARB(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat133_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat133 = 0; _jGLfloat133 < _a_GLfloat133_0->values.size(); ++_jGLfloat133) {
    v[_jGLfloat133] = (*_a_GLfloat133_0->values[_jGLfloat133]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3fvARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint s;
    s = (call.arg(1)).toSInt();

    GLint t;
    t = (call.arg(2)).toSInt();

    GLint r;
    r = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3iARB(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint154_0 = (call.arg(1)).toArray();
        for (size_t _jGLint154 = 0; _jGLint154 < _a_GLint154_0->values.size(); ++_jGLint154) {
    v[_jGLint154] = (*_a_GLint154_0->values[_jGLint154]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3ivARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort s;
    s = (call.arg(1)).toSInt();

    GLshort t;
    t = (call.arg(2)).toSInt();

    GLshort r;
    r = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3sARB(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort27_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort27 = 0; _jGLshort27 < _a_GLshort27_0->values.size(); ++_jGLshort27) {
    v[_jGLshort27] = (*_a_GLshort27_0->values[_jGLshort27]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3svARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble s;
    s = (call.arg(1)).toDouble();

    GLdouble t;
    t = (call.arg(2)).toDouble();

    GLdouble r;
    r = (call.arg(3)).toDouble();

    GLdouble q;
    q = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4dARB(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble57_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble57 = 0; _jGLdouble57 < _a_GLdouble57_0->values.size(); ++_jGLdouble57) {
    v[_jGLdouble57] = (*_a_GLdouble57_0->values[_jGLdouble57]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4dvARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    GLfloat r;
    r = (call.arg(3)).toFloat();

    GLfloat q;
    q = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4fARB(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat134_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat134 = 0; _jGLfloat134 < _a_GLfloat134_0->values.size(); ++_jGLfloat134) {
    v[_jGLfloat134] = (*_a_GLfloat134_0->values[_jGLfloat134]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4fvARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint s;
    s = (call.arg(1)).toSInt();

    GLint t;
    t = (call.arg(2)).toSInt();

    GLint r;
    r = (call.arg(3)).toSInt();

    GLint q;
    q = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4iARB(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint155_0 = (call.arg(1)).toArray();
        for (size_t _jGLint155 = 0; _jGLint155 < _a_GLint155_0->values.size(); ++_jGLint155) {
    v[_jGLint155] = (*_a_GLint155_0->values[_jGLint155]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4ivARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort s;
    s = (call.arg(1)).toSInt();

    GLshort t;
    t = (call.arg(2)).toSInt();

    GLshort r;
    r = (call.arg(3)).toSInt();

    GLshort q;
    q = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4sARB(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort28_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort28 = 0; _jGLshort28 < _a_GLshort28_0->values.size(); ++_jGLshort28) {
    v[_jGLshort28] = (*_a_GLshort28_0->values[_jGLshort28]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4svARB(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadTransposeMatrixfARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat135_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat135 = 0; _jGLfloat135 < _a_GLfloat135_0->values.size(); ++_jGLfloat135) {
    m[_jGLfloat135] = (*_a_GLfloat135_0->values[_jGLfloat135]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadTransposeMatrixfARB(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadTransposeMatrixdARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble58_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble58 = 0; _jGLdouble58 < _a_GLdouble58_0->values.size(); ++_jGLdouble58) {
    m[_jGLdouble58] = (*_a_GLdouble58_0->values[_jGLdouble58]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadTransposeMatrixdARB(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultTransposeMatrixfARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat136_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat136 = 0; _jGLfloat136 < _a_GLfloat136_0->values.size(); ++_jGLfloat136) {
    m[_jGLfloat136] = (*_a_GLfloat136_0->values[_jGLfloat136]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultTransposeMatrixfARB(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultTransposeMatrixdARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble59_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble59 = 0; _jGLdouble59 < _a_GLdouble59_0->values.size(); ++_jGLdouble59) {
    m[_jGLdouble59] = (*_a_GLdouble59_0->values[_jGLdouble59]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultTransposeMatrixdARB(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSampleCoverageARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat value;
    value = (call.arg(0)).toFloat();

    GLboolean invert;
    invert = static_cast<GLboolean>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSampleCoverageARB(value, invert);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexImage3DARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(7)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexImage2DARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLint border;
    border = (call.arg(5)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(6)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexImage1DARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLint border;
    border = (call.arg(4)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(5)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexSubImage3DARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLsizei depth;
    depth = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(9)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(10)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexSubImage2DARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(6)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(7)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexSubImage1DARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(5)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetCompressedTexImageARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLvoid * img;
    img = static_cast<GLvoid *>((call.arg(2)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetCompressedTexImageARB(target, level, img);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterfARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterfARB(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterfvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat137_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat137 = 0; _jGLfloat137 < _a_GLfloat137_0->values.size(); ++_jGLfloat137) {
    params[_jGLfloat137] = (*_a_GLfloat137_0->values[_jGLfloat137]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterfvARB(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightbvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLbyte * weights;
    weights = static_cast<GLbyte *>(_allocator.alloc(&call.arg(1), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLbyte8_0 = (call.arg(1)).toArray();
        for (size_t _jGLbyte8 = 0; _jGLbyte8 < _a_GLbyte8_0->values.size(); ++_jGLbyte8) {
    weights[_jGLbyte8] = (*_a_GLbyte8_0->values[_jGLbyte8]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightbvARB(size, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightsvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLshort * weights;
    weights = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLshort29_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort29 = 0; _jGLshort29 < _a_GLshort29_0->values.size(); ++_jGLshort29) {
    weights[_jGLshort29] = (*_a_GLshort29_0->values[_jGLshort29]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightsvARB(size, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLint * weights;
    weights = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLint156_0 = (call.arg(1)).toArray();
        for (size_t _jGLint156 = 0; _jGLint156 < _a_GLint156_0->values.size(); ++_jGLint156) {
    weights[_jGLint156] = (*_a_GLint156_0->values[_jGLint156]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightivARB(size, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightfvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLfloat * weights;
    weights = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLfloat138_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat138 = 0; _jGLfloat138 < _a_GLfloat138_0->values.size(); ++_jGLfloat138) {
    weights[_jGLfloat138] = (*_a_GLfloat138_0->values[_jGLfloat138]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightfvARB(size, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightdvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLdouble * weights;
    weights = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLdouble60_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble60 = 0; _jGLdouble60 < _a_GLdouble60_0->values.size(); ++_jGLdouble60) {
    weights[_jGLdouble60] = (*_a_GLdouble60_0->values[_jGLdouble60]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightdvARB(size, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightubvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLubyte * weights;
    weights = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLubyte12_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte12 = 0; _jGLubyte12 < _a_GLubyte12_0->values.size(); ++_jGLubyte12) {
    weights[_jGLubyte12] = (*_a_GLubyte12_0->values[_jGLubyte12]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightubvARB(size, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightusvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLushort * weights;
    weights = static_cast<GLushort *>(_allocator.alloc(&call.arg(1), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLushort9_0 = (call.arg(1)).toArray();
        for (size_t _jGLushort9 = 0; _jGLushort9 < _a_GLushort9_0->values.size(); ++_jGLushort9) {
    weights[_jGLushort9] = (*_a_GLushort9_0->values[_jGLushort9]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightusvARB(size, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightuivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLuint * weights;
    weights = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLuint91_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint91 = 0; _jGLuint91 < _a_GLuint91_0->values.size(); ++_jGLuint91) {
    weights[_jGLuint91] = (*_a_GLuint91_0->values[_jGLuint91]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightuivARB(size, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightPointerARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightPointerARB(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexBlendARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint count;
    count = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexBlendARB(count);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCurrentPaletteMatrixARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint index;
    index = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCurrentPaletteMatrixARB(index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixIndexubvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLubyte * indices;
    indices = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *indices));
    if (indices) {
        const trace::Array *_a_GLubyte13_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte13 = 0; _jGLubyte13 < _a_GLubyte13_0->values.size(); ++_jGLubyte13) {
    indices[_jGLubyte13] = (*_a_GLubyte13_0->values[_jGLubyte13]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixIndexubvARB(size, indices);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixIndexusvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLushort * indices;
    indices = static_cast<GLushort *>(_allocator.alloc(&call.arg(1), sizeof *indices));
    if (indices) {
        const trace::Array *_a_GLushort10_0 = (call.arg(1)).toArray();
        for (size_t _jGLushort10 = 0; _jGLushort10 < _a_GLushort10_0->values.size(); ++_jGLushort10) {
    indices[_jGLushort10] = (*_a_GLushort10_0->values[_jGLushort10]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixIndexusvARB(size, indices);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixIndexuivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLuint * indices;
    indices = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *indices));
    if (indices) {
        const trace::Array *_a_GLuint92_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint92 = 0; _jGLuint92 < _a_GLuint92_0->values.size(); ++_jGLuint92) {
    indices[_jGLuint92] = (*_a_GLuint92_0->values[_jGLuint92]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixIndexuivARB(size, indices);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixIndexPointerARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixIndexPointerARB(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2dARB(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble61_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble61 = 0; _jGLdouble61 < _a_GLdouble61_0->values.size(); ++_jGLdouble61) {
    v[_jGLdouble61] = (*_a_GLdouble61_0->values[_jGLdouble61]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2dvARB(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2fARB(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat139_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat139 = 0; _jGLfloat139 < _a_GLfloat139_0->values.size(); ++_jGLfloat139) {
    v[_jGLfloat139] = (*_a_GLfloat139_0->values[_jGLfloat139]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2fvARB(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2iARB(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint157_0 = (call.arg(0)).toArray();
        for (size_t _jGLint157 = 0; _jGLint157 < _a_GLint157_0->values.size(); ++_jGLint157) {
    v[_jGLint157] = (*_a_GLint157_0->values[_jGLint157]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2ivARB(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2sARB(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort30_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort30 = 0; _jGLshort30 < _a_GLshort30_0->values.size(); ++_jGLshort30) {
    v[_jGLshort30] = (*_a_GLshort30_0->values[_jGLshort30]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2svARB(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3dARB(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble62_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble62 = 0; _jGLdouble62 < _a_GLdouble62_0->values.size(); ++_jGLdouble62) {
    v[_jGLdouble62] = (*_a_GLdouble62_0->values[_jGLdouble62]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3dvARB(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3fARB(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat140_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat140 = 0; _jGLfloat140 < _a_GLfloat140_0->values.size(); ++_jGLfloat140) {
    v[_jGLfloat140] = (*_a_GLfloat140_0->values[_jGLfloat140]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3fvARB(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3iARB(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint158_0 = (call.arg(0)).toArray();
        for (size_t _jGLint158 = 0; _jGLint158 < _a_GLint158_0->values.size(); ++_jGLint158) {
    v[_jGLint158] = (*_a_GLint158_0->values[_jGLint158]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3ivARB(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3sARB(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort31_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort31 = 0; _jGLshort31 < _a_GLshort31_0->values.size(); ++_jGLshort31) {
    v[_jGLshort31] = (*_a_GLshort31_0->values[_jGLshort31]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3svARB(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1dARB(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLdouble8_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLdouble8_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1dvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1fARB(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLfloat18_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLfloat18_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1fvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1sARB(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLshort5_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLshort5_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1svARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2dARB(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble63_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble63 = 0; _jGLdouble63 < _a_GLdouble63_0->values.size(); ++_jGLdouble63) {
    v[_jGLdouble63] = (*_a_GLdouble63_0->values[_jGLdouble63]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2dvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2fARB(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat141_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat141 = 0; _jGLfloat141 < _a_GLfloat141_0->values.size(); ++_jGLfloat141) {
    v[_jGLfloat141] = (*_a_GLfloat141_0->values[_jGLfloat141]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2fvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2sARB(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort32_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort32 = 0; _jGLshort32 < _a_GLshort32_0->values.size(); ++_jGLshort32) {
    v[_jGLshort32] = (*_a_GLshort32_0->values[_jGLshort32]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2svARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3dARB(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble64_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble64 = 0; _jGLdouble64 < _a_GLdouble64_0->values.size(); ++_jGLdouble64) {
    v[_jGLdouble64] = (*_a_GLdouble64_0->values[_jGLdouble64]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3dvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3fARB(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat142_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat142 = 0; _jGLfloat142 < _a_GLfloat142_0->values.size(); ++_jGLfloat142) {
    v[_jGLfloat142] = (*_a_GLfloat142_0->values[_jGLfloat142]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3fvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    GLshort z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3sARB(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort33_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort33 = 0; _jGLshort33 < _a_GLshort33_0->values.size(); ++_jGLshort33) {
    v[_jGLshort33] = (*_a_GLshort33_0->values[_jGLshort33]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3svARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4NbvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte9_0 = (call.arg(1)).toArray();
        for (size_t _jGLbyte9 = 0; _jGLbyte9 < _a_GLbyte9_0->values.size(); ++_jGLbyte9) {
    v[_jGLbyte9] = (*_a_GLbyte9_0->values[_jGLbyte9]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4NbvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4NivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint159_0 = (call.arg(1)).toArray();
        for (size_t _jGLint159 = 0; _jGLint159 < _a_GLint159_0->values.size(); ++_jGLint159) {
    v[_jGLint159] = (*_a_GLint159_0->values[_jGLint159]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4NivARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4NsvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort34_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort34 = 0; _jGLshort34 < _a_GLshort34_0->values.size(); ++_jGLshort34) {
    v[_jGLshort34] = (*_a_GLshort34_0->values[_jGLshort34]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4NsvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4NubARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte x;
    x = (call.arg(1)).toUInt();

    GLubyte y;
    y = (call.arg(2)).toUInt();

    GLubyte z;
    z = (call.arg(3)).toUInt();

    GLubyte w;
    w = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4NubARB(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4NubvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte14_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte14 = 0; _jGLubyte14 < _a_GLubyte14_0->values.size(); ++_jGLubyte14) {
    v[_jGLubyte14] = (*_a_GLubyte14_0->values[_jGLubyte14]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4NubvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4NuivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint93_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint93 = 0; _jGLuint93 < _a_GLuint93_0->values.size(); ++_jGLuint93) {
    v[_jGLuint93] = (*_a_GLuint93_0->values[_jGLuint93]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4NuivARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4NusvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort11_0 = (call.arg(1)).toArray();
        for (size_t _jGLushort11 = 0; _jGLushort11 < _a_GLushort11_0->values.size(); ++_jGLushort11) {
    v[_jGLushort11] = (*_a_GLushort11_0->values[_jGLushort11]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4NusvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4bvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte10_0 = (call.arg(1)).toArray();
        for (size_t _jGLbyte10 = 0; _jGLbyte10 < _a_GLbyte10_0->values.size(); ++_jGLbyte10) {
    v[_jGLbyte10] = (*_a_GLbyte10_0->values[_jGLbyte10]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4bvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    GLdouble w;
    w = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4dARB(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble65_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble65 = 0; _jGLdouble65 < _a_GLdouble65_0->values.size(); ++_jGLdouble65) {
    v[_jGLdouble65] = (*_a_GLdouble65_0->values[_jGLdouble65]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4dvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    GLfloat w;
    w = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4fARB(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat143_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat143 = 0; _jGLfloat143 < _a_GLfloat143_0->values.size(); ++_jGLfloat143) {
    v[_jGLfloat143] = (*_a_GLfloat143_0->values[_jGLfloat143]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4fvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint160_0 = (call.arg(1)).toArray();
        for (size_t _jGLint160 = 0; _jGLint160 < _a_GLint160_0->values.size(); ++_jGLint160) {
    v[_jGLint160] = (*_a_GLint160_0->values[_jGLint160]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4ivARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4sARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    GLshort z;
    z = (call.arg(3)).toSInt();

    GLshort w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4sARB(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4svARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort35_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort35 = 0; _jGLshort35 < _a_GLshort35_0->values.size(); ++_jGLshort35) {
    v[_jGLshort35] = (*_a_GLshort35_0->values[_jGLshort35]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4svARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4ubvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte15_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte15 = 0; _jGLubyte15 < _a_GLubyte15_0->values.size(); ++_jGLubyte15) {
    v[_jGLubyte15] = (*_a_GLubyte15_0->values[_jGLubyte15]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4ubvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4uivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint94_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint94 = 0; _jGLuint94 < _a_GLuint94_0->values.size(); ++_jGLuint94) {
    v[_jGLuint94] = (*_a_GLuint94_0->values[_jGLuint94]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4uivARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4usvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort12_0 = (call.arg(1)).toArray();
        for (size_t _jGLushort12 = 0; _jGLushort12 < _a_GLushort12_0->values.size(); ++_jGLushort12) {
    v[_jGLushort12] = (*_a_GLushort12_0->values[_jGLushort12]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4usvARB(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribPointerARB(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = static_cast<GLint>((call.arg(1)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(5), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribPointerARB(index, size, type, normalized, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableVertexAttribArrayARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableVertexAttribArrayARB(index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableVertexAttribArrayARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableVertexAttribArrayARB(index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramStringARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei len;
    len = (call.arg(2)).toSInt();

    const void * string;
    string = (const void *)((call.arg(3)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramStringARB(target, format, len, string);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        GLint error_position = -1;
        glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &error_position);
        if (error_position != -1) {
            const char *error_string = (const char *)glGetString(GL_PROGRAM_ERROR_STRING_ARB);
            retrace::warning(call) << error_string << "\n";
        }
    }
}

static void retrace_glBindProgramARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint program;
    program = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(program) << " <- " << size_t(_programARB_map[program]) << "\n";
    }
    program = _programARB_map[program];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindProgramARB(target, program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteProgramsARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * programs;
    programs = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *programs));
    if (programs) {
        const trace::Array *_a_GLuint95_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint95 = 0; _jGLuint95 < _a_GLuint95_0->values.size(); ++_jGLuint95) {
    programs[_jGLuint95] = (*_a_GLuint95_0->values[_jGLuint95]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(programs[_jGLuint95]) << " <- " << size_t(_programARB_map[programs[_jGLuint95]]) << "\n";
    }
    programs[_jGLuint95] = _programARB_map[programs[_jGLuint95]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteProgramsARB(n, programs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenProgramsARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * programs;
    programs = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *programs));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenProgramsARB(n, programs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint97 = (call.arg(1)).toArray();
    if (_aGLuint97) {
        for (size_t _jGLuint97 = 0; _jGLuint97 < _aGLuint97->values.size(); ++_jGLuint97) {
    GLuint _origResult;
    _origResult = (*_aGLuint97->values[_jGLuint97]).toUInt();
    _programARB_map[_origResult] = programs[_jGLuint97];
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << _origResult << " -> " << programs[_jGLuint97] << "\n";
    }
        }
    }
}

static void retrace_glProgramEnvParameter4dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLdouble x;
    x = (call.arg(2)).toDouble();

    GLdouble y;
    y = (call.arg(3)).toDouble();

    GLdouble z;
    z = (call.arg(4)).toDouble();

    GLdouble w;
    w = (call.arg(5)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameter4dARB(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParameter4dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLdouble * params;
    params = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLdouble66_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble66 = 0; _jGLdouble66 < _a_GLdouble66_0->values.size(); ++_jGLdouble66) {
    params[_jGLdouble66] = (*_a_GLdouble66_0->values[_jGLdouble66]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameter4dvARB(target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParameter4fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLfloat x;
    x = (call.arg(2)).toFloat();

    GLfloat y;
    y = (call.arg(3)).toFloat();

    GLfloat z;
    z = (call.arg(4)).toFloat();

    GLfloat w;
    w = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameter4fARB(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParameter4fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat144_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat144 = 0; _jGLfloat144 < _a_GLfloat144_0->values.size(); ++_jGLfloat144) {
    params[_jGLfloat144] = (*_a_GLfloat144_0->values[_jGLfloat144]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameter4fvARB(target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameter4dARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLdouble x;
    x = (call.arg(2)).toDouble();

    GLdouble y;
    y = (call.arg(3)).toDouble();

    GLdouble z;
    z = (call.arg(4)).toDouble();

    GLdouble w;
    w = (call.arg(5)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameter4dARB(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameter4dvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLdouble * params;
    params = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLdouble67_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble67 = 0; _jGLdouble67 < _a_GLdouble67_0->values.size(); ++_jGLdouble67) {
    params[_jGLdouble67] = (*_a_GLdouble67_0->values[_jGLdouble67]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameter4dvARB(target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameter4fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLfloat x;
    x = (call.arg(2)).toFloat();

    GLfloat y;
    y = (call.arg(3)).toFloat();

    GLfloat z;
    z = (call.arg(4)).toFloat();

    GLfloat w;
    w = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameter4fARB(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameter4fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat145_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat145 = 0; _jGLfloat145 < _a_GLfloat145_0->values.size(); ++_jGLfloat145) {
    params[_jGLfloat145] = (*_a_GLfloat145_0->values[_jGLfloat145]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameter4fvARB(target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferARB(target, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteBuffersARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * buffers;
    buffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *buffers));
    if (buffers) {
        const trace::Array *_a_GLuint98_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint98 = 0; _jGLuint98 < _a_GLuint98_0->values.size(); ++_jGLuint98) {
    buffers[_jGLuint98] = (*_a_GLuint98_0->values[_jGLuint98]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffers[_jGLuint98]) << " <- " << size_t(_buffer_map[buffers[_jGLuint98]]) << "\n";
    }
    buffers[_jGLuint98] = _buffer_map[buffers[_jGLuint98]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteBuffersARB(n, buffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenBuffersARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * buffers;
    buffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *buffers));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenBuffersARB(n, buffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint100 = (call.arg(1)).toArray();
    if (_aGLuint100) {
        for (size_t _jGLuint100 = 0; _jGLuint100 < _aGLuint100->values.size(); ++_jGLuint100) {
    GLuint _origResult;
    _origResult = (*_aGLuint100->values[_jGLuint100]).toUInt();
    _buffer_map[_origResult] = buffers[_jGLuint100];
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << _origResult << " -> " << buffers[_jGLuint100] << "\n";
    }
        }
    }
}

static void retrace_glBufferDataARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizeiptrARB size;
    size = (call.arg(1)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLenum usage;
    usage = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBufferDataARB(target, size, data, usage);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBufferSubDataARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLintptrARB offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptrARB size;
    size = (call.arg(2)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBufferSubDataARB(target, offset, size, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapBufferARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum access;
    access = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glMapBufferARB(target, access);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to map buffer\n";
        }
    }
    GLint length = 0;
    glGetBufferParameterivARB(target, GL_BUFFER_SIZE_ARB, &length);
    retrace::addRegion((*call.ret).toUIntPtr(), _result, length);
}

static void retrace_glUnmapBufferARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLboolean _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
        GLvoid *ptr = NULL;
            glGetBufferPointervARB(target, GL_BUFFER_MAP_POINTER_ARB, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "no current context\n";
        }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glUnmapBufferARB(target);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to unmap buffer\n";
        }
    }
}

static void retrace_glGenQueriesARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenQueriesARB(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint102 = (call.arg(1)).toArray();
    if (_aGLuint102) {
        for (size_t _jGLuint102 = 0; _jGLuint102 < _aGLuint102->values.size(); ++_jGLuint102) {
    GLuint _origResult;
    _origResult = (*_aGLuint102->values[_jGLuint102]).toUInt();
    _query_map[_origResult] = ids[_jGLuint102];
    if (retrace::verbosity >= 2) {
        std::cout << "query " << _origResult << " -> " << ids[_jGLuint102] << "\n";
    }
        }
    }
}

static void retrace_glDeleteQueriesARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint103_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint103 = 0; _jGLuint103 < _a_GLuint103_0->values.size(); ++_jGLuint103) {
    ids[_jGLuint103] = (*_a_GLuint103_0->values[_jGLuint103]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(ids[_jGLuint103]) << " <- " << size_t(_query_map[ids[_jGLuint103]]) << "\n";
    }
    ids[_jGLuint103] = _query_map[ids[_jGLuint103]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteQueriesARB(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginQueryARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(id) << " <- " << size_t(_query_map[id]) << "\n";
    }
    id = _query_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginQueryARB(target, id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndQueryARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndQueryARB(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteObjectARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB obj;
    obj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(obj) << " <- " << size_t(_handleARB_map[obj]) << "\n";
    }
    obj = _handleARB_map[obj];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteObjectARB(obj);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDetachObjectARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB containerObj;
    containerObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(containerObj) << " <- " << size_t(_handleARB_map[containerObj]) << "\n";
    }
    containerObj = _handleARB_map[containerObj];

    GLhandleARB attachedObj;
    attachedObj = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(attachedObj) << " <- " << size_t(_handleARB_map[attachedObj]) << "\n";
    }
    attachedObj = _handleARB_map[attachedObj];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDetachObjectARB(containerObj, attachedObj);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCreateShaderObjectARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum shaderType;
    shaderType = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhandleARB _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCreateShaderObjectARB(shaderType);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLhandleARB _origResult;
    _origResult = (*call.ret).toUInt();
    _handleARB_map[_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glShaderSourceARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB shaderObj;
    shaderObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(shaderObj) << " <- " << size_t(_handleARB_map[shaderObj]) << "\n";
    }
    shaderObj = _handleARB_map[shaderObj];

    GLsizei count;
    count = (call.arg(1)).toSInt();

    const GLcharARB * * string;
    string = static_cast<const GLcharARB * *>(_allocator.alloc(&call.arg(2), sizeof *string));
    if (string) {
        const trace::Array *_a_constGLcharARB2_0 = (call.arg(2)).toArray();
        for (size_t _jconstGLcharARB2 = 0; _jconstGLcharARB2 < _a_constGLcharARB2_0->values.size(); ++_jconstGLcharARB2) {
    string[_jconstGLcharARB2] = (const GLcharARB *)((*_a_constGLcharARB2_0->values[_jconstGLcharARB2]).toString());
        }
    }

    GLint * length;
    length = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *length));
    if (length) {
        const trace::Array *_a_GLint161_0 = (call.arg(3)).toArray();
        for (size_t _jGLint161 = 0; _jGLint161 < _a_GLint161_0->values.size(); ++_jGLint161) {
    length[_jGLint161] = (*_a_GLint161_0->values[_jGLint161]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glShaderSourceARB(shaderObj, count, string, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompileShaderARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB shaderObj;
    shaderObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(shaderObj) << " <- " << size_t(_handleARB_map[shaderObj]) << "\n";
    }
    shaderObj = _handleARB_map[shaderObj];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompileShaderARB(shaderObj);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        GLint compile_status = 0;
        glGetObjectParameterivARB(shaderObj, GL_OBJECT_COMPILE_STATUS_ARB, &compile_status);
        if (!compile_status) {
             GLint info_log_length = 0;
             glGetObjectParameterivARB(shaderObj, GL_OBJECT_INFO_LOG_LENGTH_ARB, &info_log_length);
             GLchar *infoLog = new GLchar[info_log_length];
             glGetInfoLogARB(shaderObj, info_log_length, NULL, infoLog);
             retrace::warning(call) << infoLog << "\n";
             delete [] infoLog;
        }
    }
}

static void retrace_glCreateProgramObjectARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCreateProgramObjectARB();
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLhandleARB _origResult;
    _origResult = (*call.ret).toUInt();
    _handleARB_map[_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glAttachObjectARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB containerObj;
    containerObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(containerObj) << " <- " << size_t(_handleARB_map[containerObj]) << "\n";
    }
    containerObj = _handleARB_map[containerObj];

    GLhandleARB obj;
    obj = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(obj) << " <- " << size_t(_handleARB_map[obj]) << "\n";
    }
    obj = _handleARB_map[obj];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAttachObjectARB(containerObj, obj);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLinkProgramARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB programObj;
    programObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(programObj) << " <- " << size_t(_handleARB_map[programObj]) << "\n";
    }
    programObj = _handleARB_map[programObj];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLinkProgramARB(programObj);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        GLint link_status = 0;
        glGetObjectParameterivARB(programObj, GL_OBJECT_LINK_STATUS_ARB, &link_status);
        if (!link_status) {
             GLint info_log_length = 0;
             glGetObjectParameterivARB(programObj, GL_OBJECT_INFO_LOG_LENGTH_ARB, &info_log_length);
             GLchar *infoLog = new GLchar[info_log_length];
             glGetInfoLogARB(programObj, info_log_length, NULL, infoLog);
             retrace::warning(call) << infoLog << "\n";
             delete [] infoLog;
        }
    }
}

static void retrace_glUseProgramObjectARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB programObj;
    programObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(programObj) << " <- " << size_t(_handleARB_map[programObj]) << "\n";
    }
    programObj = _handleARB_map[programObj];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    glretrace::Context *currentContext = glretrace::getCurrentContext();
    if (currentContext) {
        currentContext->activeProgram = call.arg(0).toUInt();
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUseProgramObjectARB(programObj);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glValidateProgramARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB programObj;
    programObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(programObj) << " <- " << size_t(_handleARB_map[programObj]) << "\n";
    }
    programObj = _handleARB_map[programObj];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glValidateProgramARB(programObj);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1fARB(location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(1)).toFloat();

    GLfloat v1;
    v1 = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2fARB(location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(1)).toFloat();

    GLfloat v1;
    v1 = (call.arg(2)).toFloat();

    GLfloat v2;
    v2 = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3fARB(location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4fARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(1)).toFloat();

    GLfloat v1;
    v1 = (call.arg(2)).toFloat();

    GLfloat v2;
    v2 = (call.arg(3)).toFloat();

    GLfloat v3;
    v3 = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4fARB(location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1iARB(location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(1)).toSInt();

    GLint v1;
    v1 = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2iARB(location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(1)).toSInt();

    GLint v1;
    v1 = (call.arg(2)).toSInt();

    GLint v2;
    v2 = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3iARB(location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4iARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(1)).toSInt();

    GLint v1;
    v1 = (call.arg(2)).toSInt();

    GLint v2;
    v2 = (call.arg(3)).toSInt();

    GLint v3;
    v3 = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4iARB(location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat146_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat146 = 0; _jGLfloat146 < _a_GLfloat146_0->values.size(); ++_jGLfloat146) {
    value[_jGLfloat146] = (*_a_GLfloat146_0->values[_jGLfloat146]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1fvARB(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat147_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat147 = 0; _jGLfloat147 < _a_GLfloat147_0->values.size(); ++_jGLfloat147) {
    value[_jGLfloat147] = (*_a_GLfloat147_0->values[_jGLfloat147]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2fvARB(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat148_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat148 = 0; _jGLfloat148 < _a_GLfloat148_0->values.size(); ++_jGLfloat148) {
    value[_jGLfloat148] = (*_a_GLfloat148_0->values[_jGLfloat148]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3fvARB(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat149_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat149 = 0; _jGLfloat149 < _a_GLfloat149_0->values.size(); ++_jGLfloat149) {
    value[_jGLfloat149] = (*_a_GLfloat149_0->values[_jGLfloat149]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4fvARB(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint162_0 = (call.arg(2)).toArray();
        for (size_t _jGLint162 = 0; _jGLint162 < _a_GLint162_0->values.size(); ++_jGLint162) {
    value[_jGLint162] = (*_a_GLint162_0->values[_jGLint162]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1ivARB(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint163_0 = (call.arg(2)).toArray();
        for (size_t _jGLint163 = 0; _jGLint163 < _a_GLint163_0->values.size(); ++_jGLint163) {
    value[_jGLint163] = (*_a_GLint163_0->values[_jGLint163]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2ivARB(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint164_0 = (call.arg(2)).toArray();
        for (size_t _jGLint164 = 0; _jGLint164 < _a_GLint164_0->values.size(); ++_jGLint164) {
    value[_jGLint164] = (*_a_GLint164_0->values[_jGLint164]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3ivARB(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4ivARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint165_0 = (call.arg(2)).toArray();
        for (size_t _jGLint165 = 0; _jGLint165 < _a_GLint165_0->values.size(); ++_jGLint165) {
    value[_jGLint165] = (*_a_GLint165_0->values[_jGLint165]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4ivARB(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix2fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat150_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat150 = 0; _jGLfloat150 < _a_GLfloat150_0->values.size(); ++_jGLfloat150) {
    value[_jGLfloat150] = (*_a_GLfloat150_0->values[_jGLfloat150]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix2fvARB(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix3fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat151_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat151 = 0; _jGLfloat151 < _a_GLfloat151_0->values.size(); ++_jGLfloat151) {
    value[_jGLfloat151] = (*_a_GLfloat151_0->values[_jGLfloat151]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix3fvARB(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix4fvARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);
    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[programObj].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[programObj].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat152_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat152 = 0; _jGLfloat152 < _a_GLfloat152_0->values.size(); ++_jGLfloat152) {
    value[_jGLfloat152] = (*_a_GLfloat152_0->values[_jGLfloat152]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix4fvARB(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetUniformLocationARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB programObj;
    programObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(programObj) << " <- " << size_t(_handleARB_map[programObj]) << "\n";
    }
    programObj = _handleARB_map[programObj];

    const GLcharARB * name;
    name = (const GLcharARB *)((call.arg(1)).toString());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetUniformLocationARB(programObj, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLint _origResult;
    _origResult = (*call.ret).toSInt();
    _location_map[programObj][_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "location " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glBindAttribLocationARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB programObj;
    programObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(programObj) << " <- " << size_t(_handleARB_map[programObj]) << "\n";
    }
    programObj = _handleARB_map[programObj];

    GLuint index;
    index = (call.arg(1)).toUInt();

    const GLcharARB * name;
    name = (const GLcharARB *)((call.arg(2)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindAttribLocationARB(programObj, index, name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetAttribLocationARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhandleARB programObj;
    programObj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "handleARB " << size_t(programObj) << " <- " << size_t(_handleARB_map[programObj]) << "\n";
    }
    programObj = _handleARB_map[programObj];

    const GLcharARB * name;
    name = (const GLcharARB *)((call.arg(1)).toString());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetAttribLocationARB(programObj, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    GLint _origResult = call.ret->toSInt();
    if (_result != _origResult) {
        retrace::warning(call) << "vertex attrib location mismatch " << _origResult << " -> " << _result << "\n";
    }
    }
}

static void retrace_glDrawBuffersARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLenum * bufs;
    bufs = static_cast<GLenum *>(_allocator.alloc(&call.arg(1), sizeof *bufs));
    if (bufs) {
        const trace::Array *_a_GLenum11_0 = (call.arg(1)).toArray();
        for (size_t _jGLenum11 = 0; _jGLenum11 < _a_GLenum11_0->values.size(); ++_jGLenum11) {
    bufs[_jGLenum11] = static_cast<GLenum>((*_a_GLenum11_0->values[_jGLenum11]).toSInt());
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawBuffersARB(n, bufs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClampColorARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum clamp;
    clamp = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClampColorARB(target, clamp);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawArraysInstancedARB(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint first;
    first = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawArraysInstancedARB(mode, first, count, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawElementsInstancedARB(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(3)).toPointer());

    GLsizei primcount;
    primcount = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElementsInstancedARB(mode, count, type, indices, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glBindRenderbuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindRenderbuffer(target, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteRenderbuffers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * renderbuffers;
    renderbuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *renderbuffers));
    if (renderbuffers) {
        const trace::Array *_a_GLuint104_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint104 = 0; _jGLuint104 < _a_GLuint104_0->values.size(); ++_jGLuint104) {
    renderbuffers[_jGLuint104] = (*_a_GLuint104_0->values[_jGLuint104]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffers[_jGLuint104]) << " <- " << size_t(_renderbuffer_map[renderbuffers[_jGLuint104]]) << "\n";
    }
    renderbuffers[_jGLuint104] = _renderbuffer_map[renderbuffers[_jGLuint104]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteRenderbuffers(n, renderbuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenRenderbuffers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * renderbuffers;
    renderbuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *renderbuffers));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenRenderbuffers(n, renderbuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint106 = (call.arg(1)).toArray();
    if (_aGLuint106) {
        for (size_t _jGLuint106 = 0; _jGLuint106 < _aGLuint106->values.size(); ++_jGLuint106) {
    GLuint _origResult;
    _origResult = (*_aGLuint106->values[_jGLuint106]).toUInt();
    _renderbuffer_map[_origResult] = renderbuffers[_jGLuint106];
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << _origResult << " -> " << renderbuffers[_jGLuint106] << "\n";
    }
        }
    }
}

static void retrace_glRenderbufferStorage(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorage(target, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindFramebuffer(trace::Call &call) {
    assert(call.flags & trace::CALL_FLAG_SWAP_RENDERTARGET);
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint framebuffer;
    framebuffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindFramebuffer(target, framebuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteFramebuffers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * framebuffers;
    framebuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *framebuffers));
    if (framebuffers) {
        const trace::Array *_a_GLuint107_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint107 = 0; _jGLuint107 < _a_GLuint107_0->values.size(); ++_jGLuint107) {
    framebuffers[_jGLuint107] = (*_a_GLuint107_0->values[_jGLuint107]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffers[_jGLuint107]) << " <- " << size_t(_framebuffer_map[framebuffers[_jGLuint107]]) << "\n";
    }
    framebuffers[_jGLuint107] = _framebuffer_map[framebuffers[_jGLuint107]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteFramebuffers(n, framebuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenFramebuffers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * framebuffers;
    framebuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *framebuffers));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenFramebuffers(n, framebuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint109 = (call.arg(1)).toArray();
    if (_aGLuint109) {
        for (size_t _jGLuint109 = 0; _jGLuint109 < _aGLuint109->values.size(); ++_jGLuint109) {
    GLuint _origResult;
    _origResult = (*_aGLuint109->values[_jGLuint109]).toUInt();
    _framebuffer_map[_origResult] = framebuffers[_jGLuint109];
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << _origResult << " -> " << framebuffers[_jGLuint109] << "\n";
    }
        }
    }
}

static void retrace_glCheckFramebufferStatus(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCheckFramebufferStatus(target);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    GLint _origResult = call.ret->toSInt();
    if (_origResult == GL_FRAMEBUFFER_COMPLETE &&
        _result != GL_FRAMEBUFFER_COMPLETE) {
        retrace::warning(call) << "incomplete framebuffer (" << glstate::enumToString(_result) << ")\n";
    }
    }
}

static void retrace_glFramebufferTexture1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture1D(target, attachment, textarget, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture2D(target, attachment, textarget, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture3D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferRenderbuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum renderbuffertarget;
    renderbuffertarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenerateMipmap(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenerateMipmap(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlitFramebuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint srcX0;
    srcX0 = (call.arg(0)).toSInt();

    GLint srcY0;
    srcY0 = (call.arg(1)).toSInt();

    GLint srcX1;
    srcX1 = (call.arg(2)).toSInt();

    GLint srcY1;
    srcY1 = (call.arg(3)).toSInt();

    GLint dstX0;
    dstX0 = (call.arg(4)).toSInt();

    GLint dstY0;
    dstY0 = (call.arg(5)).toSInt();

    GLint dstX1;
    dstX1 = (call.arg(6)).toSInt();

    GLint dstY1;
    dstY1 = (call.arg(7)).toSInt();

    GLbitfield mask;
    mask = (call.arg(8)).toUInt();

    GLenum filter;
    filter = static_cast<GLenum>((call.arg(9)).toSInt());

    glretrace::updateDrawable(std::max(dstX0, dstX1), std::max(dstY0, dstY1));
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glRenderbufferStorageMultisample(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTextureLayer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    GLint layer;
    layer = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTextureLayer(target, attachment, texture, level, layer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameteriARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint value;
    value = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameteriARB(program, pname, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTextureARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTextureARB(target, attachment, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTextureLayerARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    GLint layer;
    layer = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTextureFaceARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    GLenum face;
    face = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTextureFaceARB(target, attachment, texture, level, face);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribDivisorARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint divisor;
    divisor = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribDivisorARB(index, divisor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapBufferRange(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLintptr offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptr length;
    length = (call.arg(2)).toSInt();

    GLbitfield access;
    access = (call.arg(3)).toUInt();

    GLvoid * _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glMapBufferRange(target, offset, length, access);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to map buffer\n";
        }
    }
    retrace::addRegion((*call.ret).toUIntPtr(), _result, length);
}

static void retrace_glFlushMappedBufferRange(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLintptr offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptr length;
    length = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlushMappedBufferRange(target, offset, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexBufferARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexBufferARB(target, internalformat, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindVertexArray(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint array;
    array = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(array) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][array]) << "\n";
    }
    array = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][array];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindVertexArray(array);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteVertexArrays(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * arrays;
    arrays = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *arrays));
    if (arrays) {
        const trace::Array *_a_GLuint110_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint110 = 0; _jGLuint110 < _a_GLuint110_0->values.size(); ++_jGLuint110) {
    arrays[_jGLuint110] = (*_a_GLuint110_0->values[_jGLuint110]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(arrays[_jGLuint110]) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][arrays[_jGLuint110]]) << "\n";
    }
    arrays[_jGLuint110] = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][arrays[_jGLuint110]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteVertexArrays(n, arrays);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenVertexArrays(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * arrays;
    arrays = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *arrays));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenVertexArrays(n, arrays);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint112 = (call.arg(1)).toArray();
    if (_aGLuint112) {
        for (size_t _jGLuint112 = 0; _jGLuint112 < _aGLuint112->values.size(); ++_jGLuint112) {
    GLuint _origResult;
    _origResult = (*_aGLuint112->values[_jGLuint112]).toUInt();
    _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][_origResult] = arrays[_jGLuint112];
    if (retrace::verbosity >= 2) {
        std::cout << "array " << _origResult << " -> " << arrays[_jGLuint112] << "\n";
    }
        }
    }
}

static void retrace_glGetUniformBlockIndex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    const GLchar * uniformBlockName;
    uniformBlockName = (const GLchar *)((call.arg(1)).toString());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetUniformBlockIndex(program, uniformBlockName);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformBlockBinding(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLuint uniformBlockIndex;
    uniformBlockIndex = (call.arg(1)).toUInt();

    GLuint uniformBlockBinding;
    uniformBlockBinding = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyBufferSubData(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum readTarget;
    readTarget = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum writeTarget;
    writeTarget = static_cast<GLenum>((call.arg(1)).toSInt());

    GLintptr readOffset;
    readOffset = (call.arg(2)).toSInt();

    GLintptr writeOffset;
    writeOffset = (call.arg(3)).toSInt();

    GLsizeiptr size;
    size = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawElementsBaseVertex(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(3)).toPointer());

    GLint basevertex;
    basevertex = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawRangeElementsBaseVertex(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint start;
    start = (call.arg(1)).toUInt();

    GLuint end;
    end = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(5)).toPointer());

    GLint basevertex;
    basevertex = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawElementsInstancedBaseVertex(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(3)).toPointer());

    GLsizei primcount;
    primcount = (call.arg(4)).toSInt();

    GLint basevertex;
    basevertex = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElementsInstancedBaseVertex(mode, count, type, indices, primcount, basevertex);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glMultiDrawElementsBaseVertex(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(1), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei6_0 = (call.arg(1)).toArray();
        for (size_t _jGLsizei6 = 0; _jGLsizei6 < _a_GLsizei6_0->values.size(); ++_jGLsizei6) {
    count[_jGLsizei6] = (*_a_GLsizei6_0->values[_jGLsizei6]).toSInt();
        }
    }

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * * indices;
    indices = static_cast<const GLvoid * *>(_allocator.alloc(&call.arg(3), sizeof *indices));
    if (indices) {
        const trace::Array *_a_constGLvoid170_0 = (call.arg(3)).toArray();
        for (size_t _jconstGLvoid170 = 0; _jconstGLvoid170 < _a_constGLvoid170_0->values.size(); ++_jconstGLvoid170) {
    indices[_jconstGLvoid170] = static_cast<const GLvoid *>((*_a_constGLvoid170_0->values[_jconstGLvoid170]).toPointer());
        }
    }

    GLsizei drawcount;
    drawcount = (call.arg(4)).toSInt();

    GLint * basevertex;
    basevertex = static_cast<GLint *>(_allocator.alloc(&call.arg(5), sizeof *basevertex));
    if (basevertex) {
        const trace::Array *_a_GLint166_0 = (call.arg(5)).toArray();
        for (size_t _jGLint166 = 0; _jGLint166 < _a_GLint166_0->values.size(); ++_jGLint166) {
    basevertex[_jGLint166] = (*_a_GLint166_0->values[_jGLint166]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glProvokingVertex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProvokingVertex(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFenceSync(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum condition;
    condition = static_cast<GLenum>((call.arg(0)).toSInt());

    GLbitfield flags;
    flags = (call.arg(1)).toUInt();

    GLsync _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glFenceSync(condition, flags);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLsync _origResult;
    _origResult = static_cast<GLsync>((*call.ret).toPointer());
    _sync_map[_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "sync " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glDeleteSync(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsync sync;
    sync = static_cast<GLsync>((call.arg(0)).toPointer());
    if (retrace::verbosity >= 2) {
        std::cout << "sync " << size_t(sync) << " <- " << size_t(_sync_map[sync]) << "\n";
    }
    sync = _sync_map[sync];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteSync(sync);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClientWaitSync(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsync sync;
    sync = static_cast<GLsync>((call.arg(0)).toPointer());
    if (retrace::verbosity >= 2) {
        std::cout << "sync " << size_t(sync) << " <- " << size_t(_sync_map[sync]) << "\n";
    }
    sync = _sync_map[sync];

    GLbitfield flags;
    flags = (call.arg(1)).toUInt();

    GLuint64 timeout;
    timeout = (call.arg(2)).toUInt();

    GLenum _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glClientWaitSync(sync, flags, timeout);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWaitSync(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsync sync;
    sync = static_cast<GLsync>((call.arg(0)).toPointer());
    if (retrace::verbosity >= 2) {
        std::cout << "sync " << size_t(sync) << " <- " << size_t(_sync_map[sync]) << "\n";
    }
    sync = _sync_map[sync];

    GLbitfield flags;
    flags = (call.arg(1)).toUInt();

    GLuint64 timeout;
    timeout = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWaitSync(sync, flags, timeout);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexImage2DMultisample(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLint internalformat;
    internalformat = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLboolean fixedsamplelocations;
    fixedsamplelocations = static_cast<GLboolean>((call.arg(5)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexImage3DMultisample(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLint internalformat;
    internalformat = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLboolean fixedsamplelocations;
    fixedsamplelocations = static_cast<GLboolean>((call.arg(6)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSampleMaski(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLbitfield mask;
    mask = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSampleMaski(index, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationiARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationiARB(buf, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationSeparateiARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum modeRGB;
    modeRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum modeAlpha;
    modeAlpha = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFunciARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum src;
    src = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum dst;
    dst = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFunciARB(buf, src, dst);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFuncSeparateiARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum srcRGB;
    srcRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum dstRGB;
    dstRGB = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum srcAlpha;
    srcAlpha = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum dstAlpha;
    dstAlpha = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMinSampleShadingARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat value;
    value = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMinSampleShadingARB(value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedStringARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint namelen;
    namelen = (call.arg(1)).toSInt();

    const GLchar * name;
    name = (const GLchar *)((call.arg(2)).toString());

    GLint stringlen;
    stringlen = (call.arg(3)).toSInt();

    const GLchar * string;
    string = (const GLchar *)((call.arg(4)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedStringARB(type, namelen, name, stringlen, string);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteNamedStringARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint namelen;
    namelen = (call.arg(0)).toSInt();

    const GLchar * name;
    name = (const GLchar *)((call.arg(1)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteNamedStringARB(namelen, name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompileShaderIncludeARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint shader;
    shader = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "shader " << size_t(shader) << " <- " << size_t(_shader_map[shader]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    shader = _handleARB_map[shader];
} else {
    shader = _shader_map[shader];
}

    GLsizei count;
    count = (call.arg(1)).toSInt();

    const GLchar * * path;
    path = static_cast<const GLchar * *>(_allocator.alloc(&call.arg(2), sizeof *path));
    if (path) {
        const trace::Array *_a_constGLchar23_0 = (call.arg(2)).toArray();
        for (size_t _jconstGLchar23 = 0; _jconstGLchar23 < _a_constGLchar23_0->values.size(); ++_jconstGLchar23) {
    path[_jconstGLchar23] = (const GLchar *)((*_a_constGLchar23_0->values[_jconstGLchar23]).toString());
        }
    }

    GLint * length;
    length = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *length));
    if (length) {
        const trace::Array *_a_GLint167_0 = (call.arg(3)).toArray();
        for (size_t _jGLint167 = 0; _jGLint167 < _a_GLint167_0->values.size(); ++_jGLint167) {
    length[_jGLint167] = (*_a_GLint167_0->values[_jGLint167]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompileShaderIncludeARB(shader, count, path, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindFragDataLocationIndexed(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLuint colorNumber;
    colorNumber = (call.arg(1)).toUInt();

    GLuint index;
    index = (call.arg(2)).toUInt();

    const GLchar * name;
    name = (const GLchar *)((call.arg(3)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindFragDataLocationIndexed(program, colorNumber, index, name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenSamplers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei count;
    count = (call.arg(0)).toSInt();

    GLuint * samplers;
    samplers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *samplers));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenSamplers(count, samplers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint114 = (call.arg(1)).toArray();
    if (_aGLuint114) {
        for (size_t _jGLuint114 = 0; _jGLuint114 < _aGLuint114->values.size(); ++_jGLuint114) {
    GLuint _origResult;
    _origResult = (*_aGLuint114->values[_jGLuint114]).toUInt();
    _sampler_map[_origResult] = samplers[_jGLuint114];
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << _origResult << " -> " << samplers[_jGLuint114] << "\n";
    }
        }
    }
}

static void retrace_glDeleteSamplers(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei count;
    count = (call.arg(0)).toSInt();

    GLuint * samplers;
    samplers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *samplers));
    if (samplers) {
        const trace::Array *_a_GLuint115_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint115 = 0; _jGLuint115 < _a_GLuint115_0->values.size(); ++_jGLuint115) {
    samplers[_jGLuint115] = (*_a_GLuint115_0->values[_jGLuint115]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(samplers[_jGLuint115]) << " <- " << size_t(_sampler_map[samplers[_jGLuint115]]) << "\n";
    }
    samplers[_jGLuint115] = _sampler_map[samplers[_jGLuint115]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteSamplers(count, samplers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindSampler(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint unit;
    unit = (call.arg(0)).toUInt();

    GLuint sampler;
    sampler = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindSampler(unit, sampler);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSamplerParameteri(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint sampler;
    sampler = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSamplerParameteri(sampler, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSamplerParameteriv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint sampler;
    sampler = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * param;
    param = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *param));
    if (param) {
        const trace::Array *_a_GLint168_0 = (call.arg(2)).toArray();
        for (size_t _jGLint168 = 0; _jGLint168 < _a_GLint168_0->values.size(); ++_jGLint168) {
    param[_jGLint168] = (*_a_GLint168_0->values[_jGLint168]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSamplerParameteriv(sampler, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSamplerParameterf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint sampler;
    sampler = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSamplerParameterf(sampler, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSamplerParameterfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint sampler;
    sampler = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * param;
    param = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *param));
    if (param) {
        const trace::Array *_a_GLfloat153_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat153 = 0; _jGLfloat153 < _a_GLfloat153_0->values.size(); ++_jGLfloat153) {
    param[_jGLfloat153] = (*_a_GLfloat153_0->values[_jGLfloat153]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSamplerParameterfv(sampler, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSamplerParameterIiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint sampler;
    sampler = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * param;
    param = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *param));
    if (param) {
        const trace::Array *_a_GLint169_0 = (call.arg(2)).toArray();
        for (size_t _jGLint169 = 0; _jGLint169 < _a_GLint169_0->values.size(); ++_jGLint169) {
    param[_jGLint169] = (*_a_GLint169_0->values[_jGLint169]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSamplerParameterIiv(sampler, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSamplerParameterIuiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint sampler;
    sampler = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint * param;
    param = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *param));
    if (param) {
        const trace::Array *_a_GLuint116_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint116 = 0; _jGLuint116 < _a_GLuint116_0->values.size(); ++_jGLuint116) {
    param[_jGLuint116] = (*_a_GLuint116_0->values[_jGLuint116]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSamplerParameterIuiv(sampler, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glQueryCounter(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(id) << " <- " << size_t(_query_map[id]) << "\n";
    }
    id = _query_map[id];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glQueryCounter(id, target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexP2ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint value;
    value = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexP2ui(type, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexP2uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *value));
    if (value) {
        const trace::Array *_a_PGLuint28_0 = (call.arg(1)).toArray();
    value[0] = (*_a_PGLuint28_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexP2uiv(type, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexP3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint value;
    value = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexP3ui(type, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexP3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *value));
    if (value) {
        const trace::Array *_a_PGLuint29_0 = (call.arg(1)).toArray();
    value[0] = (*_a_PGLuint29_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexP3uiv(type, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexP4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint value;
    value = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexP4ui(type, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexP4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *value));
    if (value) {
        const trace::Array *_a_PGLuint30_0 = (call.arg(1)).toArray();
    value[0] = (*_a_PGLuint30_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexP4uiv(type, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordP1ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint coords;
    coords = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordP1ui(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordP1uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint31_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLuint31_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordP1uiv(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordP2ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint coords;
    coords = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordP2ui(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordP2uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint32_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLuint32_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordP2uiv(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordP3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint coords;
    coords = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordP3ui(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordP3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint33_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLuint33_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordP3uiv(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordP4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint coords;
    coords = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordP4ui(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordP4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint34_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLuint34_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordP4uiv(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordP1ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint coords;
    coords = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordP1ui(texture, type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordP1uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint35_0 = (call.arg(2)).toArray();
    coords[0] = (*_a_PGLuint35_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordP1uiv(texture, type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordP2ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint coords;
    coords = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordP2ui(texture, type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordP2uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint36_0 = (call.arg(2)).toArray();
    coords[0] = (*_a_PGLuint36_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordP2uiv(texture, type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordP3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint coords;
    coords = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordP3ui(texture, type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordP3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint37_0 = (call.arg(2)).toArray();
    coords[0] = (*_a_PGLuint37_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordP3uiv(texture, type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordP4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint coords;
    coords = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordP4ui(texture, type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordP4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texture;
    texture = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint38_0 = (call.arg(2)).toArray();
    coords[0] = (*_a_PGLuint38_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordP4uiv(texture, type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalP3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint coords;
    coords = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalP3ui(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalP3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * coords;
    coords = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLuint39_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLuint39_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalP3uiv(type, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorP3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint color;
    color = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorP3ui(type, color);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorP3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * color;
    color = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *color));
    if (color) {
        const trace::Array *_a_PGLuint40_0 = (call.arg(1)).toArray();
    color[0] = (*_a_PGLuint40_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorP3uiv(type, color);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorP4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint color;
    color = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorP4ui(type, color);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorP4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * color;
    color = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *color));
    if (color) {
        const trace::Array *_a_PGLuint41_0 = (call.arg(1)).toArray();
    color[0] = (*_a_PGLuint41_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorP4uiv(type, color);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColorP3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint color;
    color = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColorP3ui(type, color);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColorP3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint * color;
    color = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *color));
    if (color) {
        const trace::Array *_a_PGLuint42_0 = (call.arg(1)).toArray();
    color[0] = (*_a_PGLuint42_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColorP3uiv(type, color);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribP1ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLuint value;
    value = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribP1ui(index, type, normalized, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribP1uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_PGLuint43_0 = (call.arg(3)).toArray();
    value[0] = (*_a_PGLuint43_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribP1uiv(index, type, normalized, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribP2ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLuint value;
    value = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribP2ui(index, type, normalized, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribP2uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_PGLuint44_0 = (call.arg(3)).toArray();
    value[0] = (*_a_PGLuint44_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribP2uiv(index, type, normalized, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribP3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLuint value;
    value = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribP3ui(index, type, normalized, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribP3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_PGLuint45_0 = (call.arg(3)).toArray();
    value[0] = (*_a_PGLuint45_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribP3uiv(index, type, normalized, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribP4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLuint value;
    value = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribP4ui(index, type, normalized, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribP4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_PGLuint46_0 = (call.arg(3)).toArray();
    value[0] = (*_a_PGLuint46_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribP4uiv(index, type, normalized, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawArraysIndirect(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    const GLvoid * indirect;
    indirect = static_cast<const GLvoid *>(retrace::toPointer(call.arg(1)));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawArraysIndirect(mode, indirect);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawElementsIndirect(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLvoid * indirect;
    indirect = static_cast<const GLvoid *>(retrace::toPointer(call.arg(2)));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElementsIndirect(mode, type, indirect);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glUniform1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble x;
    x = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1d(location, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2d(location, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3d(location, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    GLdouble w;
    w = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4d(location, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble68_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble68 = 0; _jGLdouble68 < _a_GLdouble68_0->values.size(); ++_jGLdouble68) {
    value[_jGLdouble68] = (*_a_GLdouble68_0->values[_jGLdouble68]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1dv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble69_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble69 = 0; _jGLdouble69 < _a_GLdouble69_0->values.size(); ++_jGLdouble69) {
    value[_jGLdouble69] = (*_a_GLdouble69_0->values[_jGLdouble69]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2dv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble70_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble70 = 0; _jGLdouble70 < _a_GLdouble70_0->values.size(); ++_jGLdouble70) {
    value[_jGLdouble70] = (*_a_GLdouble70_0->values[_jGLdouble70]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3dv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble71_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble71 = 0; _jGLdouble71 < _a_GLdouble71_0->values.size(); ++_jGLdouble71) {
    value[_jGLdouble71] = (*_a_GLdouble71_0->values[_jGLdouble71]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4dv(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble72_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble72 = 0; _jGLdouble72 < _a_GLdouble72_0->values.size(); ++_jGLdouble72) {
    value[_jGLdouble72] = (*_a_GLdouble72_0->values[_jGLdouble72]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix2dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble73_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble73 = 0; _jGLdouble73 < _a_GLdouble73_0->values.size(); ++_jGLdouble73) {
    value[_jGLdouble73] = (*_a_GLdouble73_0->values[_jGLdouble73]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix3dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble74_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble74 = 0; _jGLdouble74 < _a_GLdouble74_0->values.size(); ++_jGLdouble74) {
    value[_jGLdouble74] = (*_a_GLdouble74_0->values[_jGLdouble74]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix4dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix2x3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble75_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble75 = 0; _jGLdouble75 < _a_GLdouble75_0->values.size(); ++_jGLdouble75) {
    value[_jGLdouble75] = (*_a_GLdouble75_0->values[_jGLdouble75]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix2x3dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix2x4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble76_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble76 = 0; _jGLdouble76 < _a_GLdouble76_0->values.size(); ++_jGLdouble76) {
    value[_jGLdouble76] = (*_a_GLdouble76_0->values[_jGLdouble76]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix2x4dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix3x2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble77_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble77 = 0; _jGLdouble77 < _a_GLdouble77_0->values.size(); ++_jGLdouble77) {
    value[_jGLdouble77] = (*_a_GLdouble77_0->values[_jGLdouble77]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix3x2dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix3x4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble78_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble78 = 0; _jGLdouble78 < _a_GLdouble78_0->values.size(); ++_jGLdouble78) {
    value[_jGLdouble78] = (*_a_GLdouble78_0->values[_jGLdouble78]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix3x4dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix4x2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble79_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble79 = 0; _jGLdouble79 < _a_GLdouble79_0->values.size(); ++_jGLdouble79) {
    value[_jGLdouble79] = (*_a_GLdouble79_0->values[_jGLdouble79]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix4x2dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformMatrix4x3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble80_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble80 = 0; _jGLdouble80 < _a_GLdouble80_0->values.size(); ++_jGLdouble80) {
    value[_jGLdouble80] = (*_a_GLdouble80_0->values[_jGLdouble80]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformMatrix4x3dv(location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetSubroutineUniformLocation(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum shadertype;
    shadertype = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLchar * name;
    name = (const GLchar *)((call.arg(2)).toString());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetSubroutineUniformLocation(program, shadertype, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLint _origResult;
    _origResult = (*call.ret).toSInt();
    _location_map[program][_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "location " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glGetSubroutineIndex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum shadertype;
    shadertype = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLchar * name;
    name = (const GLchar *)((call.arg(2)).toString());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetSubroutineIndex(program, shadertype, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformSubroutinesuiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum shadertype;
    shadertype = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * indices;
    indices = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *indices));
    if (indices) {
        const trace::Array *_a_GLuint117_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint117 = 0; _jGLuint117 < _a_GLuint117_0->values.size(); ++_jGLuint117) {
    indices[_jGLuint117] = (*_a_GLuint117_0->values[_jGLuint117]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformSubroutinesuiv(shadertype, count, indices);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPatchParameteri(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint value;
    value = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPatchParameteri(pname, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPatchParameterfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * values;
    values = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *values));
    if (values) {
        const trace::Array *_a_GLfloat154_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat154 = 0; _jGLfloat154 < _a_GLfloat154_0->values.size(); ++_jGLfloat154) {
    values[_jGLfloat154] = (*_a_GLfloat154_0->values[_jGLfloat154]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPatchParameterfv(pname, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindTransformFeedback(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(id) << " <- " << size_t(_feedback_map[id]) << "\n";
    }
    id = _feedback_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindTransformFeedback(target, id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteTransformFeedbacks(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint118_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint118 = 0; _jGLuint118 < _a_GLuint118_0->values.size(); ++_jGLuint118) {
    ids[_jGLuint118] = (*_a_GLuint118_0->values[_jGLuint118]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(ids[_jGLuint118]) << " <- " << size_t(_feedback_map[ids[_jGLuint118]]) << "\n";
    }
    ids[_jGLuint118] = _feedback_map[ids[_jGLuint118]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteTransformFeedbacks(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenTransformFeedbacks(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenTransformFeedbacks(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint120 = (call.arg(1)).toArray();
    if (_aGLuint120) {
        for (size_t _jGLuint120 = 0; _jGLuint120 < _aGLuint120->values.size(); ++_jGLuint120) {
    GLuint _origResult;
    _origResult = (*_aGLuint120->values[_jGLuint120]).toUInt();
    _feedback_map[_origResult] = ids[_jGLuint120];
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << _origResult << " -> " << ids[_jGLuint120] << "\n";
    }
        }
    }
}

static void retrace_glPauseTransformFeedback(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPauseTransformFeedback();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glResumeTransformFeedback(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glResumeTransformFeedback();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTransformFeedback(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(id) << " <- " << size_t(_feedback_map[id]) << "\n";
    }
    id = _feedback_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTransformFeedback(mode, id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTransformFeedbackStream(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(id) << " <- " << size_t(_feedback_map[id]) << "\n";
    }
    id = _feedback_map[id];

    GLuint stream;
    stream = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTransformFeedbackStream(mode, id, stream);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginQueryIndexed(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint id;
    id = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(id) << " <- " << size_t(_feedback_map[id]) << "\n";
    }
    id = _feedback_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginQueryIndexed(target, index, id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndQueryIndexed(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndQueryIndexed(target, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReleaseShaderCompiler(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReleaseShaderCompiler();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glShaderBinary(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei count;
    count = (call.arg(0)).toSInt();

    GLuint * shaders;
    shaders = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *shaders));
    if (shaders) {
        const trace::Array *_a_GLuint121_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint121 = 0; _jGLuint121 < _a_GLuint121_0->values.size(); ++_jGLuint121) {
    shaders[_jGLuint121] = (*_a_GLuint121_0->values[_jGLuint121]).toUInt();
        }
    }

    GLenum binaryformat;
    binaryformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLvoid * binary;
    binary = static_cast<GLvoid *>((call.arg(3)).toPointer());

    GLsizei length;
    length = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glShaderBinary(count, shaders, binaryformat, binary, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthRangef(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat n;
    n = (call.arg(0)).toFloat();

    GLfloat f;
    f = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthRangef(n, f);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearDepthf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat d;
    d = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearDepthf(d);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramBinary(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum binaryFormat;
    binaryFormat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * binary;
    binary = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLsizei length;
    length = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramBinary(program, binaryFormat, binary, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameteri(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint value;
    value = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameteri(program, pname, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUseProgramStages(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint pipeline;
    pipeline = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << size_t(pipeline) << " <- " << size_t(_pipeline_map[pipeline]) << "\n";
    }
    pipeline = _pipeline_map[pipeline];

    GLbitfield stages;
    stages = (call.arg(1)).toUInt();

    GLuint program;
    program = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUseProgramStages(pipeline, stages, program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glActiveShaderProgram(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint pipeline;
    pipeline = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << size_t(pipeline) << " <- " << size_t(_pipeline_map[pipeline]) << "\n";
    }
    pipeline = _pipeline_map[pipeline];

    GLuint program;
    program = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glActiveShaderProgram(pipeline, program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCreateShaderProgramv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    const GLchar * * strings;
    strings = static_cast<const GLchar * *>(_allocator.alloc(&call.arg(2), sizeof *strings));
    if (strings) {
        const trace::Array *_a_constGLchar24_0 = (call.arg(2)).toArray();
        for (size_t _jconstGLchar24 = 0; _jconstGLchar24 < _a_constGLchar24_0->values.size(); ++_jconstGLchar24) {
    strings[_jconstGLchar24] = (const GLchar *)((*_a_constGLchar24_0->values[_jconstGLchar24]).toString());
        }
    }

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    if (retrace::dumpingState) {
        GLuint _shader = glCreateShader(type);
        if (_shader) {
            glShaderSource(_shader, count, strings, NULL);
            glCompileShader(_shader);
            const GLuint _program = glCreateProgram();
            if (_program) {
                GLint compiled = GL_FALSE;
                glGetShaderiv(_shader, GL_COMPILE_STATUS, &compiled);
                glProgramParameteri(_program, GL_PROGRAM_SEPARABLE, GL_TRUE);
                if (compiled) {
                    glAttachShader(_program, _shader);
                    glLinkProgram(_program);
                    //glDetachShader(_program, _shader);
                }
                //append-shader-info-log-to-program-info-log
            }
            //glDeleteShader(_shader);
            _result = _program;
        } else {
            _result = 0;
        }
    } else {
    _result = glCreateShaderProgramv(type, count, strings);
    (void)_result;
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        GLuint program = _result;
        GLint link_status = 0;
        glGetProgramiv(program, GL_LINK_STATUS, &link_status);
        if (!link_status) {
             GLint info_log_length = 0;
             glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
             GLchar *infoLog = new GLchar[info_log_length];
             glGetProgramInfoLog(program, info_log_length, NULL, infoLog);
             retrace::warning(call) << infoLog << "\n";
             delete [] infoLog;
        }
    }
    GLuint _origResult;
    _origResult = (*call.ret).toUInt();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _program_map[_origResult] = _result;
}
    if (retrace::verbosity >= 2) {
        std::cout << "program " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glBindProgramPipeline(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint pipeline;
    pipeline = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << size_t(pipeline) << " <- " << size_t(_pipeline_map[pipeline]) << "\n";
    }
    pipeline = _pipeline_map[pipeline];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (pipeline) {
        _pipelineHasBeenBound = true;
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindProgramPipeline(pipeline);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteProgramPipelines(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * pipelines;
    pipelines = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *pipelines));
    if (pipelines) {
        const trace::Array *_a_GLuint122_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint122 = 0; _jGLuint122 < _a_GLuint122_0->values.size(); ++_jGLuint122) {
    pipelines[_jGLuint122] = (*_a_GLuint122_0->values[_jGLuint122]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteProgramPipelines(n, pipelines);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenProgramPipelines(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * pipelines;
    pipelines = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *pipelines));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenProgramPipelines(n, pipelines);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint124 = (call.arg(1)).toArray();
    if (_aGLuint124) {
        for (size_t _jGLuint124 = 0; _jGLuint124 < _aGLuint124->values.size(); ++_jGLuint124) {
    GLuint _origResult;
    _origResult = (*_aGLuint124->values[_jGLuint124]).toUInt();
    _pipeline_map[_origResult] = pipelines[_jGLuint124];
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << _origResult << " -> " << pipelines[_jGLuint124] << "\n";
    }
        }
    }
}

static void retrace_glProgramUniform1i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1i(program, location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint170_0 = (call.arg(3)).toArray();
        for (size_t _jGLint170 = 0; _jGLint170 < _a_GLint170_0->values.size(); ++_jGLint170) {
    value[_jGLint170] = (*_a_GLint170_0->values[_jGLint170]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1iv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1f(program, location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat155_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat155 = 0; _jGLfloat155 < _a_GLfloat155_0->values.size(); ++_jGLfloat155) {
    value[_jGLfloat155] = (*_a_GLfloat155_0->values[_jGLfloat155]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1fv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble v0;
    v0 = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1d(program, location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble81_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble81 = 0; _jGLdouble81 < _a_GLdouble81_0->values.size(); ++_jGLdouble81) {
    value[_jGLdouble81] = (*_a_GLdouble81_0->values[_jGLdouble81]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1dv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1ui(program, location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint125_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint125 = 0; _jGLuint125 < _a_GLuint125_0->values.size(); ++_jGLuint125) {
    value[_jGLuint125] = (*_a_GLuint125_0->values[_jGLuint125]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1uiv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(2)).toSInt();

    GLint v1;
    v1 = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2i(program, location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint171_0 = (call.arg(3)).toArray();
        for (size_t _jGLint171 = 0; _jGLint171 < _a_GLint171_0->values.size(); ++_jGLint171) {
    value[_jGLint171] = (*_a_GLint171_0->values[_jGLint171]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2iv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(2)).toFloat();

    GLfloat v1;
    v1 = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2f(program, location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat156_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat156 = 0; _jGLfloat156 < _a_GLfloat156_0->values.size(); ++_jGLfloat156) {
    value[_jGLfloat156] = (*_a_GLfloat156_0->values[_jGLfloat156]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2fv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble v0;
    v0 = (call.arg(2)).toDouble();

    GLdouble v1;
    v1 = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2d(program, location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble82_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble82 = 0; _jGLdouble82 < _a_GLdouble82_0->values.size(); ++_jGLdouble82) {
    value[_jGLdouble82] = (*_a_GLdouble82_0->values[_jGLdouble82]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2dv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(2)).toUInt();

    GLuint v1;
    v1 = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2ui(program, location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint126_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint126 = 0; _jGLuint126 < _a_GLuint126_0->values.size(); ++_jGLuint126) {
    value[_jGLuint126] = (*_a_GLuint126_0->values[_jGLuint126]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2uiv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(2)).toSInt();

    GLint v1;
    v1 = (call.arg(3)).toSInt();

    GLint v2;
    v2 = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3i(program, location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint172_0 = (call.arg(3)).toArray();
        for (size_t _jGLint172 = 0; _jGLint172 < _a_GLint172_0->values.size(); ++_jGLint172) {
    value[_jGLint172] = (*_a_GLint172_0->values[_jGLint172]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3iv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(2)).toFloat();

    GLfloat v1;
    v1 = (call.arg(3)).toFloat();

    GLfloat v2;
    v2 = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3f(program, location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat157_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat157 = 0; _jGLfloat157 < _a_GLfloat157_0->values.size(); ++_jGLfloat157) {
    value[_jGLfloat157] = (*_a_GLfloat157_0->values[_jGLfloat157]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3fv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble v0;
    v0 = (call.arg(2)).toDouble();

    GLdouble v1;
    v1 = (call.arg(3)).toDouble();

    GLdouble v2;
    v2 = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3d(program, location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble83_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble83 = 0; _jGLdouble83 < _a_GLdouble83_0->values.size(); ++_jGLdouble83) {
    value[_jGLdouble83] = (*_a_GLdouble83_0->values[_jGLdouble83]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3dv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(2)).toUInt();

    GLuint v1;
    v1 = (call.arg(3)).toUInt();

    GLuint v2;
    v2 = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3ui(program, location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint127_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint127 = 0; _jGLuint127 < _a_GLuint127_0->values.size(); ++_jGLuint127) {
    value[_jGLuint127] = (*_a_GLuint127_0->values[_jGLuint127]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3uiv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4i(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(2)).toSInt();

    GLint v1;
    v1 = (call.arg(3)).toSInt();

    GLint v2;
    v2 = (call.arg(4)).toSInt();

    GLint v3;
    v3 = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4i(program, location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4iv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint173_0 = (call.arg(3)).toArray();
        for (size_t _jGLint173 = 0; _jGLint173 < _a_GLint173_0->values.size(); ++_jGLint173) {
    value[_jGLint173] = (*_a_GLint173_0->values[_jGLint173]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4iv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4f(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(2)).toFloat();

    GLfloat v1;
    v1 = (call.arg(3)).toFloat();

    GLfloat v2;
    v2 = (call.arg(4)).toFloat();

    GLfloat v3;
    v3 = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4f(program, location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat158_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat158 = 0; _jGLfloat158 < _a_GLfloat158_0->values.size(); ++_jGLfloat158) {
    value[_jGLfloat158] = (*_a_GLfloat158_0->values[_jGLfloat158]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4fv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble v0;
    v0 = (call.arg(2)).toDouble();

    GLdouble v1;
    v1 = (call.arg(3)).toDouble();

    GLdouble v2;
    v2 = (call.arg(4)).toDouble();

    GLdouble v3;
    v3 = (call.arg(5)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4d(program, location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble84_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble84 = 0; _jGLdouble84 < _a_GLdouble84_0->values.size(); ++_jGLdouble84) {
    value[_jGLdouble84] = (*_a_GLdouble84_0->values[_jGLdouble84]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4dv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4ui(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(2)).toUInt();

    GLuint v1;
    v1 = (call.arg(3)).toUInt();

    GLuint v2;
    v2 = (call.arg(4)).toUInt();

    GLuint v3;
    v3 = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4ui(program, location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4uiv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint128_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint128 = 0; _jGLuint128 < _a_GLuint128_0->values.size(); ++_jGLuint128) {
    value[_jGLuint128] = (*_a_GLuint128_0->values[_jGLuint128]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4uiv(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat159_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat159 = 0; _jGLfloat159 < _a_GLfloat159_0->values.size(); ++_jGLfloat159) {
    value[_jGLfloat159] = (*_a_GLfloat159_0->values[_jGLfloat159]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat160_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat160 = 0; _jGLfloat160 < _a_GLfloat160_0->values.size(); ++_jGLfloat160) {
    value[_jGLfloat160] = (*_a_GLfloat160_0->values[_jGLfloat160]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat161_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat161 = 0; _jGLfloat161 < _a_GLfloat161_0->values.size(); ++_jGLfloat161) {
    value[_jGLfloat161] = (*_a_GLfloat161_0->values[_jGLfloat161]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble85_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble85 = 0; _jGLdouble85 < _a_GLdouble85_0->values.size(); ++_jGLdouble85) {
    value[_jGLdouble85] = (*_a_GLdouble85_0->values[_jGLdouble85]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble86_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble86 = 0; _jGLdouble86 < _a_GLdouble86_0->values.size(); ++_jGLdouble86) {
    value[_jGLdouble86] = (*_a_GLdouble86_0->values[_jGLdouble86]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble87_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble87 = 0; _jGLdouble87 < _a_GLdouble87_0->values.size(); ++_jGLdouble87) {
    value[_jGLdouble87] = (*_a_GLdouble87_0->values[_jGLdouble87]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2x3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat162_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat162 = 0; _jGLfloat162 < _a_GLfloat162_0->values.size(); ++_jGLfloat162) {
    value[_jGLfloat162] = (*_a_GLfloat162_0->values[_jGLfloat162]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3x2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat163_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat163 = 0; _jGLfloat163 < _a_GLfloat163_0->values.size(); ++_jGLfloat163) {
    value[_jGLfloat163] = (*_a_GLfloat163_0->values[_jGLfloat163]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2x4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat164_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat164 = 0; _jGLfloat164 < _a_GLfloat164_0->values.size(); ++_jGLfloat164) {
    value[_jGLfloat164] = (*_a_GLfloat164_0->values[_jGLfloat164]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4x2fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat165_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat165 = 0; _jGLfloat165 < _a_GLfloat165_0->values.size(); ++_jGLfloat165) {
    value[_jGLfloat165] = (*_a_GLfloat165_0->values[_jGLfloat165]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3x4fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat166_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat166 = 0; _jGLfloat166 < _a_GLfloat166_0->values.size(); ++_jGLfloat166) {
    value[_jGLfloat166] = (*_a_GLfloat166_0->values[_jGLfloat166]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4x3fv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat167_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat167 = 0; _jGLfloat167 < _a_GLfloat167_0->values.size(); ++_jGLfloat167) {
    value[_jGLfloat167] = (*_a_GLfloat167_0->values[_jGLfloat167]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2x3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble88_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble88 = 0; _jGLdouble88 < _a_GLdouble88_0->values.size(); ++_jGLdouble88) {
    value[_jGLdouble88] = (*_a_GLdouble88_0->values[_jGLdouble88]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3x2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble89_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble89 = 0; _jGLdouble89 < _a_GLdouble89_0->values.size(); ++_jGLdouble89) {
    value[_jGLdouble89] = (*_a_GLdouble89_0->values[_jGLdouble89]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2x4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble90_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble90 = 0; _jGLdouble90 < _a_GLdouble90_0->values.size(); ++_jGLdouble90) {
    value[_jGLdouble90] = (*_a_GLdouble90_0->values[_jGLdouble90]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4x2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble91_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble91 = 0; _jGLdouble91 < _a_GLdouble91_0->values.size(); ++_jGLdouble91) {
    value[_jGLdouble91] = (*_a_GLdouble91_0->values[_jGLdouble91]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3x4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble92_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble92 = 0; _jGLdouble92 < _a_GLdouble92_0->values.size(); ++_jGLdouble92) {
    value[_jGLdouble92] = (*_a_GLdouble92_0->values[_jGLdouble92]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4x3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble93_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble93 = 0; _jGLdouble93 < _a_GLdouble93_0->values.size(); ++_jGLdouble93) {
    value[_jGLdouble93] = (*_a_GLdouble93_0->values[_jGLdouble93]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glValidateProgramPipeline(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint pipeline;
    pipeline = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << size_t(pipeline) << " <- " << size_t(_pipeline_map[pipeline]) << "\n";
    }
    pipeline = _pipeline_map[pipeline];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glValidateProgramPipeline(pipeline);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL1d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL1d(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL2d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL2d(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL3d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL3d(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL4d(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    GLdouble w;
    w = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL4d(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL1dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLdouble9_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLdouble9_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL1dv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL2dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble94_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble94 = 0; _jGLdouble94 < _a_GLdouble94_0->values.size(); ++_jGLdouble94) {
    v[_jGLdouble94] = (*_a_GLdouble94_0->values[_jGLdouble94]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL2dv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL3dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble95_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble95 = 0; _jGLdouble95 < _a_GLdouble95_0->values.size(); ++_jGLdouble95) {
    v[_jGLdouble95] = (*_a_GLdouble95_0->values[_jGLdouble95]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL3dv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL4dv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble96_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble96 = 0; _jGLdouble96 < _a_GLdouble96_0->values.size(); ++_jGLdouble96) {
    v[_jGLdouble96] = (*_a_GLdouble96_0->values[_jGLdouble96]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL4dv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribLPointer(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(4), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribLPointer(index, size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glViewportArrayv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint first;
    first = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat168_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat168 = 0; _jGLfloat168 < _a_GLfloat168_0->values.size(); ++_jGLfloat168) {
    v[_jGLfloat168] = (*_a_GLfloat168_0->values[_jGLfloat168]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glViewportArrayv(first, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glViewportIndexedf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat w;
    w = (call.arg(3)).toFloat();

    GLfloat h;
    h = (call.arg(4)).toFloat();

    if (index == 0) {
        glretrace::updateDrawable(x + w, y + h);
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glViewportIndexedf(index, x, y, w, h);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glViewportIndexedfv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat169_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat169 = 0; _jGLfloat169 < _a_GLfloat169_0->values.size(); ++_jGLfloat169) {
    v[_jGLfloat169] = (*_a_GLfloat169_0->values[_jGLfloat169]).toFloat();
        }
    }

    if (index == 0) {
        GLfloat x = v[0], y = v[1], w = v[2], h = v[3];
        glretrace::updateDrawable(x + w, y + h);
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glViewportIndexedfv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glScissorArrayv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint first;
    first = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint174_0 = (call.arg(2)).toArray();
        for (size_t _jGLint174 = 0; _jGLint174 < _a_GLint174_0->values.size(); ++_jGLint174) {
    v[_jGLint174] = (*_a_GLint174_0->values[_jGLint174]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glScissorArrayv(first, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glScissorIndexed(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint left;
    left = (call.arg(1)).toSInt();

    GLint bottom;
    bottom = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glScissorIndexed(index, left, bottom, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glScissorIndexedv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint175_0 = (call.arg(1)).toArray();
        for (size_t _jGLint175 = 0; _jGLint175 < _a_GLint175_0->values.size(); ++_jGLint175) {
    v[_jGLint175] = (*_a_GLint175_0->values[_jGLint175]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glScissorIndexedv(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthRangeArrayv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint first;
    first = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble97_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble97 = 0; _jGLdouble97 < _a_GLdouble97_0->values.size(); ++_jGLdouble97) {
    v[_jGLdouble97] = (*_a_GLdouble97_0->values[_jGLdouble97]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthRangeArrayv(first, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthRangeIndexed(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble n;
    n = (call.arg(1)).toDouble();

    GLdouble f;
    f = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthRangeIndexed(index, n, f);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDebugMessageControlARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum source;
    source = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum severity;
    severity = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(4), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint129_0 = (call.arg(4)).toArray();
        for (size_t _jGLuint129 = 0; _jGLuint129 < _a_GLuint129_0->values.size(); ++_jGLuint129) {
    ids[_jGLuint129] = (*_a_GLuint129_0->values[_jGLuint129]).toUInt();
        }
    }

    GLboolean enabled;
    enabled = static_cast<GLboolean>((call.arg(5)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDebugMessageControlARB(source, type, severity, count, ids, enabled);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDebugMessageInsertARB(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum source;
    source = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint id;
    id = (call.arg(2)).toUInt();

    GLenum severity;
    severity = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei length;
    length = (call.arg(4)).toSInt();

    const GLchar * buf;
    buf = (const GLchar *)((call.arg(5)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDebugMessageInsertARB(source, type, id, severity, length, buf);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetnPixelMapfvARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei bufSize;
    bufSize = (call.arg(1)).toSInt();

    GLfloat * values;
    values = static_cast<GLfloat *>((call.arg(2)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnPixelMapfvARB(map, bufSize, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLfloat171 = (call.arg(2)).toArray();
    if (_aGLfloat171) {
        for (size_t _jGLfloat171 = 0; _jGLfloat171 < _aGLfloat171->values.size(); ++_jGLfloat171) {
        }
    }
}

static void retrace_glGetnPixelMapuivARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei bufSize;
    bufSize = (call.arg(1)).toSInt();

    GLuint * values;
    values = static_cast<GLuint *>((call.arg(2)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnPixelMapuivARB(map, bufSize, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint131 = (call.arg(2)).toArray();
    if (_aGLuint131) {
        for (size_t _jGLuint131 = 0; _jGLuint131 < _aGLuint131->values.size(); ++_jGLuint131) {
        }
    }
}

static void retrace_glGetnPixelMapusvARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum map;
    map = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei bufSize;
    bufSize = (call.arg(1)).toSInt();

    GLushort * values;
    values = static_cast<GLushort *>((call.arg(2)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnPixelMapusvARB(map, bufSize, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLushort14 = (call.arg(2)).toArray();
    if (_aGLushort14) {
        for (size_t _jGLushort14 = 0; _jGLushort14 < _aGLushort14->values.size(); ++_jGLushort14) {
        }
    }
}

static void retrace_glGetnPolygonStippleARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei bufSize;
    bufSize = (call.arg(0)).toSInt();

    GLubyte * pattern;
    pattern = static_cast<GLubyte *>((call.arg(1)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnPolygonStippleARB(bufSize, pattern);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetnConvolutionFilterARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei bufSize;
    bufSize = (call.arg(3)).toSInt();

    GLvoid * image;
    image = static_cast<GLvoid *>((call.arg(4)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnConvolutionFilterARB(target, format, type, bufSize, image);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetnSeparableFilterARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei rowBufSize;
    rowBufSize = (call.arg(3)).toSInt();

    GLvoid * row;
    row = static_cast<GLvoid *>((call.arg(4)).toPointer());

    GLsizei columnBufSize;
    columnBufSize = (call.arg(5)).toSInt();

    GLvoid * column;
    column = static_cast<GLvoid *>((call.arg(6)).toPointer());

    GLvoid * span;
    span = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetnHistogramARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLboolean reset;
    reset = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei bufSize;
    bufSize = (call.arg(4)).toSInt();

    GLvoid * values;
    values = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnHistogramARB(target, reset, format, type, bufSize, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetnMinmaxARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLboolean reset;
    reset = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei bufSize;
    bufSize = (call.arg(4)).toSInt();

    GLvoid * values;
    values = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnMinmaxARB(target, reset, format, type, bufSize, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetnTexImageARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei bufSize;
    bufSize = (call.arg(4)).toSInt();

    GLvoid * img;
    img = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnTexImageARB(target, level, format, type, bufSize, img);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReadnPixelsARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLsizei bufSize;
    bufSize = (call.arg(6)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetnCompressedTexImageARB(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint lod;
    lod = (call.arg(1)).toSInt();

    GLsizei bufSize;
    bufSize = (call.arg(2)).toSInt();

    GLvoid * img;
    img = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetnCompressedTexImageARB(target, lod, bufSize, img);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawArraysInstancedBaseInstance(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint first;
    first = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    GLuint baseinstance;
    baseinstance = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawArraysInstancedBaseInstance(mode, first, count, primcount, baseinstance);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawElementsInstancedBaseInstance(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(3)).toPointer());

    GLsizei primcount;
    primcount = (call.arg(4)).toSInt();

    GLuint baseinstance;
    baseinstance = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElementsInstancedBaseInstance(mode, count, type, indices, primcount, baseinstance);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawElementsInstancedBaseVertexBaseInstance(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(3)).toPointer());

    GLsizei primcount;
    primcount = (call.arg(4)).toSInt();

    GLint basevertex;
    basevertex = (call.arg(5)).toSInt();

    GLuint baseinstance;
    baseinstance = (call.arg(6)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, primcount, basevertex, baseinstance);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawTransformFeedbackInstanced(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(id) << " <- " << size_t(_feedback_map[id]) << "\n";
    }
    id = _feedback_map[id];

    GLsizei primcount;
    primcount = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTransformFeedbackInstanced(mode, id, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTransformFeedbackStreamInstanced(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(id) << " <- " << size_t(_feedback_map[id]) << "\n";
    }
    id = _feedback_map[id];

    GLuint stream;
    stream = (call.arg(2)).toUInt();

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTransformFeedbackStreamInstanced(mode, id, stream, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindImageTexture(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint unit;
    unit = (call.arg(0)).toUInt();

    GLuint texture;
    texture = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(2)).toSInt();

    GLboolean layered;
    layered = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLint layer;
    layer = (call.arg(4)).toSInt();

    GLenum access;
    access = static_cast<GLenum>((call.arg(5)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(6)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindImageTexture(unit, texture, level, layered, layer, access, format);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMemoryBarrier(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield barriers;
    barriers = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMemoryBarrier(barriers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorage1D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei levels;
    levels = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorage1D(target, levels, internalformat, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorage2D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei levels;
    levels = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorage2D(target, levels, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorage3D(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei levels;
    levels = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorage3D(target, levels, internalformat, width, height, depth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureStorage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei levels;
    levels = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureStorage1DEXT(texture, target, levels, internalformat, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureStorage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei levels;
    levels = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureStorage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei levels;
    levels = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLsizei depth;
    depth = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDebugMessageControl(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum source;
    source = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum severity;
    severity = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(4), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint132_0 = (call.arg(4)).toArray();
        for (size_t _jGLuint132 = 0; _jGLuint132 < _a_GLuint132_0->values.size(); ++_jGLuint132) {
    ids[_jGLuint132] = (*_a_GLuint132_0->values[_jGLuint132]).toUInt();
        }
    }

    GLboolean enabled;
    enabled = static_cast<GLboolean>((call.arg(5)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDebugMessageControl(source, type, severity, count, ids, enabled);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDebugMessageInsert(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum source;
    source = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint id;
    id = (call.arg(2)).toUInt();

    GLenum severity;
    severity = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei length;
    length = (call.arg(4)).toSInt();

    const GLchar * buf;
    buf = (const GLchar *)((call.arg(5)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDebugMessageInsert(source, type, id, severity, length, buf);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPushDebugGroup(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum source;
    source = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();

    GLsizei length;
    length = (call.arg(2)).toSInt();

    const GLchar * message;
    message = (const GLchar *)((call.arg(3)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPushDebugGroup(source, id, length, message);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPopDebugGroup(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPopDebugGroup();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glObjectLabel(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum identifier;
    identifier = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint name;
    name = (call.arg(1)).toUInt();

    GLsizei length;
    length = (call.arg(2)).toSInt();

    const GLchar * label;
    label = (const GLchar *)((call.arg(3)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glObjectLabel(identifier, name, length, label);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glObjectPtrLabel(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    const void * ptr;
    memset(&ptr, 0, sizeof ptr); // FIXME

    GLsizei length;
    length = (call.arg(1)).toSInt();

    const GLchar * label;
    label = (const GLchar *)((call.arg(2)).toString());

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glObjectPtrLabel(ptr, length, label);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearBufferData(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    void * data;
    data = static_cast<void *>((call.arg(4)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearBufferData(target, internalformat, format, type, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearBufferSubData(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLintptr offset;
    offset = (call.arg(2)).toSInt();

    GLsizeiptr size;
    size = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    void * data;
    data = static_cast<void *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearBufferSubData(target, internalformat, offset, size, format, type, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearNamedBufferDataEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    void * data;
    data = static_cast<void *>((call.arg(4)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearNamedBufferDataEXT(buffer, internalformat, format, type, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearNamedBufferSubDataEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizeiptr offset;
    offset = (call.arg(4)).toSInt();

    GLsizeiptr size;
    size = (call.arg(5)).toSInt();

    void * data;
    data = static_cast<void *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearNamedBufferSubDataEXT(buffer, internalformat, format, type, offset, size, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDispatchCompute(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint num_groups_x;
    num_groups_x = (call.arg(0)).toUInt();

    GLuint num_groups_y;
    num_groups_y = (call.arg(1)).toUInt();

    GLuint num_groups_z;
    num_groups_z = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDispatchComputeIndirect(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLintptr indirect;
    indirect = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDispatchComputeIndirect(indirect);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyImageSubData(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint srcName;
    srcName = (call.arg(0)).toUInt();

    GLenum srcTarget;
    srcTarget = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint srcLevel;
    srcLevel = (call.arg(2)).toSInt();

    GLint srcX;
    srcX = (call.arg(3)).toSInt();

    GLint srcY;
    srcY = (call.arg(4)).toSInt();

    GLint srcZ;
    srcZ = (call.arg(5)).toSInt();

    GLuint dstName;
    dstName = (call.arg(6)).toUInt();

    GLenum dstTarget;
    dstTarget = static_cast<GLenum>((call.arg(7)).toSInt());

    GLint dstLevel;
    dstLevel = (call.arg(8)).toSInt();

    GLint dstX;
    dstX = (call.arg(9)).toSInt();

    GLint dstY;
    dstY = (call.arg(10)).toSInt();

    GLint dstZ;
    dstZ = (call.arg(11)).toSInt();

    GLsizei srcWidth;
    srcWidth = (call.arg(12)).toSInt();

    GLsizei srcHeight;
    srcHeight = (call.arg(13)).toSInt();

    GLsizei srcDepth;
    srcDepth = (call.arg(14)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureView(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint origtexture;
    origtexture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(origtexture) << " <- " << size_t(_texture_map[origtexture]) << "\n";
    }
    origtexture = _texture_map[origtexture];

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLuint minlevel;
    minlevel = (call.arg(4)).toUInt();

    GLuint numlevels;
    numlevels = (call.arg(5)).toUInt();

    GLuint minlayer;
    minlayer = (call.arg(6)).toUInt();

    GLuint numlayers;
    numlayers = (call.arg(7)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindVertexBuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint bindingindex;
    bindingindex = (call.arg(0)).toUInt();

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(2)).toSInt();

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindVertexBuffer(bindingindex, buffer, offset, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribFormat(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint attribindex;
    attribindex = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLuint relativeoffset;
    relativeoffset = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribIFormat(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint attribindex;
    attribindex = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint relativeoffset;
    relativeoffset = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribIFormat(attribindex, size, type, relativeoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribLFormat(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint attribindex;
    attribindex = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint relativeoffset;
    relativeoffset = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribLFormat(attribindex, size, type, relativeoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribBinding(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint attribindex;
    attribindex = (call.arg(0)).toUInt();

    GLuint bindingindex;
    bindingindex = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribBinding(attribindex, bindingindex);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexBindingDivisor(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint bindingindex;
    bindingindex = (call.arg(0)).toUInt();

    GLuint divisor;
    divisor = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexBindingDivisor(bindingindex, divisor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayBindVertexBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint bindingindex;
    bindingindex = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(3)).toSInt();

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexAttribFormatEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint attribindex;
    attribindex = (call.arg(1)).toUInt();

    GLint size;
    size = (call.arg(2)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(4)).toSInt());

    GLuint relativeoffset;
    relativeoffset = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, type, normalized, relativeoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexAttribIFormatEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint attribindex;
    attribindex = (call.arg(1)).toUInt();

    GLint size;
    size = (call.arg(2)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLuint relativeoffset;
    relativeoffset = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, type, relativeoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexAttribLFormatEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint attribindex;
    attribindex = (call.arg(1)).toUInt();

    GLint size;
    size = (call.arg(2)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLuint relativeoffset;
    relativeoffset = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, type, relativeoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexAttribBindingEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint attribindex;
    attribindex = (call.arg(1)).toUInt();

    GLuint bindingindex;
    bindingindex = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexBindingDivisorEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint bindingindex;
    bindingindex = (call.arg(1)).toUInt();

    GLuint divisor;
    divisor = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferParameteri(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferParameteri(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedFramebufferParameteriEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedFramebufferParameteriEXT(framebuffer, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInvalidateTexSubImage(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLsizei depth;
    depth = (call.arg(7)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInvalidateTexImage(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInvalidateTexImage(texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInvalidateBufferSubData(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptr length;
    length = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInvalidateBufferSubData(buffer, offset, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInvalidateBufferData(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInvalidateBufferData(buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInvalidateFramebuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei numAttachments;
    numAttachments = (call.arg(1)).toSInt();

    GLenum * attachments;
    attachments = static_cast<GLenum *>(_allocator.alloc(&call.arg(2), sizeof *attachments));
    if (attachments) {
        const trace::Array *_a_GLenum12_0 = (call.arg(2)).toArray();
        for (size_t _jGLenum12 = 0; _jGLenum12 < _a_GLenum12_0->values.size(); ++_jGLenum12) {
    attachments[_jGLenum12] = static_cast<GLenum>((*_a_GLenum12_0->values[_jGLenum12]).toSInt());
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInvalidateFramebuffer(target, numAttachments, attachments);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInvalidateSubFramebuffer(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei numAttachments;
    numAttachments = (call.arg(1)).toSInt();

    GLenum * attachments;
    attachments = static_cast<GLenum *>(_allocator.alloc(&call.arg(2), sizeof *attachments));
    if (attachments) {
        const trace::Array *_a_GLenum13_0 = (call.arg(2)).toArray();
        for (size_t _jGLenum13 = 0; _jGLenum13 < _a_GLenum13_0->values.size(); ++_jGLenum13) {
    attachments[_jGLenum13] = static_cast<GLenum>((*_a_GLenum13_0->values[_jGLenum13]).toSInt());
        }
    }

    GLint x;
    x = (call.arg(3)).toSInt();

    GLint y;
    y = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiDrawArraysIndirect(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    const void * indirect;
    indirect = static_cast<const void *>(retrace::toPointer(call.arg(1)));

    GLsizei drawcount;
    drawcount = (call.arg(2)).toSInt();

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glMultiDrawElementsIndirect(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    const void * indirect;
    indirect = static_cast<const void *>(retrace::toPointer(call.arg(2)));

    GLsizei drawcount;
    drawcount = (call.arg(3)).toSInt();

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glShaderStorageBlockBinding(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLuint storageBlockIndex;
    storageBlockIndex = (call.arg(1)).toUInt();

    GLuint storageBlockBinding;
    storageBlockBinding = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexBufferRange(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(3)).toSInt();

    GLsizeiptr size;
    size = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexBufferRange(target, internalformat, buffer, offset, size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureBufferRangeEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint buffer;
    buffer = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(4)).toSInt();

    GLsizeiptr size;
    size = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorage2DMultisample(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLboolean fixedsamplelocations;
    fixedsamplelocations = static_cast<GLboolean>((call.arg(5)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorage3DMultisample(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLboolean fixedsamplelocations;
    fixedsamplelocations = static_cast<GLboolean>((call.arg(6)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureStorage2DMultisampleEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei samples;
    samples = (call.arg(2)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLboolean fixedsamplelocations;
    fixedsamplelocations = static_cast<GLboolean>((call.arg(6)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureStorage3DMultisampleEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei samples;
    samples = (call.arg(2)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLsizei depth;
    depth = (call.arg(6)).toSInt();

    GLboolean fixedsamplelocations;
    fixedsamplelocations = static_cast<GLboolean>((call.arg(7)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendColorEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat red;
    red = (call.arg(0)).toFloat();

    GLfloat green;
    green = (call.arg(1)).toFloat();

    GLfloat blue;
    blue = (call.arg(2)).toFloat();

    GLfloat alpha;
    alpha = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendColorEXT(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPolygonOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat factor;
    factor = (call.arg(0)).toFloat();

    GLfloat bias;
    bias = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPolygonOffsetEXT(factor, bias);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(8)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexSubImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLsizei depth;
    depth = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(9)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(10)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexFilterFuncSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum filter;
    filter = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei n;
    n = (call.arg(2)).toSInt();

    GLfloat * weights;
    weights = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLfloat172_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat172 = 0; _jGLfloat172 < _a_GLfloat172_0->values.size(); ++_jGLfloat172) {
    weights[_jGLfloat172] = (*_a_GLfloat172_0->values[_jGLfloat172]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexFilterFuncSGIS(target, filter, n, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexSubImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexSubImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(6)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(7)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint x;
    x = (call.arg(3)).toSInt();

    GLint y;
    y = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint x;
    x = (call.arg(3)).toSInt();

    GLint y;
    y = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexSubImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint x;
    x = (call.arg(3)).toSInt();

    GLint y;
    y = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexSubImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint x;
    x = (call.arg(4)).toSInt();

    GLint y;
    y = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexSubImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLint x;
    x = (call.arg(5)).toSInt();

    GLint y;
    y = (call.arg(6)).toSInt();

    GLsizei width;
    width = (call.arg(7)).toSInt();

    GLsizei height;
    height = (call.arg(8)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glHistogramEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei width;
    width = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLboolean sink;
    sink = static_cast<GLboolean>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glHistogramEXT(target, width, internalformat, sink);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMinmaxEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLboolean sink;
    sink = static_cast<GLboolean>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMinmaxEXT(target, internalformat, sink);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glResetHistogramEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glResetHistogramEXT(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glResetMinmaxEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glResetMinmaxEXT(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionFilter1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * image;
    image = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionFilter2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLvoid * image;
    image = static_cast<GLvoid *>((call.arg(6)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionParameterfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat params;
    params = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionParameterfEXT(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionParameterfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat173_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat173 = 0; _jGLfloat173 < _a_GLfloat173_0->values.size(); ++_jGLfloat173) {
    params[_jGLfloat173] = (*_a_GLfloat173_0->values[_jGLfloat173]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionParameterfvEXT(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionParameteriEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint params;
    params = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionParameteriEXT(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glConvolutionParameterivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint176_0 = (call.arg(2)).toArray();
        for (size_t _jGLint176 = 0; _jGLint176 < _a_GLint176_0->values.size(); ++_jGLint176) {
    params[_jGLint176] = (*_a_GLint176_0->values[_jGLint176]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glConvolutionParameterivEXT(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyConvolutionFilter1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyConvolutionFilter2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSeparableFilter2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLvoid * row;
    row = static_cast<GLvoid *>((call.arg(6)).toPointer());

    GLvoid * column;
    column = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorTableSGI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * table;
    table = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorTableSGI(target, internalformat, width, format, type, table);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorTableParameterfvSGI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat174_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat174 = 0; _jGLfloat174 < _a_GLfloat174_0->values.size(); ++_jGLfloat174) {
    params[_jGLfloat174] = (*_a_GLfloat174_0->values[_jGLfloat174]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorTableParameterfvSGI(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorTableParameterivSGI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint177_0 = (call.arg(2)).toArray();
        for (size_t _jGLint177 = 0; _jGLint177 < _a_GLint177_0->values.size(); ++_jGLint177) {
    params[_jGLint177] = (*_a_GLint177_0->values[_jGLint177]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorTableParameterivSGI(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyColorTableSGI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyColorTableSGI(target, internalformat, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTexGenSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTexGenSGIX(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTexGenParameteriSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTexGenParameteriSGIS(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTexGenParameterivSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint178_0 = (call.arg(1)).toArray();
        for (size_t _jGLint178 = 0; _jGLint178 < _a_GLint178_0->values.size(); ++_jGLint178) {
    params[_jGLint178] = (*_a_GLint178_0->values[_jGLint178]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTexGenParameterivSGIS(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTexGenParameterfSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTexGenParameterfSGIS(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTexGenParameterfvSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat175_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat175 = 0; _jGLfloat175 < _a_GLfloat175_0->values.size(); ++_jGLfloat175) {
    params[_jGLfloat175] = (*_a_GLfloat175_0->values[_jGLfloat175]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTexGenParameterfvSGIS(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexImage4DSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLsizei size4d;
    size4d = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(9)).toSInt());

    const GLvoid * pixels;
    memset(&pixels, 0, sizeof pixels); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexSubImage4DSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLint woffset;
    woffset = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    GLsizei depth;
    depth = (call.arg(8)).toSInt();

    GLsizei size4d;
    size4d = (call.arg(9)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(10)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(11)).toSInt());

    const GLvoid * pixels;
    memset(&pixels, 0, sizeof pixels); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindTextureEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint texture;
    texture = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindTextureEXT(target, texture);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteTexturesEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * textures;
    textures = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *textures));
    if (textures) {
        const trace::Array *_a_GLuint135_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint135 = 0; _jGLuint135 < _a_GLuint135_0->values.size(); ++_jGLuint135) {
    textures[_jGLuint135] = (*_a_GLuint135_0->values[_jGLuint135]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(textures[_jGLuint135]) << " <- " << size_t(_texture_map[textures[_jGLuint135]]) << "\n";
    }
    textures[_jGLuint135] = _texture_map[textures[_jGLuint135]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteTexturesEXT(n, textures);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenTexturesEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * textures;
    textures = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *textures));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenTexturesEXT(n, textures);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint137 = (call.arg(1)).toArray();
    if (_aGLuint137) {
        for (size_t _jGLuint137 = 0; _jGLuint137 < _aGLuint137->values.size(); ++_jGLuint137) {
    GLuint _origResult;
    _origResult = (*_aGLuint137->values[_jGLuint137]).toUInt();
    _texture_map[_origResult] = textures[_jGLuint137];
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << _origResult << " -> " << textures[_jGLuint137] << "\n";
    }
        }
    }
}

static void retrace_glPrioritizeTexturesEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * textures;
    textures = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *textures));
    if (textures) {
        const trace::Array *_a_GLuint138_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint138 = 0; _jGLuint138 < _a_GLuint138_0->values.size(); ++_jGLuint138) {
    textures[_jGLuint138] = (*_a_GLuint138_0->values[_jGLuint138]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(textures[_jGLuint138]) << " <- " << size_t(_texture_map[textures[_jGLuint138]]) << "\n";
    }
    textures[_jGLuint138] = _texture_map[textures[_jGLuint138]];
        }
    }

    GLclampf * priorities;
    priorities = static_cast<GLclampf *>(_allocator.alloc(&call.arg(2), sizeof *priorities));
    if (priorities) {
        const trace::Array *_a_GLclampf2_0 = (call.arg(2)).toArray();
        for (size_t _jGLclampf2 = 0; _jGLclampf2 < _a_GLclampf2_0->values.size(); ++_jGLclampf2) {
    priorities[_jGLclampf2] = (*_a_GLclampf2_0->values[_jGLclampf2]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPrioritizeTexturesEXT(n, textures, priorities);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDetailTexFuncSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei n;
    n = (call.arg(1)).toSInt();

    GLfloat * points;
    points = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *points));
    if (points) {
        const trace::Array *_a_GLfloat176_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat176 = 0; _jGLfloat176 < _a_GLfloat176_0->values.size(); ++_jGLfloat176) {
    points[_jGLfloat176] = (*_a_GLfloat176_0->values[_jGLfloat176]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDetailTexFuncSGIS(target, n, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSharpenTexFuncSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei n;
    n = (call.arg(1)).toSInt();

    GLfloat * points;
    points = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *points));
    if (points) {
        const trace::Array *_a_GLfloat177_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat177 = 0; _jGLfloat177 < _a_GLfloat177_0->values.size(); ++_jGLfloat177) {
    points[_jGLfloat177] = (*_a_GLfloat177_0->values[_jGLfloat177]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSharpenTexFuncSGIS(target, n, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSampleMaskSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLclampf value;
    value = (call.arg(0)).toFloat();

    GLboolean invert;
    invert = static_cast<GLboolean>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSampleMaskSGIS(value, invert);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSamplePatternSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pattern;
    pattern = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSamplePatternSGIS(pattern);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glArrayElementEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint i;
    i = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glArrayElementEXT(i);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = static_cast<GLint>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(4), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorPointerEXT(size, type, stride, count, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawArraysEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint first;
    first = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawArraysEXT(mode, first, count);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glEdgeFlagPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei stride;
    stride = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    const GLboolean * pointer;
    pointer = static_cast<const GLboolean *>(retrace::toPointer(call.arg(2), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEdgeFlagPointerEXT(stride, count, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(3), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexPointerEXT(type, stride, count, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(3), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalPointerEXT(type, stride, count, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(4), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordPointerEXT(size, type, stride, count, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(4), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexPointerEXT(size, type, stride, count, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationEXT(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSpriteParameterfSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSpriteParameterfSGIX(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSpriteParameterfvSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat178_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat178 = 0; _jGLfloat178 < _a_GLfloat178_0->values.size(); ++_jGLfloat178) {
    params[_jGLfloat178] = (*_a_GLfloat178_0->values[_jGLfloat178]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSpriteParameterfvSGIX(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSpriteParameteriSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSpriteParameteriSGIX(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSpriteParameterivSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint179_0 = (call.arg(1)).toArray();
        for (size_t _jGLint179 = 0; _jGLint179 < _a_GLint179_0->values.size(); ++_jGLint179) {
    params[_jGLint179] = (*_a_GLint179_0->values[_jGLint179]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSpriteParameterivSGIX(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterfEXT(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat179_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat179 = 0; _jGLfloat179 < _a_GLfloat179_0->values.size(); ++_jGLfloat179) {
    params[_jGLfloat179] = (*_a_GLfloat179_0->values[_jGLfloat179]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterfvEXT(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterfSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterfSGIS(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterfvSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat180_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat180 = 0; _jGLfloat180 < _a_GLfloat180_0->values.size(); ++_jGLfloat180) {
    params[_jGLfloat180] = (*_a_GLfloat180_0->values[_jGLfloat180]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterfvSGIS(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInstrumentsBufferSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei size;
    size = (call.arg(0)).toSInt();

    GLint * buffer;
    memset(&buffer, 0, sizeof buffer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInstrumentsBufferSGIX(size, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPollInstrumentsSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * marker_p;
    marker_p = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *marker_p));

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glPollInstrumentsSGIX(marker_p);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aPGLint9 = (call.arg(0)).toArray();
    if (_aPGLint9) {
    }
}

static void retrace_glReadInstrumentsSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint marker;
    marker = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReadInstrumentsSGIX(marker);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStartInstrumentsSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStartInstrumentsSGIX();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStopInstrumentsSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint marker;
    marker = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStopInstrumentsSGIX(marker);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFrameZoomSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint factor;
    factor = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFrameZoomSGIX(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTagSampleBufferSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTagSampleBufferSGIX();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeformationMap3dSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble u1;
    u1 = (call.arg(1)).toDouble();

    GLdouble u2;
    u2 = (call.arg(2)).toDouble();

    GLint ustride;
    ustride = (call.arg(3)).toSInt();

    GLint uorder;
    uorder = (call.arg(4)).toSInt();

    GLdouble v1;
    v1 = (call.arg(5)).toDouble();

    GLdouble v2;
    v2 = (call.arg(6)).toDouble();

    GLint vstride;
    vstride = (call.arg(7)).toSInt();

    GLint vorder;
    vorder = (call.arg(8)).toSInt();

    GLdouble w1;
    w1 = (call.arg(9)).toDouble();

    GLdouble w2;
    w2 = (call.arg(10)).toDouble();

    GLint wstride;
    wstride = (call.arg(11)).toSInt();

    GLint worder;
    worder = (call.arg(12)).toSInt();

    const GLdouble * points;
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeformationMap3fSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat u1;
    u1 = (call.arg(1)).toFloat();

    GLfloat u2;
    u2 = (call.arg(2)).toFloat();

    GLint ustride;
    ustride = (call.arg(3)).toSInt();

    GLint uorder;
    uorder = (call.arg(4)).toSInt();

    GLfloat v1;
    v1 = (call.arg(5)).toFloat();

    GLfloat v2;
    v2 = (call.arg(6)).toFloat();

    GLint vstride;
    vstride = (call.arg(7)).toSInt();

    GLint vorder;
    vorder = (call.arg(8)).toSInt();

    GLfloat w1;
    w1 = (call.arg(9)).toFloat();

    GLfloat w2;
    w2 = (call.arg(10)).toFloat();

    GLint wstride;
    wstride = (call.arg(11)).toSInt();

    GLint worder;
    worder = (call.arg(12)).toSInt();

    const GLfloat * points;
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeformSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeformSGIX(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadIdentityDeformationMapSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadIdentityDeformationMapSGIX(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReferencePlaneSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * equation;
    equation = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *equation));
    if (equation) {
        const trace::Array *_a_GLdouble98_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble98 = 0; _jGLdouble98 < _a_GLdouble98_0->values.size(); ++_jGLdouble98) {
    equation[_jGLdouble98] = (*_a_GLdouble98_0->values[_jGLdouble98]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReferencePlaneSGIX(equation);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFlushRasterSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlushRasterSGIX();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogFuncSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLfloat * points;
    points = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *points));
    if (points) {
        const trace::Array *_a_GLfloat181_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat181 = 0; _jGLfloat181 < _a_GLfloat181_0->values.size(); ++_jGLfloat181) {
    points[_jGLfloat181] = (*_a_GLfloat181_0->values[_jGLfloat181]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogFuncSGIS(n, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glImageTransformParameteriHP(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glImageTransformParameteriHP(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glImageTransformParameterfHP(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glImageTransformParameterfHP(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glImageTransformParameterivHP(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint180_0 = (call.arg(2)).toArray();
        for (size_t _jGLint180 = 0; _jGLint180 < _a_GLint180_0->values.size(); ++_jGLint180) {
    params[_jGLint180] = (*_a_GLint180_0->values[_jGLint180]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glImageTransformParameterivHP(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glImageTransformParameterfvHP(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat182_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat182 = 0; _jGLfloat182 < _a_GLfloat182_0->values.size(); ++_jGLfloat182) {
    params[_jGLfloat182] = (*_a_GLfloat182_0->values[_jGLfloat182]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glImageTransformParameterfvHP(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorSubTableEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei start;
    start = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorSubTableEXT(target, start, count, format, type, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyColorSubTableEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei start;
    start = (call.arg(1)).toSInt();

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyColorSubTableEXT(target, start, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glHintPGI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint mode;
    mode = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glHintPGI(target, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorTableEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * table;
    table = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorTableEXT(target, internalformat, width, format, type, table);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glListParameterfSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint list;
    list = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "list " << size_t(list) << " <- " << size_t(_list_map[list]) << "\n";
    }
    list = _list_map[list];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glListParameterfSGIX(list, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glListParameterfvSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint list;
    list = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "list " << size_t(list) << " <- " << size_t(_list_map[list]) << "\n";
    }
    list = _list_map[list];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat183_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat183 = 0; _jGLfloat183 < _a_GLfloat183_0->values.size(); ++_jGLfloat183) {
    params[_jGLfloat183] = (*_a_GLfloat183_0->values[_jGLfloat183]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glListParameterfvSGIX(list, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glListParameteriSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint list;
    list = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "list " << size_t(list) << " <- " << size_t(_list_map[list]) << "\n";
    }
    list = _list_map[list];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glListParameteriSGIX(list, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glListParameterivSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint list;
    list = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "list " << size_t(list) << " <- " << size_t(_list_map[list]) << "\n";
    }
    list = _list_map[list];

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint181_0 = (call.arg(2)).toArray();
        for (size_t _jGLint181 = 0; _jGLint181 < _a_GLint181_0->values.size(); ++_jGLint181) {
    params[_jGLint181] = (*_a_GLint181_0->values[_jGLint181]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glListParameterivSGIX(list, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexMaterialEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexMaterialEXT(face, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexFuncEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum func;
    func = static_cast<GLenum>((call.arg(0)).toSInt());

    GLclampf ref;
    ref = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexFuncEXT(func, ref);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLockArraysEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint first;
    first = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLockArraysEXT(first, count);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUnlockArraysEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUnlockArraysEXT();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCullParameterdvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * params;
    params = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLdouble99_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble99 = 0; _jGLdouble99 < _a_GLdouble99_0->values.size(); ++_jGLdouble99) {
    params[_jGLdouble99] = (*_a_GLdouble99_0->values[_jGLdouble99]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCullParameterdvEXT(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCullParameterfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat184_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat184 = 0; _jGLfloat184 < _a_GLfloat184_0->values.size(); ++_jGLfloat184) {
    params[_jGLfloat184] = (*_a_GLfloat184_0->values[_jGLfloat184]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCullParameterfvEXT(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentColorMaterialSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentColorMaterialSGIX(face, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentLightfSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentLightfSGIX(light, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentLightfvSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat185_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat185 = 0; _jGLfloat185 < _a_GLfloat185_0->values.size(); ++_jGLfloat185) {
    params[_jGLfloat185] = (*_a_GLfloat185_0->values[_jGLfloat185]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentLightfvSGIX(light, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentLightiSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentLightiSGIX(light, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentLightivSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint182_0 = (call.arg(2)).toArray();
        for (size_t _jGLint182 = 0; _jGLint182 < _a_GLint182_0->values.size(); ++_jGLint182) {
    params[_jGLint182] = (*_a_GLint182_0->values[_jGLint182]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentLightivSGIX(light, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentLightModelfSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentLightModelfSGIX(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentLightModelfvSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat186_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat186 = 0; _jGLfloat186 < _a_GLfloat186_0->values.size(); ++_jGLfloat186) {
    params[_jGLfloat186] = (*_a_GLfloat186_0->values[_jGLfloat186]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentLightModelfvSGIX(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentLightModeliSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentLightModeliSGIX(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentLightModelivSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint183_0 = (call.arg(1)).toArray();
        for (size_t _jGLint183 = 0; _jGLint183 < _a_GLint183_0->values.size(); ++_jGLint183) {
    params[_jGLint183] = (*_a_GLint183_0->values[_jGLint183]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentLightModelivSGIX(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentMaterialfSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentMaterialfSGIX(face, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentMaterialfvSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat187_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat187 = 0; _jGLfloat187 < _a_GLfloat187_0->values.size(); ++_jGLfloat187) {
    params[_jGLfloat187] = (*_a_GLfloat187_0->values[_jGLfloat187]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentMaterialfvSGIX(face, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentMaterialiSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentMaterialiSGIX(face, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFragmentMaterialivSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint184_0 = (call.arg(2)).toArray();
        for (size_t _jGLint184 = 0; _jGLint184 < _a_GLint184_0->values.size(); ++_jGLint184) {
    params[_jGLint184] = (*_a_GLint184_0->values[_jGLint184]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFragmentMaterialivSGIX(face, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightEnviSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightEnviSGIX(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawRangeElementsEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint start;
    start = (call.arg(1)).toUInt();

    GLuint end;
    end = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawRangeElementsEXT(mode, start, end, count, type, indices);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glApplyTextureEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glApplyTextureEXT(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureLightEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureLightEXT(pname);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureMaterialEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureMaterialEXT(face, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAsyncMarkerSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint marker;
    marker = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAsyncMarkerSGIX(marker);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFinishAsyncSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * markerp;
    markerp = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *markerp));

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glFinishAsyncSGIX(markerp);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aPGLuint21 = (call.arg(0)).toArray();
    if (_aPGLuint21) {
    }
}

static void retrace_glPollAsyncSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * markerp;
    markerp = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *markerp));

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glPollAsyncSGIX(markerp);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aPGLuint22 = (call.arg(0)).toArray();
    if (_aPGLuint22) {
    }
}

static void retrace_glGenAsyncMarkersSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei range;
    range = (call.arg(0)).toSInt();

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGenAsyncMarkersSGIX(range);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteAsyncMarkersSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint marker;
    marker = (call.arg(0)).toUInt();

    GLsizei range;
    range = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteAsyncMarkersSGIX(marker, range);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexPointervINTEL(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexPointervINTEL(size, type, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalPointervINTEL(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalPointervINTEL(type, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorPointervINTEL(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = static_cast<GLint>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorPointervINTEL(size, type, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordPointervINTEL(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordPointervINTEL(size, type, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTransformParameteriEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTransformParameteriEXT(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTransformParameterfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTransformParameterfEXT(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTransformParameterivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_PGLint29_0 = (call.arg(2)).toArray();
    params[0] = (*_a_PGLint29_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTransformParameterivEXT(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelTransformParameterfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_PGLfloat19_0 = (call.arg(2)).toArray();
    params[0] = (*_a_PGLfloat19_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelTransformParameterfvEXT(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3bEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte red;
    red = (call.arg(0)).toSInt();

    GLbyte green;
    green = (call.arg(1)).toSInt();

    GLbyte blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3bEXT(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3bvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte11_0 = (call.arg(0)).toArray();
        for (size_t _jGLbyte11 = 0; _jGLbyte11 < _a_GLbyte11_0->values.size(); ++_jGLbyte11) {
    v[_jGLbyte11] = (*_a_GLbyte11_0->values[_jGLbyte11]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3bvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble red;
    red = (call.arg(0)).toDouble();

    GLdouble green;
    green = (call.arg(1)).toDouble();

    GLdouble blue;
    blue = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3dEXT(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble100_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble100 = 0; _jGLdouble100 < _a_GLdouble100_0->values.size(); ++_jGLdouble100) {
    v[_jGLdouble100] = (*_a_GLdouble100_0->values[_jGLdouble100]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3dvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3fEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat red;
    red = (call.arg(0)).toFloat();

    GLfloat green;
    green = (call.arg(1)).toFloat();

    GLfloat blue;
    blue = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3fEXT(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat188_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat188 = 0; _jGLfloat188 < _a_GLfloat188_0->values.size(); ++_jGLfloat188) {
    v[_jGLfloat188] = (*_a_GLfloat188_0->values[_jGLfloat188]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3fvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint red;
    red = (call.arg(0)).toSInt();

    GLint green;
    green = (call.arg(1)).toSInt();

    GLint blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3iEXT(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint185_0 = (call.arg(0)).toArray();
        for (size_t _jGLint185 = 0; _jGLint185 < _a_GLint185_0->values.size(); ++_jGLint185) {
    v[_jGLint185] = (*_a_GLint185_0->values[_jGLint185]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3ivEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3sEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort red;
    red = (call.arg(0)).toSInt();

    GLshort green;
    green = (call.arg(1)).toSInt();

    GLshort blue;
    blue = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3sEXT(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3svEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort36_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort36 = 0; _jGLshort36 < _a_GLshort36_0->values.size(); ++_jGLshort36) {
    v[_jGLshort36] = (*_a_GLshort36_0->values[_jGLshort36]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3svEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3ubEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte red;
    red = (call.arg(0)).toUInt();

    GLubyte green;
    green = (call.arg(1)).toUInt();

    GLubyte blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3ubEXT(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3ubvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte16_0 = (call.arg(0)).toArray();
        for (size_t _jGLubyte16 = 0; _jGLubyte16 < _a_GLubyte16_0->values.size(); ++_jGLubyte16) {
    v[_jGLubyte16] = (*_a_GLubyte16_0->values[_jGLubyte16]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3ubvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint red;
    red = (call.arg(0)).toUInt();

    GLuint green;
    green = (call.arg(1)).toUInt();

    GLuint blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3uiEXT(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint139_0 = (call.arg(0)).toArray();
        for (size_t _jGLuint139 = 0; _jGLuint139 < _a_GLuint139_0->values.size(); ++_jGLuint139) {
    v[_jGLuint139] = (*_a_GLuint139_0->values[_jGLuint139]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3uivEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3usEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort red;
    red = (call.arg(0)).toUInt();

    GLushort green;
    green = (call.arg(1)).toUInt();

    GLushort blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3usEXT(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3usvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort15_0 = (call.arg(0)).toArray();
        for (size_t _jGLushort15 = 0; _jGLushort15 < _a_GLushort15_0->values.size(); ++_jGLushort15) {
    v[_jGLushort15] = (*_a_GLushort15_0->values[_jGLushort15]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3usvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColorPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = static_cast<GLint>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(3), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColorPointerEXT(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureNormalEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureNormalEXT(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiDrawArraysEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * first;
    first = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *first));
    if (first) {
        const trace::Array *_a_GLint186_0 = (call.arg(1)).toArray();
        for (size_t _jGLint186 = 0; _jGLint186 < _a_GLint186_0->values.size(); ++_jGLint186) {
    first[_jGLint186] = (*_a_GLint186_0->values[_jGLint186]).toSInt();
        }
    }

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(2), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei7_0 = (call.arg(2)).toArray();
        for (size_t _jGLsizei7 = 0; _jGLsizei7 < _a_GLsizei7_0->values.size(); ++_jGLsizei7) {
    count[_jGLsizei7] = (*_a_GLsizei7_0->values[_jGLsizei7]).toSInt();
        }
    }

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawArraysEXT(mode, first, count, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glMultiDrawElementsEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(1), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei8_0 = (call.arg(1)).toArray();
        for (size_t _jGLsizei8 = 0; _jGLsizei8 < _a_GLsizei8_0->values.size(); ++_jGLsizei8) {
    count[_jGLsizei8] = (*_a_GLsizei8_0->values[_jGLsizei8]).toSInt();
        }
    }

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * * indices;
    indices = static_cast<const GLvoid * *>(_allocator.alloc(&call.arg(3), sizeof *indices));
    if (indices) {
        const trace::Array *_a_constGLvoid175_0 = (call.arg(3)).toArray();
        for (size_t _jconstGLvoid175 = 0; _jconstGLvoid175 < _a_constGLvoid175_0->values.size(); ++_jconstGLvoid175) {
    indices[_jconstGLvoid175] = static_cast<const GLvoid *>((*_a_constGLvoid175_0->values[_jconstGLvoid175]).toPointer());
        }
    }

    GLsizei primcount;
    primcount = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawElementsEXT(mode, count, type, indices, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glFogCoordfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat coord;
    coord = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordfEXT(coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * coord;
    coord = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *coord));
    if (coord) {
        const trace::Array *_a_PGLfloat20_0 = (call.arg(0)).toArray();
    coord[0] = (*_a_PGLfloat20_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordfvEXT(coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoorddEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble coord;
    coord = (call.arg(0)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoorddEXT(coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoorddvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * coord;
    coord = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *coord));
    if (coord) {
        const trace::Array *_a_PGLdouble10_0 = (call.arg(0)).toArray();
    coord[0] = (*_a_PGLdouble10_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoorddvEXT(coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(2), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordPointerEXT(type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3bEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte tx;
    tx = (call.arg(0)).toSInt();

    GLbyte ty;
    ty = (call.arg(1)).toSInt();

    GLbyte tz;
    tz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3bEXT(tx, ty, tz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3bvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte12_0 = (call.arg(0)).toArray();
        for (size_t _jGLbyte12 = 0; _jGLbyte12 < _a_GLbyte12_0->values.size(); ++_jGLbyte12) {
    v[_jGLbyte12] = (*_a_GLbyte12_0->values[_jGLbyte12]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3bvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble tx;
    tx = (call.arg(0)).toDouble();

    GLdouble ty;
    ty = (call.arg(1)).toDouble();

    GLdouble tz;
    tz = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3dEXT(tx, ty, tz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble101_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble101 = 0; _jGLdouble101 < _a_GLdouble101_0->values.size(); ++_jGLdouble101) {
    v[_jGLdouble101] = (*_a_GLdouble101_0->values[_jGLdouble101]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3dvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3fEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat tx;
    tx = (call.arg(0)).toFloat();

    GLfloat ty;
    ty = (call.arg(1)).toFloat();

    GLfloat tz;
    tz = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3fEXT(tx, ty, tz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat189_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat189 = 0; _jGLfloat189 < _a_GLfloat189_0->values.size(); ++_jGLfloat189) {
    v[_jGLfloat189] = (*_a_GLfloat189_0->values[_jGLfloat189]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3fvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint tx;
    tx = (call.arg(0)).toSInt();

    GLint ty;
    ty = (call.arg(1)).toSInt();

    GLint tz;
    tz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3iEXT(tx, ty, tz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint187_0 = (call.arg(0)).toArray();
        for (size_t _jGLint187 = 0; _jGLint187 < _a_GLint187_0->values.size(); ++_jGLint187) {
    v[_jGLint187] = (*_a_GLint187_0->values[_jGLint187]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3ivEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3sEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort tx;
    tx = (call.arg(0)).toSInt();

    GLshort ty;
    ty = (call.arg(1)).toSInt();

    GLshort tz;
    tz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3sEXT(tx, ty, tz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangent3svEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort37_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort37 = 0; _jGLshort37 < _a_GLshort37_0->values.size(); ++_jGLshort37) {
    v[_jGLshort37] = (*_a_GLshort37_0->values[_jGLshort37]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangent3svEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3bEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte bx;
    bx = (call.arg(0)).toSInt();

    GLbyte by;
    by = (call.arg(1)).toSInt();

    GLbyte bz;
    bz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3bEXT(bx, by, bz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3bvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte13_0 = (call.arg(0)).toArray();
        for (size_t _jGLbyte13 = 0; _jGLbyte13 < _a_GLbyte13_0->values.size(); ++_jGLbyte13) {
    v[_jGLbyte13] = (*_a_GLbyte13_0->values[_jGLbyte13]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3bvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble bx;
    bx = (call.arg(0)).toDouble();

    GLdouble by;
    by = (call.arg(1)).toDouble();

    GLdouble bz;
    bz = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3dEXT(bx, by, bz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble102_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble102 = 0; _jGLdouble102 < _a_GLdouble102_0->values.size(); ++_jGLdouble102) {
    v[_jGLdouble102] = (*_a_GLdouble102_0->values[_jGLdouble102]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3dvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3fEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat bx;
    bx = (call.arg(0)).toFloat();

    GLfloat by;
    by = (call.arg(1)).toFloat();

    GLfloat bz;
    bz = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3fEXT(bx, by, bz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat190_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat190 = 0; _jGLfloat190 < _a_GLfloat190_0->values.size(); ++_jGLfloat190) {
    v[_jGLfloat190] = (*_a_GLfloat190_0->values[_jGLfloat190]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3fvEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint bx;
    bx = (call.arg(0)).toSInt();

    GLint by;
    by = (call.arg(1)).toSInt();

    GLint bz;
    bz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3iEXT(bx, by, bz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint188_0 = (call.arg(0)).toArray();
        for (size_t _jGLint188 = 0; _jGLint188 < _a_GLint188_0->values.size(); ++_jGLint188) {
    v[_jGLint188] = (*_a_GLint188_0->values[_jGLint188]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3ivEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3sEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort bx;
    bx = (call.arg(0)).toSInt();

    GLshort by;
    by = (call.arg(1)).toSInt();

    GLshort bz;
    bz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3sEXT(bx, by, bz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormal3svEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort38_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort38 = 0; _jGLshort38 < _a_GLshort38_0->values.size(); ++_jGLshort38) {
    v[_jGLshort38] = (*_a_GLshort38_0->values[_jGLshort38]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormal3svEXT(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTangentPointerEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTangentPointerEXT(type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBinormalPointerEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBinormalPointerEXT(type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFinishTextureSUNX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFinishTextureSUNX();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGlobalAlphaFactorbSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbyte factor;
    factor = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGlobalAlphaFactorbSUN(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGlobalAlphaFactorsSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort factor;
    factor = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGlobalAlphaFactorsSUN(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGlobalAlphaFactoriSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint factor;
    factor = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGlobalAlphaFactoriSUN(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGlobalAlphaFactorfSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat factor;
    factor = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGlobalAlphaFactorfSUN(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGlobalAlphaFactordSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble factor;
    factor = (call.arg(0)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGlobalAlphaFactordSUN(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGlobalAlphaFactorubSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte factor;
    factor = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGlobalAlphaFactorubSUN(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGlobalAlphaFactorusSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort factor;
    factor = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGlobalAlphaFactorusSUN(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGlobalAlphaFactoruiSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint factor;
    factor = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGlobalAlphaFactoruiSUN(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint code;
    code = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiSUN(code);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeusSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLushort code;
    code = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeusSUN(code);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeubSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte code;
    code = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeubSUN(code);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuivSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    const GLuint * code;
    memset(&code, 0, sizeof code); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuivSUN(code);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeusvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    const GLushort * code;
    memset(&code, 0, sizeof code); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeusvSUN(code);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeubvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    const GLubyte * code;
    memset(&code, 0, sizeof code); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeubvSUN(code);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodePointerSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodePointerSUN(type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4ubVertex2fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte r;
    r = (call.arg(0)).toUInt();

    GLubyte g;
    g = (call.arg(1)).toUInt();

    GLubyte b;
    b = (call.arg(2)).toUInt();

    GLubyte a;
    a = (call.arg(3)).toUInt();

    GLfloat x;
    x = (call.arg(4)).toFloat();

    GLfloat y;
    y = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4ubVertex2fSUN(r, g, b, a, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4ubVertex2fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * c;
    c = static_cast<GLubyte *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_GLubyte17_0 = (call.arg(0)).toArray();
        for (size_t _jGLubyte17 = 0; _jGLubyte17 < _a_GLubyte17_0->values.size(); ++_jGLubyte17) {
    c[_jGLubyte17] = (*_a_GLubyte17_0->values[_jGLubyte17]).toUInt();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat191_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat191 = 0; _jGLfloat191 < _a_GLfloat191_0->values.size(); ++_jGLfloat191) {
    v[_jGLfloat191] = (*_a_GLfloat191_0->values[_jGLfloat191]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4ubVertex2fvSUN(c, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4ubVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte r;
    r = (call.arg(0)).toUInt();

    GLubyte g;
    g = (call.arg(1)).toUInt();

    GLubyte b;
    b = (call.arg(2)).toUInt();

    GLubyte a;
    a = (call.arg(3)).toUInt();

    GLfloat x;
    x = (call.arg(4)).toFloat();

    GLfloat y;
    y = (call.arg(5)).toFloat();

    GLfloat z;
    z = (call.arg(6)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4ubVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLubyte * c;
    c = static_cast<GLubyte *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_GLubyte18_0 = (call.arg(0)).toArray();
        for (size_t _jGLubyte18 = 0; _jGLubyte18 < _a_GLubyte18_0->values.size(); ++_jGLubyte18) {
    c[_jGLubyte18] = (*_a_GLubyte18_0->values[_jGLubyte18]).toUInt();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat192_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat192 = 0; _jGLfloat192 < _a_GLfloat192_0->values.size(); ++_jGLfloat192) {
    v[_jGLfloat192] = (*_a_GLfloat192_0->values[_jGLfloat192]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4ubVertex3fvSUN(c, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat r;
    r = (call.arg(0)).toFloat();

    GLfloat g;
    g = (call.arg(1)).toFloat();

    GLfloat b;
    b = (call.arg(2)).toFloat();

    GLfloat x;
    x = (call.arg(3)).toFloat();

    GLfloat y;
    y = (call.arg(4)).toFloat();

    GLfloat z;
    z = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3fVertex3fSUN(r, g, b, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_GLfloat193_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat193 = 0; _jGLfloat193 < _a_GLfloat193_0->values.size(); ++_jGLfloat193) {
    c[_jGLfloat193] = (*_a_GLfloat193_0->values[_jGLfloat193]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat194_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat194 = 0; _jGLfloat194 < _a_GLfloat194_0->values.size(); ++_jGLfloat194) {
    v[_jGLfloat194] = (*_a_GLfloat194_0->values[_jGLfloat194]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3fVertex3fvSUN(c, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat nx;
    nx = (call.arg(0)).toFloat();

    GLfloat ny;
    ny = (call.arg(1)).toFloat();

    GLfloat nz;
    nz = (call.arg(2)).toFloat();

    GLfloat x;
    x = (call.arg(3)).toFloat();

    GLfloat y;
    y = (call.arg(4)).toFloat();

    GLfloat z;
    z = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat195_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat195 = 0; _jGLfloat195 < _a_GLfloat195_0->values.size(); ++_jGLfloat195) {
    n[_jGLfloat195] = (*_a_GLfloat195_0->values[_jGLfloat195]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat196_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat196 = 0; _jGLfloat196 < _a_GLfloat196_0->values.size(); ++_jGLfloat196) {
    v[_jGLfloat196] = (*_a_GLfloat196_0->values[_jGLfloat196]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3fVertex3fvSUN(n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4fNormal3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat r;
    r = (call.arg(0)).toFloat();

    GLfloat g;
    g = (call.arg(1)).toFloat();

    GLfloat b;
    b = (call.arg(2)).toFloat();

    GLfloat a;
    a = (call.arg(3)).toFloat();

    GLfloat nx;
    nx = (call.arg(4)).toFloat();

    GLfloat ny;
    ny = (call.arg(5)).toFloat();

    GLfloat nz;
    nz = (call.arg(6)).toFloat();

    GLfloat x;
    x = (call.arg(7)).toFloat();

    GLfloat y;
    y = (call.arg(8)).toFloat();

    GLfloat z;
    z = (call.arg(9)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4fNormal3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *c));
    if (c) {
        const trace::Array *_a_GLfloat197_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat197 = 0; _jGLfloat197 < _a_GLfloat197_0->values.size(); ++_jGLfloat197) {
    c[_jGLfloat197] = (*_a_GLfloat197_0->values[_jGLfloat197]).toFloat();
        }
    }

    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat198_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat198 = 0; _jGLfloat198 < _a_GLfloat198_0->values.size(); ++_jGLfloat198) {
    n[_jGLfloat198] = (*_a_GLfloat198_0->values[_jGLfloat198]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat199_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat199 = 0; _jGLfloat199 < _a_GLfloat199_0->values.size(); ++_jGLfloat199) {
    v[_jGLfloat199] = (*_a_GLfloat199_0->values[_jGLfloat199]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4fNormal3fVertex3fvSUN(c, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLfloat x;
    x = (call.arg(2)).toFloat();

    GLfloat y;
    y = (call.arg(3)).toFloat();

    GLfloat z;
    z = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fVertex3fSUN(s, t, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat200_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat200 = 0; _jGLfloat200 < _a_GLfloat200_0->values.size(); ++_jGLfloat200) {
    tc[_jGLfloat200] = (*_a_GLfloat200_0->values[_jGLfloat200]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat201_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat201 = 0; _jGLfloat201 < _a_GLfloat201_0->values.size(); ++_jGLfloat201) {
    v[_jGLfloat201] = (*_a_GLfloat201_0->values[_jGLfloat201]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fVertex3fvSUN(tc, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4fVertex4fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLfloat p;
    p = (call.arg(2)).toFloat();

    GLfloat q;
    q = (call.arg(3)).toFloat();

    GLfloat x;
    x = (call.arg(4)).toFloat();

    GLfloat y;
    y = (call.arg(5)).toFloat();

    GLfloat z;
    z = (call.arg(6)).toFloat();

    GLfloat w;
    w = (call.arg(7)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4fVertex4fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat202_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat202 = 0; _jGLfloat202 < _a_GLfloat202_0->values.size(); ++_jGLfloat202) {
    tc[_jGLfloat202] = (*_a_GLfloat202_0->values[_jGLfloat202]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat203_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat203 = 0; _jGLfloat203 < _a_GLfloat203_0->values.size(); ++_jGLfloat203) {
    v[_jGLfloat203] = (*_a_GLfloat203_0->values[_jGLfloat203]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4fVertex4fvSUN(tc, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fColor4ubVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLubyte r;
    r = (call.arg(2)).toUInt();

    GLubyte g;
    g = (call.arg(3)).toUInt();

    GLubyte b;
    b = (call.arg(4)).toUInt();

    GLubyte a;
    a = (call.arg(5)).toUInt();

    GLfloat x;
    x = (call.arg(6)).toFloat();

    GLfloat y;
    y = (call.arg(7)).toFloat();

    GLfloat z;
    z = (call.arg(8)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fColor4ubVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat204_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat204 = 0; _jGLfloat204 < _a_GLfloat204_0->values.size(); ++_jGLfloat204) {
    tc[_jGLfloat204] = (*_a_GLfloat204_0->values[_jGLfloat204]).toFloat();
        }
    }

    GLubyte * c;
    c = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *c));
    if (c) {
        const trace::Array *_a_GLubyte19_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte19 = 0; _jGLubyte19 < _a_GLubyte19_0->values.size(); ++_jGLubyte19) {
    c[_jGLubyte19] = (*_a_GLubyte19_0->values[_jGLubyte19]).toUInt();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat205_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat205 = 0; _jGLfloat205 < _a_GLfloat205_0->values.size(); ++_jGLfloat205) {
    v[_jGLfloat205] = (*_a_GLfloat205_0->values[_jGLfloat205]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fColor3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLfloat r;
    r = (call.arg(2)).toFloat();

    GLfloat g;
    g = (call.arg(3)).toFloat();

    GLfloat b;
    b = (call.arg(4)).toFloat();

    GLfloat x;
    x = (call.arg(5)).toFloat();

    GLfloat y;
    y = (call.arg(6)).toFloat();

    GLfloat z;
    z = (call.arg(7)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fColor3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat206_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat206 = 0; _jGLfloat206 < _a_GLfloat206_0->values.size(); ++_jGLfloat206) {
    tc[_jGLfloat206] = (*_a_GLfloat206_0->values[_jGLfloat206]).toFloat();
        }
    }

    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *c));
    if (c) {
        const trace::Array *_a_GLfloat207_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat207 = 0; _jGLfloat207 < _a_GLfloat207_0->values.size(); ++_jGLfloat207) {
    c[_jGLfloat207] = (*_a_GLfloat207_0->values[_jGLfloat207]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat208_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat208 = 0; _jGLfloat208 < _a_GLfloat208_0->values.size(); ++_jGLfloat208) {
    v[_jGLfloat208] = (*_a_GLfloat208_0->values[_jGLfloat208]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fNormal3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLfloat nx;
    nx = (call.arg(2)).toFloat();

    GLfloat ny;
    ny = (call.arg(3)).toFloat();

    GLfloat nz;
    nz = (call.arg(4)).toFloat();

    GLfloat x;
    x = (call.arg(5)).toFloat();

    GLfloat y;
    y = (call.arg(6)).toFloat();

    GLfloat z;
    z = (call.arg(7)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fNormal3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat209_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat209 = 0; _jGLfloat209 < _a_GLfloat209_0->values.size(); ++_jGLfloat209) {
    tc[_jGLfloat209] = (*_a_GLfloat209_0->values[_jGLfloat209]).toFloat();
        }
    }

    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat210_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat210 = 0; _jGLfloat210 < _a_GLfloat210_0->values.size(); ++_jGLfloat210) {
    n[_jGLfloat210] = (*_a_GLfloat210_0->values[_jGLfloat210]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat211_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat211 = 0; _jGLfloat211 < _a_GLfloat211_0->values.size(); ++_jGLfloat211) {
    v[_jGLfloat211] = (*_a_GLfloat211_0->values[_jGLfloat211]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fColor4fNormal3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLfloat r;
    r = (call.arg(2)).toFloat();

    GLfloat g;
    g = (call.arg(3)).toFloat();

    GLfloat b;
    b = (call.arg(4)).toFloat();

    GLfloat a;
    a = (call.arg(5)).toFloat();

    GLfloat nx;
    nx = (call.arg(6)).toFloat();

    GLfloat ny;
    ny = (call.arg(7)).toFloat();

    GLfloat nz;
    nz = (call.arg(8)).toFloat();

    GLfloat x;
    x = (call.arg(9)).toFloat();

    GLfloat y;
    y = (call.arg(10)).toFloat();

    GLfloat z;
    z = (call.arg(11)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2fColor4fNormal3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat212_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat212 = 0; _jGLfloat212 < _a_GLfloat212_0->values.size(); ++_jGLfloat212) {
    tc[_jGLfloat212] = (*_a_GLfloat212_0->values[_jGLfloat212]).toFloat();
        }
    }

    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *c));
    if (c) {
        const trace::Array *_a_GLfloat213_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat213 = 0; _jGLfloat213 < _a_GLfloat213_0->values.size(); ++_jGLfloat213) {
    c[_jGLfloat213] = (*_a_GLfloat213_0->values[_jGLfloat213]).toFloat();
        }
    }

    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat214_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat214 = 0; _jGLfloat214 < _a_GLfloat214_0->values.size(); ++_jGLfloat214) {
    n[_jGLfloat214] = (*_a_GLfloat214_0->values[_jGLfloat214]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat215_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat215 = 0; _jGLfloat215 < _a_GLfloat215_0->values.size(); ++_jGLfloat215) {
    v[_jGLfloat215] = (*_a_GLfloat215_0->values[_jGLfloat215]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4fColor4fNormal3fVertex4fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat s;
    s = (call.arg(0)).toFloat();

    GLfloat t;
    t = (call.arg(1)).toFloat();

    GLfloat p;
    p = (call.arg(2)).toFloat();

    GLfloat q;
    q = (call.arg(3)).toFloat();

    GLfloat r;
    r = (call.arg(4)).toFloat();

    GLfloat g;
    g = (call.arg(5)).toFloat();

    GLfloat b;
    b = (call.arg(6)).toFloat();

    GLfloat a;
    a = (call.arg(7)).toFloat();

    GLfloat nx;
    nx = (call.arg(8)).toFloat();

    GLfloat ny;
    ny = (call.arg(9)).toFloat();

    GLfloat nz;
    nz = (call.arg(10)).toFloat();

    GLfloat x;
    x = (call.arg(11)).toFloat();

    GLfloat y;
    y = (call.arg(12)).toFloat();

    GLfloat z;
    z = (call.arg(13)).toFloat();

    GLfloat w;
    w = (call.arg(14)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4fColor4fNormal3fVertex4fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat216_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat216 = 0; _jGLfloat216 < _a_GLfloat216_0->values.size(); ++_jGLfloat216) {
    tc[_jGLfloat216] = (*_a_GLfloat216_0->values[_jGLfloat216]).toFloat();
        }
    }

    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *c));
    if (c) {
        const trace::Array *_a_GLfloat217_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat217 = 0; _jGLfloat217 < _a_GLfloat217_0->values.size(); ++_jGLfloat217) {
    c[_jGLfloat217] = (*_a_GLfloat217_0->values[_jGLfloat217]).toFloat();
        }
    }

    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat218_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat218 = 0; _jGLfloat218 < _a_GLfloat218_0->values.size(); ++_jGLfloat218) {
    n[_jGLfloat218] = (*_a_GLfloat218_0->values[_jGLfloat218]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat219_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat219 = 0; _jGLfloat219 < _a_GLfloat219_0->values.size(); ++_jGLfloat219) {
    v[_jGLfloat219] = (*_a_GLfloat219_0->values[_jGLfloat219]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint rc;
    rc = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiVertex3fSUN(rc, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * rc;
    rc = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *rc));
    if (rc) {
        const trace::Array *_a_PGLuint47_0 = (call.arg(0)).toArray();
    rc[0] = (*_a_PGLuint47_0->values[0]).toUInt();
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat220_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat220 = 0; _jGLfloat220 < _a_GLfloat220_0->values.size(); ++_jGLfloat220) {
    v[_jGLfloat220] = (*_a_GLfloat220_0->values[_jGLfloat220]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiVertex3fvSUN(rc, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiColor4ubVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint rc;
    rc = (call.arg(0)).toUInt();

    GLubyte r;
    r = (call.arg(1)).toUInt();

    GLubyte g;
    g = (call.arg(2)).toUInt();

    GLubyte b;
    b = (call.arg(3)).toUInt();

    GLubyte a;
    a = (call.arg(4)).toUInt();

    GLfloat x;
    x = (call.arg(5)).toFloat();

    GLfloat y;
    y = (call.arg(6)).toFloat();

    GLfloat z;
    z = (call.arg(7)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiColor4ubVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * rc;
    rc = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *rc));
    if (rc) {
        const trace::Array *_a_PGLuint48_0 = (call.arg(0)).toArray();
    rc[0] = (*_a_PGLuint48_0->values[0]).toUInt();
    }

    GLubyte * c;
    c = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *c));
    if (c) {
        const trace::Array *_a_GLubyte20_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte20 = 0; _jGLubyte20 < _a_GLubyte20_0->values.size(); ++_jGLubyte20) {
    c[_jGLubyte20] = (*_a_GLubyte20_0->values[_jGLubyte20]).toUInt();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat221_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat221 = 0; _jGLfloat221 < _a_GLfloat221_0->values.size(); ++_jGLfloat221) {
    v[_jGLfloat221] = (*_a_GLfloat221_0->values[_jGLfloat221]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiColor3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint rc;
    rc = (call.arg(0)).toUInt();

    GLfloat r;
    r = (call.arg(1)).toFloat();

    GLfloat g;
    g = (call.arg(2)).toFloat();

    GLfloat b;
    b = (call.arg(3)).toFloat();

    GLfloat x;
    x = (call.arg(4)).toFloat();

    GLfloat y;
    y = (call.arg(5)).toFloat();

    GLfloat z;
    z = (call.arg(6)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiColor3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * rc;
    rc = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *rc));
    if (rc) {
        const trace::Array *_a_PGLuint49_0 = (call.arg(0)).toArray();
    rc[0] = (*_a_PGLuint49_0->values[0]).toUInt();
    }

    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *c));
    if (c) {
        const trace::Array *_a_GLfloat222_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat222 = 0; _jGLfloat222 < _a_GLfloat222_0->values.size(); ++_jGLfloat222) {
    c[_jGLfloat222] = (*_a_GLfloat222_0->values[_jGLfloat222]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat223_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat223 = 0; _jGLfloat223 < _a_GLfloat223_0->values.size(); ++_jGLfloat223) {
    v[_jGLfloat223] = (*_a_GLfloat223_0->values[_jGLfloat223]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiNormal3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint rc;
    rc = (call.arg(0)).toUInt();

    GLfloat nx;
    nx = (call.arg(1)).toFloat();

    GLfloat ny;
    ny = (call.arg(2)).toFloat();

    GLfloat nz;
    nz = (call.arg(3)).toFloat();

    GLfloat x;
    x = (call.arg(4)).toFloat();

    GLfloat y;
    y = (call.arg(5)).toFloat();

    GLfloat z;
    z = (call.arg(6)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiNormal3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * rc;
    rc = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *rc));
    if (rc) {
        const trace::Array *_a_PGLuint50_0 = (call.arg(0)).toArray();
    rc[0] = (*_a_PGLuint50_0->values[0]).toUInt();
    }

    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat224_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat224 = 0; _jGLfloat224 < _a_GLfloat224_0->values.size(); ++_jGLfloat224) {
    n[_jGLfloat224] = (*_a_GLfloat224_0->values[_jGLfloat224]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat225_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat225 = 0; _jGLfloat225 < _a_GLfloat225_0->values.size(); ++_jGLfloat225) {
    v[_jGLfloat225] = (*_a_GLfloat225_0->values[_jGLfloat225]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiColor4fNormal3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint rc;
    rc = (call.arg(0)).toUInt();

    GLfloat r;
    r = (call.arg(1)).toFloat();

    GLfloat g;
    g = (call.arg(2)).toFloat();

    GLfloat b;
    b = (call.arg(3)).toFloat();

    GLfloat a;
    a = (call.arg(4)).toFloat();

    GLfloat nx;
    nx = (call.arg(5)).toFloat();

    GLfloat ny;
    ny = (call.arg(6)).toFloat();

    GLfloat nz;
    nz = (call.arg(7)).toFloat();

    GLfloat x;
    x = (call.arg(8)).toFloat();

    GLfloat y;
    y = (call.arg(9)).toFloat();

    GLfloat z;
    z = (call.arg(10)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * rc;
    rc = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *rc));
    if (rc) {
        const trace::Array *_a_PGLuint51_0 = (call.arg(0)).toArray();
    rc[0] = (*_a_PGLuint51_0->values[0]).toUInt();
    }

    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *c));
    if (c) {
        const trace::Array *_a_GLfloat226_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat226 = 0; _jGLfloat226 < _a_GLfloat226_0->values.size(); ++_jGLfloat226) {
    c[_jGLfloat226] = (*_a_GLfloat226_0->values[_jGLfloat226]).toFloat();
        }
    }

    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat227_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat227 = 0; _jGLfloat227 < _a_GLfloat227_0->values.size(); ++_jGLfloat227) {
    n[_jGLfloat227] = (*_a_GLfloat227_0->values[_jGLfloat227]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat228_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat228 = 0; _jGLfloat228 < _a_GLfloat228_0->values.size(); ++_jGLfloat228) {
    v[_jGLfloat228] = (*_a_GLfloat228_0->values[_jGLfloat228]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiTexCoord2fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint rc;
    rc = (call.arg(0)).toUInt();

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    GLfloat x;
    x = (call.arg(3)).toFloat();

    GLfloat y;
    y = (call.arg(4)).toFloat();

    GLfloat z;
    z = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiTexCoord2fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * rc;
    rc = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *rc));
    if (rc) {
        const trace::Array *_a_PGLuint52_0 = (call.arg(0)).toArray();
    rc[0] = (*_a_PGLuint52_0->values[0]).toUInt();
    }

    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat229_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat229 = 0; _jGLfloat229 < _a_GLfloat229_0->values.size(); ++_jGLfloat229) {
    tc[_jGLfloat229] = (*_a_GLfloat229_0->values[_jGLfloat229]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat230_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat230 = 0; _jGLfloat230 < _a_GLfloat230_0->values.size(); ++_jGLfloat230) {
    v[_jGLfloat230] = (*_a_GLfloat230_0->values[_jGLfloat230]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint rc;
    rc = (call.arg(0)).toUInt();

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    GLfloat nx;
    nx = (call.arg(3)).toFloat();

    GLfloat ny;
    ny = (call.arg(4)).toFloat();

    GLfloat nz;
    nz = (call.arg(5)).toFloat();

    GLfloat x;
    x = (call.arg(6)).toFloat();

    GLfloat y;
    y = (call.arg(7)).toFloat();

    GLfloat z;
    z = (call.arg(8)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * rc;
    rc = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *rc));
    if (rc) {
        const trace::Array *_a_PGLuint53_0 = (call.arg(0)).toArray();
    rc[0] = (*_a_PGLuint53_0->values[0]).toUInt();
    }

    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat231_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat231 = 0; _jGLfloat231 < _a_GLfloat231_0->values.size(); ++_jGLfloat231) {
    tc[_jGLfloat231] = (*_a_GLfloat231_0->values[_jGLfloat231]).toFloat();
        }
    }

    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat232_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat232 = 0; _jGLfloat232 < _a_GLfloat232_0->values.size(); ++_jGLfloat232) {
    n[_jGLfloat232] = (*_a_GLfloat232_0->values[_jGLfloat232]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat233_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat233 = 0; _jGLfloat233 < _a_GLfloat233_0->values.size(); ++_jGLfloat233) {
    v[_jGLfloat233] = (*_a_GLfloat233_0->values[_jGLfloat233]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint rc;
    rc = (call.arg(0)).toUInt();

    GLfloat s;
    s = (call.arg(1)).toFloat();

    GLfloat t;
    t = (call.arg(2)).toFloat();

    GLfloat r;
    r = (call.arg(3)).toFloat();

    GLfloat g;
    g = (call.arg(4)).toFloat();

    GLfloat b;
    b = (call.arg(5)).toFloat();

    GLfloat a;
    a = (call.arg(6)).toFloat();

    GLfloat nx;
    nx = (call.arg(7)).toFloat();

    GLfloat ny;
    ny = (call.arg(8)).toFloat();

    GLfloat nz;
    nz = (call.arg(9)).toFloat();

    GLfloat x;
    x = (call.arg(10)).toFloat();

    GLfloat y;
    y = (call.arg(11)).toFloat();

    GLfloat z;
    z = (call.arg(12)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint * rc;
    rc = static_cast<GLuint *>(_allocator.alloc(&call.arg(0), sizeof *rc));
    if (rc) {
        const trace::Array *_a_PGLuint54_0 = (call.arg(0)).toArray();
    rc[0] = (*_a_PGLuint54_0->values[0]).toUInt();
    }

    GLfloat * tc;
    tc = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *tc));
    if (tc) {
        const trace::Array *_a_GLfloat234_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat234 = 0; _jGLfloat234 < _a_GLfloat234_0->values.size(); ++_jGLfloat234) {
    tc[_jGLfloat234] = (*_a_GLfloat234_0->values[_jGLfloat234]).toFloat();
        }
    }

    GLfloat * c;
    c = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *c));
    if (c) {
        const trace::Array *_a_GLfloat235_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat235 = 0; _jGLfloat235 < _a_GLfloat235_0->values.size(); ++_jGLfloat235) {
    c[_jGLfloat235] = (*_a_GLfloat235_0->values[_jGLfloat235]).toFloat();
        }
    }

    GLfloat * n;
    n = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *n));
    if (n) {
        const trace::Array *_a_GLfloat236_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat236 = 0; _jGLfloat236 < _a_GLfloat236_0->values.size(); ++_jGLfloat236) {
    n[_jGLfloat236] = (*_a_GLfloat236_0->values[_jGLfloat236]).toFloat();
        }
    }

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat237_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat237 = 0; _jGLfloat237 < _a_GLfloat237_0->values.size(); ++_jGLfloat237) {
    v[_jGLfloat237] = (*_a_GLfloat237_0->values[_jGLfloat237]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFuncSeparateEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum sfactorRGB;
    sfactorRGB = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum dfactorRGB;
    dfactorRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum sfactorAlpha;
    sfactorAlpha = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum dfactorAlpha;
    dfactorAlpha = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFuncSeparateINGR(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum sfactorRGB;
    sfactorRGB = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum dfactorRGB;
    dfactorRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum sfactorAlpha;
    sfactorAlpha = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum dfactorAlpha;
    dfactorAlpha = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexWeightfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat weight;
    weight = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexWeightfEXT(weight);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexWeightfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * weight;
    weight = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *weight));
    if (weight) {
        const trace::Array *_a_PGLfloat21_0 = (call.arg(0)).toArray();
    weight[0] = (*_a_PGLfloat21_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexWeightfvEXT(weight);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexWeightPointerEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexWeightPointerEXT(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFlushVertexArrayRangeNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlushVertexArrayRangeNV();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayRangeNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei length;
    length = (call.arg(0)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayRangeNV(length, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCombinerParameterfvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat238_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat238 = 0; _jGLfloat238 < _a_GLfloat238_0->values.size(); ++_jGLfloat238) {
    params[_jGLfloat238] = (*_a_GLfloat238_0->values[_jGLfloat238]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCombinerParameterfvNV(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCombinerParameterfNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCombinerParameterfNV(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCombinerParameterivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint189_0 = (call.arg(1)).toArray();
        for (size_t _jGLint189 = 0; _jGLint189 < _a_GLint189_0->values.size(); ++_jGLint189) {
    params[_jGLint189] = (*_a_GLint189_0->values[_jGLint189]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCombinerParameterivNV(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCombinerParameteriNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCombinerParameteriNV(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCombinerInputNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stage;
    stage = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum portion;
    portion = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum variable;
    variable = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum input;
    input = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum mapping;
    mapping = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum componentUsage;
    componentUsage = static_cast<GLenum>((call.arg(5)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCombinerOutputNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stage;
    stage = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum portion;
    portion = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum abOutput;
    abOutput = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum cdOutput;
    cdOutput = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum sumOutput;
    sumOutput = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum scale;
    scale = static_cast<GLenum>((call.arg(5)).toSInt());

    GLenum bias;
    bias = static_cast<GLenum>((call.arg(6)).toSInt());

    GLboolean abDotProduct;
    abDotProduct = static_cast<GLboolean>((call.arg(7)).toSInt());

    GLboolean cdDotProduct;
    cdDotProduct = static_cast<GLboolean>((call.arg(8)).toSInt());

    GLboolean muxSum;
    muxSum = static_cast<GLboolean>((call.arg(9)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFinalCombinerInputNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum variable;
    variable = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum input;
    input = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum mapping;
    mapping = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum componentUsage;
    componentUsage = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFinalCombinerInputNV(variable, input, mapping, componentUsage);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenPathsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei range;
    range = (call.arg(0)).toSInt();

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGenPathsNV(range);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeletePathsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLsizei range;
    range = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeletePathsNV(path, range);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIsPathNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLboolean _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glIsPathNV(path);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathCommandsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLsizei numCommands;
    numCommands = (call.arg(1)).toSInt();

    GLubyte * commands;
    commands = static_cast<GLubyte *>(_allocator.alloc(&call.arg(2), sizeof *commands));
    if (commands) {
        const trace::Array *_a_GLubyte21_0 = (call.arg(2)).toArray();
        for (size_t _jGLubyte21 = 0; _jGLubyte21 < _a_GLubyte21_0->values.size(); ++_jGLubyte21) {
    commands[_jGLubyte21] = (*_a_GLubyte21_0->values[_jGLubyte21]).toUInt();
        }
    }

    GLsizei numCoords;
    numCoords = (call.arg(3)).toSInt();

    GLenum coordType;
    coordType = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * coord;
    coord = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coord);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathCoordsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLsizei numCoords;
    numCoords = (call.arg(1)).toSInt();

    GLenum coordType;
    coordType = static_cast<GLenum>((call.arg(2)).toSInt());

    GLvoid * coords;
    coords = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathCoordsNV(path, numCoords, coordType, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathSubCommandsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLsizei commandStart;
    commandStart = (call.arg(1)).toSInt();

    GLsizei commandsToDelete;
    commandsToDelete = (call.arg(2)).toSInt();

    GLsizei numCommands;
    numCommands = (call.arg(3)).toSInt();

    GLubyte * commands;
    commands = static_cast<GLubyte *>(_allocator.alloc(&call.arg(4), sizeof *commands));
    if (commands) {
        const trace::Array *_a_GLubyte22_0 = (call.arg(4)).toArray();
        for (size_t _jGLubyte22 = 0; _jGLubyte22 < _a_GLubyte22_0->values.size(); ++_jGLubyte22) {
    commands[_jGLubyte22] = (*_a_GLubyte22_0->values[_jGLubyte22]).toUInt();
        }
    }

    GLsizei numCoords;
    numCoords = (call.arg(5)).toSInt();

    GLenum coordType;
    coordType = static_cast<GLenum>((call.arg(6)).toSInt());

    GLvoid * coords;
    coords = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathSubCoordsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLsizei coordStart;
    coordStart = (call.arg(1)).toSInt();

    GLsizei numCoords;
    numCoords = (call.arg(2)).toSInt();

    GLenum coordType;
    coordType = static_cast<GLenum>((call.arg(3)).toSInt());

    GLvoid * coords;
    coords = static_cast<GLvoid *>((call.arg(4)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathStringNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei length;
    length = (call.arg(2)).toSInt();

    GLvoid * pathString;
    pathString = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathStringNV(path, format, length, pathString);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathGlyphsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint firstPathName;
    firstPathName = (call.arg(0)).toUInt();

    GLenum fontTarget;
    fontTarget = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * fontName;
    fontName = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLbitfield fontStyle;
    fontStyle = (call.arg(3)).toUInt();

    GLsizei numGlyphs;
    numGlyphs = (call.arg(4)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(5)).toSInt());

    GLvoid * charcodes;
    charcodes = static_cast<GLvoid *>((call.arg(6)).toPointer());

    GLenum handleMissingGlyphs;
    handleMissingGlyphs = static_cast<GLenum>((call.arg(7)).toSInt());

    GLuint pathParameterTemplate;
    pathParameterTemplate = (call.arg(8)).toUInt();

    GLfloat emScale;
    emScale = (call.arg(9)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathGlyphRangeNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint firstPathName;
    firstPathName = (call.arg(0)).toUInt();

    GLenum fontTarget;
    fontTarget = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * fontName;
    fontName = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLbitfield fontStyle;
    fontStyle = (call.arg(3)).toUInt();

    GLuint firstGlyph;
    firstGlyph = (call.arg(4)).toUInt();

    GLsizei numGlyphs;
    numGlyphs = (call.arg(5)).toSInt();

    GLenum handleMissingGlyphs;
    handleMissingGlyphs = static_cast<GLenum>((call.arg(6)).toSInt());

    GLuint pathParameterTemplate;
    pathParameterTemplate = (call.arg(7)).toUInt();

    GLfloat emScale;
    emScale = (call.arg(8)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightPathsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint resultPath;
    resultPath = (call.arg(0)).toUInt();

    GLsizei numPaths;
    numPaths = (call.arg(1)).toSInt();

    GLuint * paths;
    paths = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *paths));
    if (paths) {
        const trace::Array *_a_GLuint140_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint140 = 0; _jGLuint140 < _a_GLuint140_0->values.size(); ++_jGLuint140) {
    paths[_jGLuint140] = (*_a_GLuint140_0->values[_jGLuint140]).toUInt();
        }
    }

    GLfloat * weights;
    weights = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *weights));
    if (weights) {
        const trace::Array *_a_GLfloat239_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat239 = 0; _jGLfloat239 < _a_GLfloat239_0->values.size(); ++_jGLfloat239) {
    weights[_jGLfloat239] = (*_a_GLfloat239_0->values[_jGLfloat239]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightPathsNV(resultPath, numPaths, paths, weights);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyPathNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint resultPath;
    resultPath = (call.arg(0)).toUInt();

    GLuint srcPath;
    srcPath = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyPathNV(resultPath, srcPath);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInterpolatePathsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint resultPath;
    resultPath = (call.arg(0)).toUInt();

    GLuint pathA;
    pathA = (call.arg(1)).toUInt();

    GLuint pathB;
    pathB = (call.arg(2)).toUInt();

    GLfloat weight;
    weight = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInterpolatePathsNV(resultPath, pathA, pathB, weight);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTransformPathNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint resultPath;
    resultPath = (call.arg(0)).toUInt();

    GLuint srcPath;
    srcPath = (call.arg(1)).toUInt();

    GLenum transformType;
    transformType = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat * transformValues;
    transformValues = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *transformValues));
    if (transformValues) {
        const trace::Array *_a_GLfloat240_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat240 = 0; _jGLfloat240 < _a_GLfloat240_0->values.size(); ++_jGLfloat240) {
    transformValues[_jGLfloat240] = (*_a_GLfloat240_0->values[_jGLfloat240]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTransformPathNV(resultPath, srcPath, transformType, transformValues);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathParameterivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint190_0 = (call.arg(2)).toArray();
        for (size_t _jGLint190 = 0; _jGLint190 < _a_GLint190_0->values.size(); ++_jGLint190) {
    value[_jGLint190] = (*_a_GLint190_0->values[_jGLint190]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathParameterivNV(path, pname, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathParameteriNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint value;
    value = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathParameteriNV(path, pname, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathParameterfvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat241_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat241 = 0; _jGLfloat241 < _a_GLfloat241_0->values.size(); ++_jGLfloat241) {
    value[_jGLfloat241] = (*_a_GLfloat241_0->values[_jGLfloat241]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathParameterfvNV(path, pname, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathParameterfNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat value;
    value = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathParameterfNV(path, pname, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathDashArrayNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLsizei dashCount;
    dashCount = (call.arg(1)).toSInt();

    GLfloat * dashArray;
    dashArray = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *dashArray));
    if (dashArray) {
        const trace::Array *_a_GLfloat242_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat242 = 0; _jGLfloat242 < _a_GLfloat242_0->values.size(); ++_jGLfloat242) {
    dashArray[_jGLfloat242] = (*_a_GLfloat242_0->values[_jGLfloat242]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathDashArrayNV(path, dashCount, dashArray);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathStencilFuncNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum func;
    func = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint ref;
    ref = (call.arg(1)).toSInt();

    GLuint mask;
    mask = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathStencilFuncNV(func, ref, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathStencilDepthOffsetNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat factor;
    factor = (call.arg(0)).toFloat();

    GLfloat units;
    units = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathStencilDepthOffsetNV(factor, units);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilFillPathNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLenum fillMode;
    fillMode = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint mask;
    mask = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilFillPathNV(path, fillMode, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilStrokePathNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLint reference;
    reference = (call.arg(1)).toSInt();

    GLuint mask;
    mask = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilStrokePathNV(path, reference, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilFillPathInstancedNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei numPaths;
    numPaths = (call.arg(0)).toSInt();

    GLenum pathNameType;
    pathNameType = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * paths;
    paths = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLuint pathBase;
    pathBase = (call.arg(3)).toUInt();

    GLenum fillMode;
    fillMode = static_cast<GLenum>((call.arg(4)).toSInt());

    GLuint mask;
    mask = (call.arg(5)).toUInt();

    GLenum transformType;
    transformType = static_cast<GLenum>((call.arg(6)).toSInt());

    GLfloat * transformValues;
    transformValues = static_cast<GLfloat *>(_allocator.alloc(&call.arg(7), sizeof *transformValues));
    if (transformValues) {
        const trace::Array *_a_GLfloat243_0 = (call.arg(7)).toArray();
        for (size_t _jGLfloat243 = 0; _jGLfloat243 < _a_GLfloat243_0->values.size(); ++_jGLfloat243) {
    transformValues[_jGLfloat243] = (*_a_GLfloat243_0->values[_jGLfloat243]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilStrokePathInstancedNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei numPaths;
    numPaths = (call.arg(0)).toSInt();

    GLenum pathNameType;
    pathNameType = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * paths;
    paths = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLuint pathBase;
    pathBase = (call.arg(3)).toUInt();

    GLint reference;
    reference = (call.arg(4)).toSInt();

    GLuint mask;
    mask = (call.arg(5)).toUInt();

    GLenum transformType;
    transformType = static_cast<GLenum>((call.arg(6)).toSInt());

    GLfloat * transformValues;
    transformValues = static_cast<GLfloat *>(_allocator.alloc(&call.arg(7), sizeof *transformValues));
    if (transformValues) {
        const trace::Array *_a_GLfloat244_0 = (call.arg(7)).toArray();
        for (size_t _jGLfloat244 = 0; _jGLfloat244 < _a_GLfloat244_0->values.size(); ++_jGLfloat244) {
    transformValues[_jGLfloat244] = (*_a_GLfloat244_0->values[_jGLfloat244]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathCoverDepthFuncNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum func;
    func = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathCoverDepthFuncNV(func);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathColorGenNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum color;
    color = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum genMode;
    genMode = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum colorFormat;
    colorFormat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat * coeffs;
    coeffs = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *coeffs));
    if (coeffs) {
        const trace::Array *_a_GLfloat245_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat245 = 0; _jGLfloat245 < _a_GLfloat245_0->values.size(); ++_jGLfloat245) {
    coeffs[_jGLfloat245] = (*_a_GLfloat245_0->values[_jGLfloat245]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathColorGenNV(color, genMode, colorFormat, coeffs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathTexGenNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texCoordSet;
    texCoordSet = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum genMode;
    genMode = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint components;
    components = (call.arg(2)).toSInt();

    GLfloat * coeffs;
    coeffs = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *coeffs));
    if (coeffs) {
        const trace::Array *_a_GLfloat246_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat246 = 0; _jGLfloat246 < _a_GLfloat246_0->values.size(); ++_jGLfloat246) {
    coeffs[_jGLfloat246] = (*_a_GLfloat246_0->values[_jGLfloat246]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathTexGenNV(texCoordSet, genMode, components, coeffs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPathFogGenNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum genMode;
    genMode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPathFogGenNV(genMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCoverFillPathNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLenum coverMode;
    coverMode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCoverFillPathNV(path, coverMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCoverStrokePathNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLenum coverMode;
    coverMode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCoverStrokePathNV(path, coverMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCoverFillPathInstancedNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei numPaths;
    numPaths = (call.arg(0)).toSInt();

    GLenum pathNameType;
    pathNameType = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * paths;
    paths = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLuint pathBase;
    pathBase = (call.arg(3)).toUInt();

    GLenum coverMode;
    coverMode = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum transformType;
    transformType = static_cast<GLenum>((call.arg(5)).toSInt());

    GLfloat * transformValues;
    transformValues = static_cast<GLfloat *>(_allocator.alloc(&call.arg(6), sizeof *transformValues));
    if (transformValues) {
        const trace::Array *_a_GLfloat247_0 = (call.arg(6)).toArray();
        for (size_t _jGLfloat247 = 0; _jGLfloat247 < _a_GLfloat247_0->values.size(); ++_jGLfloat247) {
    transformValues[_jGLfloat247] = (*_a_GLfloat247_0->values[_jGLfloat247]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCoverStrokePathInstancedNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei numPaths;
    numPaths = (call.arg(0)).toSInt();

    GLenum pathNameType;
    pathNameType = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * paths;
    paths = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLuint pathBase;
    pathBase = (call.arg(3)).toUInt();

    GLenum coverMode;
    coverMode = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum transformType;
    transformType = static_cast<GLenum>((call.arg(5)).toSInt());

    GLfloat * transformValues;
    transformValues = static_cast<GLfloat *>(_allocator.alloc(&call.arg(6), sizeof *transformValues));
    if (transformValues) {
        const trace::Array *_a_GLfloat248_0 = (call.arg(6)).toArray();
        for (size_t _jGLfloat248 = 0; _jGLfloat248 < _a_GLfloat248_0->values.size(); ++_jGLfloat248) {
    transformValues[_jGLfloat248] = (*_a_GLfloat248_0->values[_jGLfloat248]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetPathSpacingNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pathListMode;
    pathListMode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei numPaths;
    numPaths = (call.arg(1)).toSInt();

    GLenum pathNameType;
    pathNameType = static_cast<GLenum>((call.arg(2)).toSInt());

    GLvoid * paths;
    paths = static_cast<GLvoid *>((call.arg(3)).toPointer());

    GLuint pathBase;
    pathBase = (call.arg(4)).toUInt();

    GLfloat advanceScale;
    advanceScale = (call.arg(5)).toFloat();

    GLfloat kerningScale;
    kerningScale = (call.arg(6)).toFloat();

    GLenum transformType;
    transformType = static_cast<GLenum>((call.arg(7)).toSInt());

    GLfloat * returnedSpacing;
    returnedSpacing = static_cast<GLfloat *>(_allocator.alloc(&call.arg(8), sizeof *returnedSpacing));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLfloat250 = (call.arg(8)).toArray();
    if (_aGLfloat250) {
        for (size_t _jGLfloat250 = 0; _jGLfloat250 < _aGLfloat250->values.size(); ++_jGLfloat250) {
        }
    }
}

static void retrace_glGetPathLengthNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint path;
    path = (call.arg(0)).toUInt();

    GLsizei startSegment;
    startSegment = (call.arg(1)).toSInt();

    GLsizei numSegments;
    numSegments = (call.arg(2)).toSInt();

    GLfloat _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetPathLengthNV(path, startSegment, numSegments);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glResizeBuffersMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glResizeBuffersMESA();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2dMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2dMESA(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2dvMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble103_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble103 = 0; _jGLdouble103 < _a_GLdouble103_0->values.size(); ++_jGLdouble103) {
    v[_jGLdouble103] = (*_a_GLdouble103_0->values[_jGLdouble103]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2dvMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2fMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2fMESA(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2fvMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat251_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat251 = 0; _jGLfloat251 < _a_GLfloat251_0->values.size(); ++_jGLfloat251) {
    v[_jGLfloat251] = (*_a_GLfloat251_0->values[_jGLfloat251]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2fvMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2iMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2iMESA(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2ivMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint191_0 = (call.arg(0)).toArray();
        for (size_t _jGLint191 = 0; _jGLint191 < _a_GLint191_0->values.size(); ++_jGLint191) {
    v[_jGLint191] = (*_a_GLint191_0->values[_jGLint191]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2ivMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2sMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2sMESA(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos2svMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort39_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort39 = 0; _jGLshort39 < _a_GLshort39_0->values.size(); ++_jGLshort39) {
    v[_jGLshort39] = (*_a_GLshort39_0->values[_jGLshort39]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos2svMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3dMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3dMESA(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3dvMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble104_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble104 = 0; _jGLdouble104 < _a_GLdouble104_0->values.size(); ++_jGLdouble104) {
    v[_jGLdouble104] = (*_a_GLdouble104_0->values[_jGLdouble104]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3dvMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3fMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3fMESA(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3fvMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat252_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat252 = 0; _jGLfloat252 < _a_GLfloat252_0->values.size(); ++_jGLfloat252) {
    v[_jGLfloat252] = (*_a_GLfloat252_0->values[_jGLfloat252]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3fvMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3iMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3iMESA(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3ivMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint192_0 = (call.arg(0)).toArray();
        for (size_t _jGLint192 = 0; _jGLint192 < _a_GLint192_0->values.size(); ++_jGLint192) {
    v[_jGLint192] = (*_a_GLint192_0->values[_jGLint192]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3ivMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3sMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3sMESA(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos3svMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort40_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort40 = 0; _jGLshort40 < _a_GLshort40_0->values.size(); ++_jGLshort40) {
    v[_jGLshort40] = (*_a_GLshort40_0->values[_jGLshort40]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos3svMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos4dMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble x;
    x = (call.arg(0)).toDouble();

    GLdouble y;
    y = (call.arg(1)).toDouble();

    GLdouble z;
    z = (call.arg(2)).toDouble();

    GLdouble w;
    w = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos4dMESA(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos4dvMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble105_0 = (call.arg(0)).toArray();
        for (size_t _jGLdouble105 = 0; _jGLdouble105 < _a_GLdouble105_0->values.size(); ++_jGLdouble105) {
    v[_jGLdouble105] = (*_a_GLdouble105_0->values[_jGLdouble105]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos4dvMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos4fMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    GLfloat w;
    w = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos4fMESA(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos4fvMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat253_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat253 = 0; _jGLfloat253 < _a_GLfloat253_0->values.size(); ++_jGLfloat253) {
    v[_jGLfloat253] = (*_a_GLfloat253_0->values[_jGLfloat253]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos4fvMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos4iMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    GLint w;
    w = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos4iMESA(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos4ivMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint193_0 = (call.arg(0)).toArray();
        for (size_t _jGLint193 = 0; _jGLint193 < _a_GLint193_0->values.size(); ++_jGLint193) {
    v[_jGLint193] = (*_a_GLint193_0->values[_jGLint193]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos4ivMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos4sMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    GLshort w;
    w = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos4sMESA(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWindowPos4svMESA(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort41_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort41 = 0; _jGLshort41 < _a_GLshort41_0->values.size(); ++_jGLshort41) {
    v[_jGLshort41] = (*_a_GLshort41_0->values[_jGLshort41]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWindowPos4svMESA(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiModeDrawArraysIBM(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum * mode;
    mode = static_cast<GLenum *>(_allocator.alloc(&call.arg(0), sizeof *mode));
    if (mode) {
        const trace::Array *_a_GLenum14_0 = (call.arg(0)).toArray();
        for (size_t _jGLenum14 = 0; _jGLenum14 < _a_GLenum14_0->values.size(); ++_jGLenum14) {
    mode[_jGLenum14] = static_cast<GLenum>((*_a_GLenum14_0->values[_jGLenum14]).toSInt());
        }
    }

    GLint * first;
    first = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *first));
    if (first) {
        const trace::Array *_a_GLint194_0 = (call.arg(1)).toArray();
        for (size_t _jGLint194 = 0; _jGLint194 < _a_GLint194_0->values.size(); ++_jGLint194) {
    first[_jGLint194] = (*_a_GLint194_0->values[_jGLint194]).toSInt();
        }
    }

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(2), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei9_0 = (call.arg(2)).toArray();
        for (size_t _jGLsizei9 = 0; _jGLsizei9 < _a_GLsizei9_0->values.size(); ++_jGLsizei9) {
    count[_jGLsizei9] = (*_a_GLsizei9_0->values[_jGLsizei9]).toSInt();
        }
    }

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    GLint modestride;
    modestride = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glMultiModeDrawElementsIBM(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum * mode;
    mode = static_cast<GLenum *>(_allocator.alloc(&call.arg(0), sizeof *mode));
    if (mode) {
        const trace::Array *_a_GLenum15_0 = (call.arg(0)).toArray();
        for (size_t _jGLenum15 = 0; _jGLenum15 < _a_GLenum15_0->values.size(); ++_jGLenum15) {
    mode[_jGLenum15] = static_cast<GLenum>((*_a_GLenum15_0->values[_jGLenum15]).toSInt());
        }
    }

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(1), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei10_0 = (call.arg(1)).toArray();
        for (size_t _jGLsizei10 = 0; _jGLsizei10 < _a_GLsizei10_0->values.size(); ++_jGLsizei10) {
    count[_jGLsizei10] = (*_a_GLsizei10_0->values[_jGLsizei10]).toSInt();
        }
    }

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * * indices;
    indices = static_cast<const GLvoid * *>(_allocator.alloc(&call.arg(3), sizeof *indices));
    if (indices) {
        const trace::Array *_a_constGLvoid176_0 = (call.arg(3)).toArray();
        for (size_t _jconstGLvoid176 = 0; _jconstGLvoid176 < _a_constGLvoid176_0->values.size(); ++_jconstGLvoid176) {
    indices[_jconstGLvoid176] = static_cast<const GLvoid *>((*_a_constGLvoid176_0->values[_jconstGLvoid176]).toPointer());
        }
    }

    GLsizei primcount;
    primcount = (call.arg(4)).toSInt();

    GLint modestride;
    modestride = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glColorPointerListIBM(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = static_cast<GLint>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    GLint ptrstride;
    ptrstride = (call.arg(4)).toSInt();

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorPointerListIBM(size, type, stride, pointer, ptrstride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColorPointerListIBM(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = static_cast<GLint>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    GLint ptrstride;
    ptrstride = (call.arg(4)).toSInt();

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEdgeFlagPointerListIBM(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint stride;
    stride = (call.arg(0)).toSInt();

    const GLboolean * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    GLint ptrstride;
    ptrstride = (call.arg(2)).toSInt();

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordPointerListIBM(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    GLint ptrstride;
    ptrstride = (call.arg(3)).toSInt();

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordPointerListIBM(type, stride, pointer, ptrstride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexPointerListIBM(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    GLint ptrstride;
    ptrstride = (call.arg(3)).toSInt();

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexPointerListIBM(type, stride, pointer, ptrstride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalPointerListIBM(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    GLint ptrstride;
    ptrstride = (call.arg(3)).toSInt();

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalPointerListIBM(type, stride, pointer, ptrstride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordPointerListIBM(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    GLint ptrstride;
    ptrstride = (call.arg(4)).toSInt();

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordPointerListIBM(size, type, stride, pointer, ptrstride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexPointerListIBM(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    GLint ptrstride;
    ptrstride = (call.arg(4)).toSInt();

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexPointerListIBM(size, type, stride, pointer, ptrstride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTbufferMask3DFX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTbufferMask3DFX(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSampleMaskEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLclampf value;
    value = (call.arg(0)).toFloat();

    GLboolean invert;
    invert = static_cast<GLboolean>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSampleMaskEXT(value, invert);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSamplePatternEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pattern;
    pattern = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSamplePatternEXT(pattern);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureColorMaskSGIS(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLboolean red;
    red = static_cast<GLboolean>((call.arg(0)).toSInt());

    GLboolean green;
    green = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLboolean blue;
    blue = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLboolean alpha;
    alpha = static_cast<GLboolean>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureColorMaskSGIS(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIglooInterfaceSGIX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    const GLvoid * params;
    memset(&params, 0, sizeof params); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIglooInterfaceSGIX(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteFencesNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * fences;
    fences = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *fences));
    if (fences) {
        const trace::Array *_a_GLuint141_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint141 = 0; _jGLuint141 < _a_GLuint141_0->values.size(); ++_jGLuint141) {
    fences[_jGLuint141] = (*_a_GLuint141_0->values[_jGLuint141]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << size_t(fences[_jGLuint141]) << " <- " << size_t(_fence_map[fences[_jGLuint141]]) << "\n";
    }
    fences[_jGLuint141] = _fence_map[fences[_jGLuint141]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteFencesNV(n, fences);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenFencesNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * fences;
    fences = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *fences));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenFencesNV(n, fences);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint143 = (call.arg(1)).toArray();
    if (_aGLuint143) {
        for (size_t _jGLuint143 = 0; _jGLuint143 < _aGLuint143->values.size(); ++_jGLuint143) {
    GLuint _origResult;
    _origResult = (*_aGLuint143->values[_jGLuint143]).toUInt();
    _fence_map[_origResult] = fences[_jGLuint143];
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << _origResult << " -> " << fences[_jGLuint143] << "\n";
    }
        }
    }
}

static void retrace_glTestFenceNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint fence;
    fence = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << size_t(fence) << " <- " << size_t(_fence_map[fence]) << "\n";
    }
    fence = _fence_map[fence];

    GLboolean _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glTestFenceNV(fence);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFinishFenceNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint fence;
    fence = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << size_t(fence) << " <- " << size_t(_fence_map[fence]) << "\n";
    }
    fence = _fence_map[fence];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFinishFenceNV(fence);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSetFenceNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint fence;
    fence = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << size_t(fence) << " <- " << size_t(_fence_map[fence]) << "\n";
    }
    fence = _fence_map[fence];

    GLenum condition;
    condition = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSetFenceNV(fence, condition);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapControlPointsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei ustride;
    ustride = (call.arg(3)).toSInt();

    GLsizei vstride;
    vstride = (call.arg(4)).toSInt();

    GLint uorder;
    uorder = (call.arg(5)).toSInt();

    GLint vorder;
    vorder = (call.arg(6)).toSInt();

    GLboolean packed;
    packed = static_cast<GLboolean>((call.arg(7)).toSInt());

    const GLvoid * points;
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapParameterivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLint * params;
    memset(&params, 0, sizeof params); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapParameterivNV(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapParameterfvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLfloat * params;
    memset(&params, 0, sizeof params); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapParameterfvNV(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEvalMapsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEvalMapsNV(target, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCombinerStageParameterfvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stage;
    stage = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat254_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat254 = 0; _jGLfloat254 < _a_GLfloat254_0->values.size(); ++_jGLfloat254) {
    params[_jGLfloat254] = (*_a_GLfloat254_0->values[_jGLfloat254]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCombinerStageParameterfvNV(stage, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindProgramNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint program;
    program = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(program) << " <- " << size_t(_programARB_map[program]) << "\n";
    }
    program = _programARB_map[program];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindProgramNV(target, program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteProgramsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * programs;
    programs = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *programs));
    if (programs) {
        const trace::Array *_a_GLuint144_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint144 = 0; _jGLuint144 < _a_GLuint144_0->values.size(); ++_jGLuint144) {
    programs[_jGLuint144] = (*_a_GLuint144_0->values[_jGLuint144]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(programs[_jGLuint144]) << " <- " << size_t(_programARB_map[programs[_jGLuint144]]) << "\n";
    }
    programs[_jGLuint144] = _programARB_map[programs[_jGLuint144]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteProgramsNV(n, programs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glExecuteProgramNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(id) << " <- " << size_t(_programARB_map[id]) << "\n";
    }
    id = _programARB_map[id];

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat255_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat255 = 0; _jGLfloat255 < _a_GLfloat255_0->values.size(); ++_jGLfloat255) {
    params[_jGLfloat255] = (*_a_GLfloat255_0->values[_jGLfloat255]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glExecuteProgramNV(target, id, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenProgramsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * programs;
    programs = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *programs));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenProgramsNV(n, programs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint146 = (call.arg(1)).toArray();
    if (_aGLuint146) {
        for (size_t _jGLuint146 = 0; _jGLuint146 < _aGLuint146->values.size(); ++_jGLuint146) {
    GLuint _origResult;
    _origResult = (*_aGLuint146->values[_jGLuint146]).toUInt();
    _programARB_map[_origResult] = programs[_jGLuint146];
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << _origResult << " -> " << programs[_jGLuint146] << "\n";
    }
        }
    }
}

static void retrace_glLoadProgramNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(id) << " <- " << size_t(_programARB_map[id]) << "\n";
    }
    id = _programARB_map[id];

    GLsizei len;
    len = (call.arg(2)).toSInt();

    const GLubyte * program;
    program = (const GLubyte *)((call.arg(3)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadProgramNV(target, id, len, program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameter4dNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLdouble x;
    x = (call.arg(2)).toDouble();

    GLdouble y;
    y = (call.arg(3)).toDouble();

    GLdouble z;
    z = (call.arg(4)).toDouble();

    GLdouble w;
    w = (call.arg(5)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameter4dNV(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameter4dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble106_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble106 = 0; _jGLdouble106 < _a_GLdouble106_0->values.size(); ++_jGLdouble106) {
    v[_jGLdouble106] = (*_a_GLdouble106_0->values[_jGLdouble106]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameter4dvNV(target, index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameter4fNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLfloat x;
    x = (call.arg(2)).toFloat();

    GLfloat y;
    y = (call.arg(3)).toFloat();

    GLfloat z;
    z = (call.arg(4)).toFloat();

    GLfloat w;
    w = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameter4fNV(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameter4fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat256_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat256 = 0; _jGLfloat256 < _a_GLfloat256_0->values.size(); ++_jGLfloat256) {
    v[_jGLfloat256] = (*_a_GLfloat256_0->values[_jGLfloat256]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameter4fvNV(target, index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameters4dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble107_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble107 = 0; _jGLdouble107 < _a_GLdouble107_0->values.size(); ++_jGLdouble107) {
    v[_jGLdouble107] = (*_a_GLdouble107_0->values[_jGLdouble107]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameters4dvNV(target, index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameters4fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat257_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat257 = 0; _jGLfloat257 < _a_GLfloat257_0->values.size(); ++_jGLfloat257) {
    v[_jGLfloat257] = (*_a_GLfloat257_0->values[_jGLfloat257]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameters4fvNV(target, index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRequestResidentProgramsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * programs;
    programs = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *programs));
    if (programs) {
        const trace::Array *_a_GLuint147_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint147 = 0; _jGLuint147 < _a_GLuint147_0->values.size(); ++_jGLuint147) {
    programs[_jGLuint147] = (*_a_GLuint147_0->values[_jGLuint147]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(programs[_jGLuint147]) << " <- " << size_t(_programARB_map[programs[_jGLuint147]]) << "\n";
    }
    programs[_jGLuint147] = _programARB_map[programs[_jGLuint147]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRequestResidentProgramsNV(n, programs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTrackMatrixNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint address;
    address = (call.arg(1)).toUInt();

    GLenum matrix;
    matrix = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum transform;
    transform = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTrackMatrixNV(target, address, matrix, transform);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribPointerNV(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = static_cast<GLint>((call.arg(1)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(4), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribPointerNV(index, size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1dNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1dNV(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLdouble11_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLdouble11_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1dvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1fNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1fNV(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLfloat22_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLfloat22_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1fvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1sNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1sNV(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1svNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLshort6_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLshort6_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1svNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2dNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2dNV(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble108_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble108 = 0; _jGLdouble108 < _a_GLdouble108_0->values.size(); ++_jGLdouble108) {
    v[_jGLdouble108] = (*_a_GLdouble108_0->values[_jGLdouble108]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2dvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2fNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2fNV(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat258_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat258 = 0; _jGLfloat258 < _a_GLfloat258_0->values.size(); ++_jGLfloat258) {
    v[_jGLfloat258] = (*_a_GLfloat258_0->values[_jGLfloat258]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2fvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2sNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2sNV(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2svNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort42_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort42 = 0; _jGLshort42 < _a_GLshort42_0->values.size(); ++_jGLshort42) {
    v[_jGLshort42] = (*_a_GLshort42_0->values[_jGLshort42]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2svNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3dNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3dNV(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble109_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble109 = 0; _jGLdouble109 < _a_GLdouble109_0->values.size(); ++_jGLdouble109) {
    v[_jGLdouble109] = (*_a_GLdouble109_0->values[_jGLdouble109]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3dvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3fNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3fNV(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat259_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat259 = 0; _jGLfloat259 < _a_GLfloat259_0->values.size(); ++_jGLfloat259) {
    v[_jGLfloat259] = (*_a_GLfloat259_0->values[_jGLfloat259]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3fvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3sNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    GLshort z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3sNV(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3svNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort43_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort43 = 0; _jGLshort43 < _a_GLshort43_0->values.size(); ++_jGLshort43) {
    v[_jGLshort43] = (*_a_GLshort43_0->values[_jGLshort43]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3svNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4dNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    GLdouble w;
    w = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4dNV(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble110_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble110 = 0; _jGLdouble110 < _a_GLdouble110_0->values.size(); ++_jGLdouble110) {
    v[_jGLdouble110] = (*_a_GLdouble110_0->values[_jGLdouble110]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4dvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4fNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    GLfloat w;
    w = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4fNV(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat260_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat260 = 0; _jGLfloat260 < _a_GLfloat260_0->values.size(); ++_jGLfloat260) {
    v[_jGLfloat260] = (*_a_GLfloat260_0->values[_jGLfloat260]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4fvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4sNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    GLshort z;
    z = (call.arg(3)).toSInt();

    GLshort w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4sNV(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4svNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort44_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort44 = 0; _jGLshort44 < _a_GLshort44_0->values.size(); ++_jGLshort44) {
    v[_jGLshort44] = (*_a_GLshort44_0->values[_jGLshort44]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4svNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4ubNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte x;
    x = (call.arg(1)).toUInt();

    GLubyte y;
    y = (call.arg(2)).toUInt();

    GLubyte z;
    z = (call.arg(3)).toUInt();

    GLubyte w;
    w = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4ubNV(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4ubvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte23_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte23 = 0; _jGLubyte23 < _a_GLubyte23_0->values.size(); ++_jGLubyte23) {
    v[_jGLubyte23] = (*_a_GLubyte23_0->values[_jGLubyte23]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4ubvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs1dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble111_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble111 = 0; _jGLdouble111 < _a_GLdouble111_0->values.size(); ++_jGLdouble111) {
    v[_jGLdouble111] = (*_a_GLdouble111_0->values[_jGLdouble111]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs1dvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs1fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat261_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat261 = 0; _jGLfloat261 < _a_GLfloat261_0->values.size(); ++_jGLfloat261) {
    v[_jGLfloat261] = (*_a_GLfloat261_0->values[_jGLfloat261]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs1fvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs1svNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort45_0 = (call.arg(2)).toArray();
        for (size_t _jGLshort45 = 0; _jGLshort45 < _a_GLshort45_0->values.size(); ++_jGLshort45) {
    v[_jGLshort45] = (*_a_GLshort45_0->values[_jGLshort45]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs1svNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs2dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble112_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble112 = 0; _jGLdouble112 < _a_GLdouble112_0->values.size(); ++_jGLdouble112) {
    v[_jGLdouble112] = (*_a_GLdouble112_0->values[_jGLdouble112]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs2dvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs2fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat262_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat262 = 0; _jGLfloat262 < _a_GLfloat262_0->values.size(); ++_jGLfloat262) {
    v[_jGLfloat262] = (*_a_GLfloat262_0->values[_jGLfloat262]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs2fvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs2svNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort46_0 = (call.arg(2)).toArray();
        for (size_t _jGLshort46 = 0; _jGLshort46 < _a_GLshort46_0->values.size(); ++_jGLshort46) {
    v[_jGLshort46] = (*_a_GLshort46_0->values[_jGLshort46]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs2svNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs3dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble113_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble113 = 0; _jGLdouble113 < _a_GLdouble113_0->values.size(); ++_jGLdouble113) {
    v[_jGLdouble113] = (*_a_GLdouble113_0->values[_jGLdouble113]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs3dvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs3fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat263_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat263 = 0; _jGLfloat263 < _a_GLfloat263_0->values.size(); ++_jGLfloat263) {
    v[_jGLfloat263] = (*_a_GLfloat263_0->values[_jGLfloat263]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs3fvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs3svNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort47_0 = (call.arg(2)).toArray();
        for (size_t _jGLshort47 = 0; _jGLshort47 < _a_GLshort47_0->values.size(); ++_jGLshort47) {
    v[_jGLshort47] = (*_a_GLshort47_0->values[_jGLshort47]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs3svNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs4dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble114_0 = (call.arg(2)).toArray();
        for (size_t _jGLdouble114 = 0; _jGLdouble114 < _a_GLdouble114_0->values.size(); ++_jGLdouble114) {
    v[_jGLdouble114] = (*_a_GLdouble114_0->values[_jGLdouble114]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs4dvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs4fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat264_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat264 = 0; _jGLfloat264 < _a_GLfloat264_0->values.size(); ++_jGLfloat264) {
    v[_jGLfloat264] = (*_a_GLfloat264_0->values[_jGLfloat264]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs4fvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs4svNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort48_0 = (call.arg(2)).toArray();
        for (size_t _jGLshort48 = 0; _jGLshort48 < _a_GLshort48_0->values.size(); ++_jGLshort48) {
    v[_jGLshort48] = (*_a_GLshort48_0->values[_jGLshort48]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs4svNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs4ubvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte24_0 = (call.arg(2)).toArray();
        for (size_t _jGLubyte24 = 0; _jGLubyte24 < _a_GLubyte24_0->values.size(); ++_jGLubyte24) {
    v[_jGLubyte24] = (*_a_GLubyte24_0->values[_jGLubyte24]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs4ubvNV(index, count, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexBumpParameterivATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * param;
    param = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *param));
    if (param) {
        const trace::Array *_a_GLint195_0 = (call.arg(1)).toArray();
        for (size_t _jGLint195 = 0; _jGLint195 < _a_GLint195_0->values.size(); ++_jGLint195) {
    param[_jGLint195] = (*_a_GLint195_0->values[_jGLint195]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexBumpParameterivATI(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexBumpParameterfvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * param;
    param = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *param));
    if (param) {
        const trace::Array *_a_GLfloat265_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat265 = 0; _jGLfloat265 < _a_GLfloat265_0->values.size(); ++_jGLfloat265) {
    param[_jGLfloat265] = (*_a_GLfloat265_0->values[_jGLfloat265]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexBumpParameterfvATI(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenFragmentShadersATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint range;
    range = (call.arg(0)).toUInt();

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGenFragmentShadersATI(range);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLuint _origResult;
    _origResult = (*call.ret).toUInt();
    for (GLuint _hPGLuint23 = 0; _hPGLuint23 < range; ++_hPGLuint23) {
        _fragmentShaderATI_map[_origResult + _hPGLuint23] = _result + _hPGLuint23;
        if (retrace::verbosity >= 2) {
            std::cout << "fragmentShaderATI " << (_origResult + _hPGLuint23) << " -> " << (_result + _hPGLuint23) << "\n";
        }
    }
}

static void retrace_glBindFragmentShaderATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fragmentShaderATI " << size_t(id) << " <- " << size_t(_fragmentShaderATI_map[id]) << "\n";
    }
    id = _fragmentShaderATI_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindFragmentShaderATI(id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteFragmentShaderATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fragmentShaderATI " << size_t(id) << " <- " << size_t(_fragmentShaderATI_map[id]) << "\n";
    }
    id = _fragmentShaderATI_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteFragmentShaderATI(id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginFragmentShaderATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginFragmentShaderATI();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndFragmentShaderATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndFragmentShaderATI();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPassTexCoordATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint dst;
    dst = (call.arg(0)).toUInt();

    GLuint coord;
    coord = (call.arg(1)).toUInt();

    GLenum swizzle;
    swizzle = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPassTexCoordATI(dst, coord, swizzle);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSampleMapATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint dst;
    dst = (call.arg(0)).toUInt();

    GLuint interp;
    interp = (call.arg(1)).toUInt();

    GLenum swizzle;
    swizzle = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSampleMapATI(dst, interp, swizzle);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorFragmentOp1ATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint dst;
    dst = (call.arg(1)).toUInt();

    GLuint dstMask;
    dstMask = (call.arg(2)).toUInt();

    GLuint dstMod;
    dstMod = (call.arg(3)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(4)).toUInt();

    GLuint arg1Rep;
    arg1Rep = (call.arg(5)).toUInt();

    GLuint arg1Mod;
    arg1Mod = (call.arg(6)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorFragmentOp2ATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint dst;
    dst = (call.arg(1)).toUInt();

    GLuint dstMask;
    dstMask = (call.arg(2)).toUInt();

    GLuint dstMod;
    dstMod = (call.arg(3)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(4)).toUInt();

    GLuint arg1Rep;
    arg1Rep = (call.arg(5)).toUInt();

    GLuint arg1Mod;
    arg1Mod = (call.arg(6)).toUInt();

    GLuint arg2;
    arg2 = (call.arg(7)).toUInt();

    GLuint arg2Rep;
    arg2Rep = (call.arg(8)).toUInt();

    GLuint arg2Mod;
    arg2Mod = (call.arg(9)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorFragmentOp3ATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint dst;
    dst = (call.arg(1)).toUInt();

    GLuint dstMask;
    dstMask = (call.arg(2)).toUInt();

    GLuint dstMod;
    dstMod = (call.arg(3)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(4)).toUInt();

    GLuint arg1Rep;
    arg1Rep = (call.arg(5)).toUInt();

    GLuint arg1Mod;
    arg1Mod = (call.arg(6)).toUInt();

    GLuint arg2;
    arg2 = (call.arg(7)).toUInt();

    GLuint arg2Rep;
    arg2Rep = (call.arg(8)).toUInt();

    GLuint arg2Mod;
    arg2Mod = (call.arg(9)).toUInt();

    GLuint arg3;
    arg3 = (call.arg(10)).toUInt();

    GLuint arg3Rep;
    arg3Rep = (call.arg(11)).toUInt();

    GLuint arg3Mod;
    arg3Mod = (call.arg(12)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAlphaFragmentOp1ATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint dst;
    dst = (call.arg(1)).toUInt();

    GLuint dstMod;
    dstMod = (call.arg(2)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(3)).toUInt();

    GLuint arg1Rep;
    arg1Rep = (call.arg(4)).toUInt();

    GLuint arg1Mod;
    arg1Mod = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAlphaFragmentOp2ATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint dst;
    dst = (call.arg(1)).toUInt();

    GLuint dstMod;
    dstMod = (call.arg(2)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(3)).toUInt();

    GLuint arg1Rep;
    arg1Rep = (call.arg(4)).toUInt();

    GLuint arg1Mod;
    arg1Mod = (call.arg(5)).toUInt();

    GLuint arg2;
    arg2 = (call.arg(6)).toUInt();

    GLuint arg2Rep;
    arg2Rep = (call.arg(7)).toUInt();

    GLuint arg2Mod;
    arg2Mod = (call.arg(8)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAlphaFragmentOp3ATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint dst;
    dst = (call.arg(1)).toUInt();

    GLuint dstMod;
    dstMod = (call.arg(2)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(3)).toUInt();

    GLuint arg1Rep;
    arg1Rep = (call.arg(4)).toUInt();

    GLuint arg1Mod;
    arg1Mod = (call.arg(5)).toUInt();

    GLuint arg2;
    arg2 = (call.arg(6)).toUInt();

    GLuint arg2Rep;
    arg2Rep = (call.arg(7)).toUInt();

    GLuint arg2Mod;
    arg2Mod = (call.arg(8)).toUInt();

    GLuint arg3;
    arg3 = (call.arg(9)).toUInt();

    GLuint arg3Rep;
    arg3Rep = (call.arg(10)).toUInt();

    GLuint arg3Mod;
    arg3Mod = (call.arg(11)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSetFragmentShaderConstantATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint dst;
    dst = (call.arg(0)).toUInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat266_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat266 = 0; _jGLfloat266 < _a_GLfloat266_0->values.size(); ++_jGLfloat266) {
    value[_jGLfloat266] = (*_a_GLfloat266_0->values[_jGLfloat266]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSetFragmentShaderConstantATI(dst, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPNTrianglesiATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPNTrianglesiATI(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPNTrianglesfATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPNTrianglesfATI(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNewObjectBufferATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei size;
    size = (call.arg(0)).toSInt();

    GLvoid * pointer;
    pointer = static_cast<GLvoid *>((call.arg(1)).toPointer());

    GLenum usage;
    usage = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glNewObjectBufferATI(size, pointer, usage);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUpdateObjectBufferATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();

    GLuint offset;
    offset = (call.arg(1)).toUInt();

    GLsizei size;
    size = (call.arg(2)).toSInt();

    GLvoid * pointer;
    pointer = static_cast<GLvoid *>((call.arg(3)).toPointer());

    GLenum preserve;
    preserve = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFreeObjectBufferATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFreeObjectBufferATI(buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glArrayObjectATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum array;
    array = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    GLuint buffer;
    buffer = (call.arg(4)).toUInt();

    GLuint offset;
    offset = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glArrayObjectATI(array, size, type, stride, buffer, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantArrayObjectATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    GLuint buffer;
    buffer = (call.arg(3)).toUInt();

    GLuint offset;
    offset = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantArrayObjectATI(id, type, stride, buffer, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginVertexShaderEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginVertexShaderEXT();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndVertexShaderEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndVertexShaderEXT();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindVertexShaderEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindVertexShaderEXT(id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenVertexShadersEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint range;
    range = (call.arg(0)).toUInt();

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGenVertexShadersEXT(range);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteVertexShaderEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteVertexShaderEXT(id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glShaderOp1EXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint res;
    res = (call.arg(1)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glShaderOp1EXT(op, res, arg1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glShaderOp2EXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint res;
    res = (call.arg(1)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(2)).toUInt();

    GLuint arg2;
    arg2 = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glShaderOp2EXT(op, res, arg1, arg2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glShaderOp3EXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum op;
    op = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint res;
    res = (call.arg(1)).toUInt();

    GLuint arg1;
    arg1 = (call.arg(2)).toUInt();

    GLuint arg2;
    arg2 = (call.arg(3)).toUInt();

    GLuint arg3;
    arg3 = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glShaderOp3EXT(op, res, arg1, arg2, arg3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSwizzleEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint res;
    res = (call.arg(0)).toUInt();

    GLuint in;
    in = (call.arg(1)).toUInt();

    GLenum outX;
    outX = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum outY;
    outY = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum outZ;
    outZ = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum outW;
    outW = static_cast<GLenum>((call.arg(5)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSwizzleEXT(res, in, outX, outY, outZ, outW);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWriteMaskEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint res;
    res = (call.arg(0)).toUInt();

    GLuint in;
    in = (call.arg(1)).toUInt();

    GLenum outX;
    outX = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum outY;
    outY = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum outZ;
    outZ = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum outW;
    outW = static_cast<GLenum>((call.arg(5)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWriteMaskEXT(res, in, outX, outY, outZ, outW);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glInsertComponentEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint res;
    res = (call.arg(0)).toUInt();

    GLuint src;
    src = (call.arg(1)).toUInt();

    GLuint num;
    num = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glInsertComponentEXT(res, src, num);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glExtractComponentEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint res;
    res = (call.arg(0)).toUInt();

    GLuint src;
    src = (call.arg(1)).toUInt();

    GLuint num;
    num = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glExtractComponentEXT(res, src, num);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenSymbolsEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum datatype;
    datatype = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum storagetype;
    storagetype = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum range;
    range = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint components;
    components = (call.arg(3)).toUInt();

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGenSymbolsEXT(datatype, storagetype, range, components);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSetInvariantEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLvoid * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSetInvariantEXT(id, type, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSetLocalConstantEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLvoid * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSetLocalConstantEXT(id, type, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantbvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    const GLbyte * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantbvEXT(id, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantsvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    const GLshort * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantsvEXT(id, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    const GLint * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantivEXT(id, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    const GLfloat * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantfvEXT(id, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantdvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    const GLdouble * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantdvEXT(id, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantubvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    const GLubyte * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantubvEXT(id, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantusvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    const GLushort * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantusvEXT(id, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantuivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    const GLuint * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantuivEXT(id, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVariantPointerEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint stride;
    stride = (call.arg(2)).toUInt();

    const GLvoid * addr;
    memset(&addr, 0, sizeof addr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVariantPointerEXT(id, type, stride, addr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableVariantClientStateEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableVariantClientStateEXT(id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableVariantClientStateEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableVariantClientStateEXT(id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindLightParameterEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum value;
    value = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glBindLightParameterEXT(light, value);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindMaterialParameterEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum value;
    value = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glBindMaterialParameterEXT(face, value);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindTexGenParameterEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum unit;
    unit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum coord;
    coord = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum value;
    value = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glBindTexGenParameterEXT(unit, coord, value);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindTextureUnitParameterEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum unit;
    unit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum value;
    value = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glBindTextureUnitParameterEXT(unit, value);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindParameterEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum value;
    value = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glBindParameterEXT(value);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream1sATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream1sATI(stream, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream1svATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * coords;
    coords = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLshort7_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLshort7_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream1svATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream1iATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream1iATI(stream, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream1ivATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * coords;
    coords = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLint30_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLint30_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream1ivATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream1fATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat x;
    x = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream1fATI(stream, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream1fvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * coords;
    coords = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLfloat23_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLfloat23_0->values[0]).toFloat();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream1fvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream1dATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble x;
    x = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream1dATI(stream, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream1dvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * coords;
    coords = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_PGLdouble12_0 = (call.arg(1)).toArray();
    coords[0] = (*_a_PGLdouble12_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream1dvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream2sATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream2sATI(stream, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream2svATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * coords;
    coords = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLshort49_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort49 = 0; _jGLshort49 < _a_GLshort49_0->values.size(); ++_jGLshort49) {
    coords[_jGLshort49] = (*_a_GLshort49_0->values[_jGLshort49]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream2svATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream2iATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream2iATI(stream, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream2ivATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * coords;
    coords = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLint196_0 = (call.arg(1)).toArray();
        for (size_t _jGLint196 = 0; _jGLint196 < _a_GLint196_0->values.size(); ++_jGLint196) {
    coords[_jGLint196] = (*_a_GLint196_0->values[_jGLint196]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream2ivATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream2fATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream2fATI(stream, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream2fvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * coords;
    coords = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLfloat267_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat267 = 0; _jGLfloat267 < _a_GLfloat267_0->values.size(); ++_jGLfloat267) {
    coords[_jGLfloat267] = (*_a_GLfloat267_0->values[_jGLfloat267]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream2fvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream2dATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream2dATI(stream, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream2dvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * coords;
    coords = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLdouble115_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble115 = 0; _jGLdouble115 < _a_GLdouble115_0->values.size(); ++_jGLdouble115) {
    coords[_jGLdouble115] = (*_a_GLdouble115_0->values[_jGLdouble115]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream2dvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream3sATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    GLshort z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream3sATI(stream, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream3svATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * coords;
    coords = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLshort50_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort50 = 0; _jGLshort50 < _a_GLshort50_0->values.size(); ++_jGLshort50) {
    coords[_jGLshort50] = (*_a_GLshort50_0->values[_jGLshort50]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream3svATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream3iATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    GLint z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream3iATI(stream, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream3ivATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * coords;
    coords = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLint197_0 = (call.arg(1)).toArray();
        for (size_t _jGLint197 = 0; _jGLint197 < _a_GLint197_0->values.size(); ++_jGLint197) {
    coords[_jGLint197] = (*_a_GLint197_0->values[_jGLint197]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream3ivATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream3fATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream3fATI(stream, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream3fvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * coords;
    coords = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLfloat268_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat268 = 0; _jGLfloat268 < _a_GLfloat268_0->values.size(); ++_jGLfloat268) {
    coords[_jGLfloat268] = (*_a_GLfloat268_0->values[_jGLfloat268]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream3fvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream3dATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream3dATI(stream, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream3dvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * coords;
    coords = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLdouble116_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble116 = 0; _jGLdouble116 < _a_GLdouble116_0->values.size(); ++_jGLdouble116) {
    coords[_jGLdouble116] = (*_a_GLdouble116_0->values[_jGLdouble116]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream3dvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream4sATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort x;
    x = (call.arg(1)).toSInt();

    GLshort y;
    y = (call.arg(2)).toSInt();

    GLshort z;
    z = (call.arg(3)).toSInt();

    GLshort w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream4sATI(stream, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream4svATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * coords;
    coords = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLshort51_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort51 = 0; _jGLshort51 < _a_GLshort51_0->values.size(); ++_jGLshort51) {
    coords[_jGLshort51] = (*_a_GLshort51_0->values[_jGLshort51]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream4svATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream4iATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    GLint z;
    z = (call.arg(3)).toSInt();

    GLint w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream4iATI(stream, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream4ivATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * coords;
    coords = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLint198_0 = (call.arg(1)).toArray();
        for (size_t _jGLint198 = 0; _jGLint198 < _a_GLint198_0->values.size(); ++_jGLint198) {
    coords[_jGLint198] = (*_a_GLint198_0->values[_jGLint198]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream4ivATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream4fATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    GLfloat w;
    w = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream4fATI(stream, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream4fvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * coords;
    coords = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLfloat269_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat269 = 0; _jGLfloat269 < _a_GLfloat269_0->values.size(); ++_jGLfloat269) {
    coords[_jGLfloat269] = (*_a_GLfloat269_0->values[_jGLfloat269]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream4fvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream4dATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    GLdouble w;
    w = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream4dATI(stream, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexStream4dvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * coords;
    coords = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLdouble117_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble117 = 0; _jGLdouble117 < _a_GLdouble117_0->values.size(); ++_jGLdouble117) {
    coords[_jGLdouble117] = (*_a_GLdouble117_0->values[_jGLdouble117]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexStream4dvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3bATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLbyte nx;
    nx = (call.arg(1)).toSInt();

    GLbyte ny;
    ny = (call.arg(2)).toSInt();

    GLbyte nz;
    nz = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3bATI(stream, nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3bvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLbyte * coords;
    coords = static_cast<GLbyte *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLbyte14_0 = (call.arg(1)).toArray();
        for (size_t _jGLbyte14 = 0; _jGLbyte14 < _a_GLbyte14_0->values.size(); ++_jGLbyte14) {
    coords[_jGLbyte14] = (*_a_GLbyte14_0->values[_jGLbyte14]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3bvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3sATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort nx;
    nx = (call.arg(1)).toSInt();

    GLshort ny;
    ny = (call.arg(2)).toSInt();

    GLshort nz;
    nz = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3sATI(stream, nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3svATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLshort * coords;
    coords = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLshort52_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort52 = 0; _jGLshort52 < _a_GLshort52_0->values.size(); ++_jGLshort52) {
    coords[_jGLshort52] = (*_a_GLshort52_0->values[_jGLshort52]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3svATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3iATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint nx;
    nx = (call.arg(1)).toSInt();

    GLint ny;
    ny = (call.arg(2)).toSInt();

    GLint nz;
    nz = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3iATI(stream, nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3ivATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * coords;
    coords = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLint199_0 = (call.arg(1)).toArray();
        for (size_t _jGLint199 = 0; _jGLint199 < _a_GLint199_0->values.size(); ++_jGLint199) {
    coords[_jGLint199] = (*_a_GLint199_0->values[_jGLint199]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3ivATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3fATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat nx;
    nx = (call.arg(1)).toFloat();

    GLfloat ny;
    ny = (call.arg(2)).toFloat();

    GLfloat nz;
    nz = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3fATI(stream, nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3fvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * coords;
    coords = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLfloat270_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat270 = 0; _jGLfloat270 < _a_GLfloat270_0->values.size(); ++_jGLfloat270) {
    coords[_jGLfloat270] = (*_a_GLfloat270_0->values[_jGLfloat270]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3fvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3dATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble nx;
    nx = (call.arg(1)).toDouble();

    GLdouble ny;
    ny = (call.arg(2)).toDouble();

    GLdouble nz;
    nz = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3dATI(stream, nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalStream3dvATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * coords;
    coords = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLdouble118_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble118 = 0; _jGLdouble118 < _a_GLdouble118_0->values.size(); ++_jGLdouble118) {
    coords[_jGLdouble118] = (*_a_GLdouble118_0->values[_jGLdouble118]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalStream3dvATI(stream, coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClientActiveVertexStreamATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum stream;
    stream = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClientActiveVertexStreamATI(stream);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexBlendEnviATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexBlendEnviATI(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexBlendEnvfATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat param;
    param = (call.arg(1)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexBlendEnvfATI(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glElementPointerATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glElementPointerATI(type, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawElementArrayATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawElementArrayATI(mode, count);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawRangeElementArrayATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint start;
    start = (call.arg(1)).toUInt();

    GLuint end;
    end = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawRangeElementArrayATI(mode, start, end, count);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawMeshArraysSUN(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint first;
    first = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawMeshArraysSUN(mode, first, count, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glGenOcclusionQueriesNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenOcclusionQueriesNV(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint149 = (call.arg(1)).toArray();
    if (_aGLuint149) {
        for (size_t _jGLuint149 = 0; _jGLuint149 < _aGLuint149->values.size(); ++_jGLuint149) {
    GLuint _origResult;
    _origResult = (*_aGLuint149->values[_jGLuint149]).toUInt();
    _query_map[_origResult] = ids[_jGLuint149];
    if (retrace::verbosity >= 2) {
        std::cout << "query " << _origResult << " -> " << ids[_jGLuint149] << "\n";
    }
        }
    }
}

static void retrace_glDeleteOcclusionQueriesNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint150_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint150 = 0; _jGLuint150 < _a_GLuint150_0->values.size(); ++_jGLuint150) {
    ids[_jGLuint150] = (*_a_GLuint150_0->values[_jGLuint150]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(ids[_jGLuint150]) << " <- " << size_t(_query_map[ids[_jGLuint150]]) << "\n";
    }
    ids[_jGLuint150] = _query_map[ids[_jGLuint150]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteOcclusionQueriesNV(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginOcclusionQueryNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(id) << " <- " << size_t(_query_map[id]) << "\n";
    }
    id = _query_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginOcclusionQueryNV(id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndOcclusionQueryNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndOcclusionQueryNV();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameteriNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameteriNV(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint200_0 = (call.arg(1)).toArray();
        for (size_t _jGLint200 = 0; _jGLint200 < _a_GLint200_0->values.size(); ++_jGLint200) {
    params[_jGLint200] = (*_a_GLint200_0->values[_jGLint200]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterivNV(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glActiveStencilFaceEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glActiveStencilFaceEXT(face);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glElementPointerAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLvoid * pointer;
    pointer = static_cast<GLvoid *>((call.arg(1)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glElementPointerAPPLE(type, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawElementArrayAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint first;
    first = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawElementArrayAPPLE(mode, first, count);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawRangeElementArrayAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint start;
    start = (call.arg(1)).toUInt();

    GLuint end;
    end = (call.arg(2)).toUInt();

    GLint first;
    first = (call.arg(3)).toSInt();

    GLsizei count;
    count = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiDrawElementArrayAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint * first;
    first = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *first));
    if (first) {
        const trace::Array *_a_GLint201_0 = (call.arg(1)).toArray();
        for (size_t _jGLint201 = 0; _jGLint201 < _a_GLint201_0->values.size(); ++_jGLint201) {
    first[_jGLint201] = (*_a_GLint201_0->values[_jGLint201]).toSInt();
        }
    }

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(2), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei11_0 = (call.arg(2)).toArray();
        for (size_t _jGLsizei11 = 0; _jGLsizei11 < _a_GLsizei11_0->values.size(); ++_jGLsizei11) {
    count[_jGLsizei11] = (*_a_GLsizei11_0->values[_jGLsizei11]).toSInt();
        }
    }

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiDrawElementArrayAPPLE(mode, first, count, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiDrawRangeElementArrayAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint start;
    start = (call.arg(1)).toUInt();

    GLuint end;
    end = (call.arg(2)).toUInt();

    GLint * first;
    first = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *first));
    if (first) {
        const trace::Array *_a_GLint202_0 = (call.arg(3)).toArray();
        for (size_t _jGLint202 = 0; _jGLint202 < _a_GLint202_0->values.size(); ++_jGLint202) {
    first[_jGLint202] = (*_a_GLint202_0->values[_jGLint202]).toSInt();
        }
    }

    GLsizei * count;
    count = static_cast<GLsizei *>(_allocator.alloc(&call.arg(4), sizeof *count));
    if (count) {
        const trace::Array *_a_GLsizei12_0 = (call.arg(4)).toArray();
        for (size_t _jGLsizei12 = 0; _jGLsizei12 < _a_GLsizei12_0->values.size(); ++_jGLsizei12) {
    count[_jGLsizei12] = (*_a_GLsizei12_0->values[_jGLsizei12]).toSInt();
        }
    }

    GLsizei primcount;
    primcount = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenFencesAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * fences;
    fences = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *fences));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenFencesAPPLE(n, fences);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint152 = (call.arg(1)).toArray();
    if (_aGLuint152) {
        for (size_t _jGLuint152 = 0; _jGLuint152 < _aGLuint152->values.size(); ++_jGLuint152) {
    GLuint _origResult;
    _origResult = (*_aGLuint152->values[_jGLuint152]).toUInt();
    _fence_map[_origResult] = fences[_jGLuint152];
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << _origResult << " -> " << fences[_jGLuint152] << "\n";
    }
        }
    }
}

static void retrace_glDeleteFencesAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * fences;
    fences = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *fences));
    if (fences) {
        const trace::Array *_a_GLuint153_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint153 = 0; _jGLuint153 < _a_GLuint153_0->values.size(); ++_jGLuint153) {
    fences[_jGLuint153] = (*_a_GLuint153_0->values[_jGLuint153]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << size_t(fences[_jGLuint153]) << " <- " << size_t(_fence_map[fences[_jGLuint153]]) << "\n";
    }
    fences[_jGLuint153] = _fence_map[fences[_jGLuint153]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteFencesAPPLE(n, fences);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSetFenceAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint fence;
    fence = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << size_t(fence) << " <- " << size_t(_fence_map[fence]) << "\n";
    }
    fence = _fence_map[fence];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSetFenceAPPLE(fence);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTestFenceAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint fence;
    fence = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << size_t(fence) << " <- " << size_t(_fence_map[fence]) << "\n";
    }
    fence = _fence_map[fence];

    GLboolean _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glTestFenceAPPLE(fence);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFinishFenceAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint fence;
    fence = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "fence " << size_t(fence) << " <- " << size_t(_fence_map[fence]) << "\n";
    }
    fence = _fence_map[fence];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFinishFenceAPPLE(fence);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTestObjectAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum object;
    object = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint name;
    name = (call.arg(1)).toUInt();

    GLboolean _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glTestObjectAPPLE(object, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFinishObjectAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum object;
    object = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint name;
    name = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFinishObjectAPPLE(object, name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindVertexArrayAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint array;
    array = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "arrayAPPLE " << size_t(array) << " <- " << size_t(_arrayAPPLE_map[array]) << "\n";
    }
    array = _arrayAPPLE_map[array];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindVertexArrayAPPLE(array);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteVertexArraysAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * arrays;
    arrays = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *arrays));
    if (arrays) {
        const trace::Array *_a_GLuint154_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint154 = 0; _jGLuint154 < _a_GLuint154_0->values.size(); ++_jGLuint154) {
    arrays[_jGLuint154] = (*_a_GLuint154_0->values[_jGLuint154]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "arrayAPPLE " << size_t(arrays[_jGLuint154]) << " <- " << size_t(_arrayAPPLE_map[arrays[_jGLuint154]]) << "\n";
    }
    arrays[_jGLuint154] = _arrayAPPLE_map[arrays[_jGLuint154]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteVertexArraysAPPLE(n, arrays);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenVertexArraysAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * arrays;
    arrays = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *arrays));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenVertexArraysAPPLE(n, arrays);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint156 = (call.arg(1)).toArray();
    if (_aGLuint156) {
        for (size_t _jGLuint156 = 0; _jGLuint156 < _aGLuint156->values.size(); ++_jGLuint156) {
    GLuint _origResult;
    _origResult = (*_aGLuint156->values[_jGLuint156]).toUInt();
    _arrayAPPLE_map[_origResult] = arrays[_jGLuint156];
    if (retrace::verbosity >= 2) {
        std::cout << "arrayAPPLE " << _origResult << " -> " << arrays[_jGLuint156] << "\n";
    }
        }
    }
}

static void retrace_glVertexArrayRangeAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei length;
    length = (call.arg(0)).toSInt();

    GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayRangeAPPLE(length, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFlushVertexArrayRangeAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei length;
    length = (call.arg(0)).toSInt();

    GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlushVertexArrayRangeAPPLE(length, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayParameteriAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayParameteriAPPLE(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFlushRenderAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlushRenderAPPLE();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFinishRenderAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFinishRenderAPPLE();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSwapAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSwapAPPLE();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawBuffersATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLenum * bufs;
    bufs = static_cast<GLenum *>(_allocator.alloc(&call.arg(1), sizeof *bufs));
    if (bufs) {
        const trace::Array *_a_GLenum16_0 = (call.arg(1)).toArray();
        for (size_t _jGLenum16 = 0; _jGLenum16 < _a_GLenum16_0->values.size(); ++_jGLenum16) {
    bufs[_jGLenum16] = static_cast<GLenum>((*_a_GLenum16_0->values[_jGLenum16]).toSInt());
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawBuffersATI(n, bufs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramNamedParameter4fNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(id) << " <- " << size_t(_programARB_map[id]) << "\n";
    }
    id = _programARB_map[id];

    GLsizei len;
    len = (call.arg(1)).toSInt();

    const GLubyte * name;
    name = (const GLubyte *)((call.arg(2)).toString());

    GLfloat x;
    x = (call.arg(3)).toFloat();

    GLfloat y;
    y = (call.arg(4)).toFloat();

    GLfloat z;
    z = (call.arg(5)).toFloat();

    GLfloat w;
    w = (call.arg(6)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramNamedParameter4dNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(id) << " <- " << size_t(_programARB_map[id]) << "\n";
    }
    id = _programARB_map[id];

    GLsizei len;
    len = (call.arg(1)).toSInt();

    const GLubyte * name;
    name = (const GLubyte *)((call.arg(2)).toString());

    GLdouble x;
    x = (call.arg(3)).toDouble();

    GLdouble y;
    y = (call.arg(4)).toDouble();

    GLdouble z;
    z = (call.arg(5)).toDouble();

    GLdouble w;
    w = (call.arg(6)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramNamedParameter4fvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(id) << " <- " << size_t(_programARB_map[id]) << "\n";
    }
    id = _programARB_map[id];

    GLsizei len;
    len = (call.arg(1)).toSInt();

    const GLubyte * name;
    name = (const GLubyte *)((call.arg(2)).toString());

    GLfloat * v;
    v = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *v));
    if (v) {
        const trace::Array *_a_GLfloat271_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat271 = 0; _jGLfloat271 < _a_GLfloat271_0->values.size(); ++_jGLfloat271) {
    v[_jGLfloat271] = (*_a_GLfloat271_0->values[_jGLfloat271]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramNamedParameter4fvNV(id, len, name, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramNamedParameter4dvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "programARB " << size_t(id) << " <- " << size_t(_programARB_map[id]) << "\n";
    }
    id = _programARB_map[id];

    GLsizei len;
    len = (call.arg(1)).toSInt();

    const GLubyte * name;
    name = (const GLubyte *)((call.arg(2)).toString());

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble119_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble119 = 0; _jGLdouble119 < _a_GLdouble119_0->values.size(); ++_jGLdouble119) {
    v[_jGLdouble119] = (*_a_GLdouble119_0->values[_jGLdouble119]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramNamedParameter4dvNV(id, len, name, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV x;
    x = (call.arg(0)).toUInt();

    GLhalfNV y;
    y = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2hNV(x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex2hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV1_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV1 = 0; _jGLhalfNV1 < _a_GLhalfNV1_0->values.size(); ++_jGLhalfNV1) {
    v[_jGLhalfNV1] = (*_a_GLhalfNV1_0->values[_jGLhalfNV1]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex2hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV x;
    x = (call.arg(0)).toUInt();

    GLhalfNV y;
    y = (call.arg(1)).toUInt();

    GLhalfNV z;
    z = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3hNV(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex3hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV2_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV2 = 0; _jGLhalfNV2 < _a_GLhalfNV2_0->values.size(); ++_jGLhalfNV2) {
    v[_jGLhalfNV2] = (*_a_GLhalfNV2_0->values[_jGLhalfNV2]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex3hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV x;
    x = (call.arg(0)).toUInt();

    GLhalfNV y;
    y = (call.arg(1)).toUInt();

    GLhalfNV z;
    z = (call.arg(2)).toUInt();

    GLhalfNV w;
    w = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4hNV(x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertex4hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV3_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV3 = 0; _jGLhalfNV3 < _a_GLhalfNV3_0->values.size(); ++_jGLhalfNV3) {
    v[_jGLhalfNV3] = (*_a_GLhalfNV3_0->values[_jGLhalfNV3]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertex4hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV nx;
    nx = (call.arg(0)).toUInt();

    GLhalfNV ny;
    ny = (call.arg(1)).toUInt();

    GLhalfNV nz;
    nz = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3hNV(nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV4_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV4 = 0; _jGLhalfNV4 < _a_GLhalfNV4_0->values.size(); ++_jGLhalfNV4) {
    v[_jGLhalfNV4] = (*_a_GLhalfNV4_0->values[_jGLhalfNV4]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV red;
    red = (call.arg(0)).toUInt();

    GLhalfNV green;
    green = (call.arg(1)).toUInt();

    GLhalfNV blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3hNV(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor3hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV5_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV5 = 0; _jGLhalfNV5 < _a_GLhalfNV5_0->values.size(); ++_jGLhalfNV5) {
    v[_jGLhalfNV5] = (*_a_GLhalfNV5_0->values[_jGLhalfNV5]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor3hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV red;
    red = (call.arg(0)).toUInt();

    GLhalfNV green;
    green = (call.arg(1)).toUInt();

    GLhalfNV blue;
    blue = (call.arg(2)).toUInt();

    GLhalfNV alpha;
    alpha = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4hNV(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV6_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV6 = 0; _jGLhalfNV6 < _a_GLhalfNV6_0->values.size(); ++_jGLhalfNV6) {
    v[_jGLhalfNV6] = (*_a_GLhalfNV6_0->values[_jGLhalfNV6]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV s;
    s = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1hNV(s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord1hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLhalfNV_0 = (call.arg(0)).toArray();
    v[0] = (*_a_PGLhalfNV_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord1hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV s;
    s = (call.arg(0)).toUInt();

    GLhalfNV t;
    t = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2hNV(s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord2hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV7_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV7 = 0; _jGLhalfNV7 < _a_GLhalfNV7_0->values.size(); ++_jGLhalfNV7) {
    v[_jGLhalfNV7] = (*_a_GLhalfNV7_0->values[_jGLhalfNV7]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord2hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV s;
    s = (call.arg(0)).toUInt();

    GLhalfNV t;
    t = (call.arg(1)).toUInt();

    GLhalfNV r;
    r = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3hNV(s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord3hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV8_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV8 = 0; _jGLhalfNV8 < _a_GLhalfNV8_0->values.size(); ++_jGLhalfNV8) {
    v[_jGLhalfNV8] = (*_a_GLhalfNV8_0->values[_jGLhalfNV8]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord3hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV s;
    s = (call.arg(0)).toUInt();

    GLhalfNV t;
    t = (call.arg(1)).toUInt();

    GLhalfNV r;
    r = (call.arg(2)).toUInt();

    GLhalfNV q;
    q = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4hNV(s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoord4hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV9_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV9 = 0; _jGLhalfNV9 < _a_GLhalfNV9_0->values.size(); ++_jGLhalfNV9) {
    v[_jGLhalfNV9] = (*_a_GLhalfNV9_0->values[_jGLhalfNV9]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoord4hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhalfNV s;
    s = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1hNV(target, s);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord1hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLhalfNV1_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLhalfNV1_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord1hvNV(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhalfNV s;
    s = (call.arg(1)).toUInt();

    GLhalfNV t;
    t = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2hNV(target, s, t);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord2hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV10_0 = (call.arg(1)).toArray();
        for (size_t _jGLhalfNV10 = 0; _jGLhalfNV10 < _a_GLhalfNV10_0->values.size(); ++_jGLhalfNV10) {
    v[_jGLhalfNV10] = (*_a_GLhalfNV10_0->values[_jGLhalfNV10]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord2hvNV(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhalfNV s;
    s = (call.arg(1)).toUInt();

    GLhalfNV t;
    t = (call.arg(2)).toUInt();

    GLhalfNV r;
    r = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3hNV(target, s, t, r);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord3hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV11_0 = (call.arg(1)).toArray();
        for (size_t _jGLhalfNV11 = 0; _jGLhalfNV11 < _a_GLhalfNV11_0->values.size(); ++_jGLhalfNV11) {
    v[_jGLhalfNV11] = (*_a_GLhalfNV11_0->values[_jGLhalfNV11]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord3hvNV(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhalfNV s;
    s = (call.arg(1)).toUInt();

    GLhalfNV t;
    t = (call.arg(2)).toUInt();

    GLhalfNV r;
    r = (call.arg(3)).toUInt();

    GLhalfNV q;
    q = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4hNV(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV12_0 = (call.arg(1)).toArray();
        for (size_t _jGLhalfNV12 = 0; _jGLhalfNV12 < _a_GLhalfNV12_0->values.size(); ++_jGLhalfNV12) {
    v[_jGLhalfNV12] = (*_a_GLhalfNV12_0->values[_jGLhalfNV12]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4hvNV(target, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordhNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV fog;
    fog = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordhNV(fog);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordhvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * fog;
    fog = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *fog));
    if (fog) {
        const trace::Array *_a_PGLhalfNV2_0 = (call.arg(0)).toArray();
    fog[0] = (*_a_PGLhalfNV2_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordhvNV(fog);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV red;
    red = (call.arg(0)).toUInt();

    GLhalfNV green;
    green = (call.arg(1)).toUInt();

    GLhalfNV blue;
    blue = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3hNV(red, green, blue);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColor3hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV13_0 = (call.arg(0)).toArray();
        for (size_t _jGLhalfNV13 = 0; _jGLhalfNV13 < _a_GLhalfNV13_0->values.size(); ++_jGLhalfNV13) {
    v[_jGLhalfNV13] = (*_a_GLhalfNV13_0->values[_jGLhalfNV13]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColor3hvNV(v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexWeighthNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV weight;
    weight = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexWeighthNV(weight);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexWeighthvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLhalfNV * weight;
    weight = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(0), sizeof *weight));
    if (weight) {
        const trace::Array *_a_PGLhalfNV3_0 = (call.arg(0)).toArray();
    weight[0] = (*_a_PGLhalfNV3_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexWeighthvNV(weight);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLhalfNV x;
    x = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1hNV(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib1hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLhalfNV4_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLhalfNV4_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib1hvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLhalfNV x;
    x = (call.arg(1)).toUInt();

    GLhalfNV y;
    y = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2hNV(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib2hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV14_0 = (call.arg(1)).toArray();
        for (size_t _jGLhalfNV14 = 0; _jGLhalfNV14 < _a_GLhalfNV14_0->values.size(); ++_jGLhalfNV14) {
    v[_jGLhalfNV14] = (*_a_GLhalfNV14_0->values[_jGLhalfNV14]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib2hvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLhalfNV x;
    x = (call.arg(1)).toUInt();

    GLhalfNV y;
    y = (call.arg(2)).toUInt();

    GLhalfNV z;
    z = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3hNV(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib3hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV15_0 = (call.arg(1)).toArray();
        for (size_t _jGLhalfNV15 = 0; _jGLhalfNV15 < _a_GLhalfNV15_0->values.size(); ++_jGLhalfNV15) {
    v[_jGLhalfNV15] = (*_a_GLhalfNV15_0->values[_jGLhalfNV15]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib3hvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4hNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLhalfNV x;
    x = (call.arg(1)).toUInt();

    GLhalfNV y;
    y = (call.arg(2)).toUInt();

    GLhalfNV z;
    z = (call.arg(3)).toUInt();

    GLhalfNV w;
    w = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4hNV(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttrib4hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV16_0 = (call.arg(1)).toArray();
        for (size_t _jGLhalfNV16 = 0; _jGLhalfNV16 < _a_GLhalfNV16_0->values.size(); ++_jGLhalfNV16) {
    v[_jGLhalfNV16] = (*_a_GLhalfNV16_0->values[_jGLhalfNV16]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttrib4hvNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs1hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei n;
    n = (call.arg(1)).toSInt();

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV17_0 = (call.arg(2)).toArray();
        for (size_t _jGLhalfNV17 = 0; _jGLhalfNV17 < _a_GLhalfNV17_0->values.size(); ++_jGLhalfNV17) {
    v[_jGLhalfNV17] = (*_a_GLhalfNV17_0->values[_jGLhalfNV17]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs1hvNV(index, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs2hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei n;
    n = (call.arg(1)).toSInt();

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV18_0 = (call.arg(2)).toArray();
        for (size_t _jGLhalfNV18 = 0; _jGLhalfNV18 < _a_GLhalfNV18_0->values.size(); ++_jGLhalfNV18) {
    v[_jGLhalfNV18] = (*_a_GLhalfNV18_0->values[_jGLhalfNV18]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs2hvNV(index, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs3hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei n;
    n = (call.arg(1)).toSInt();

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV19_0 = (call.arg(2)).toArray();
        for (size_t _jGLhalfNV19 = 0; _jGLhalfNV19 < _a_GLhalfNV19_0->values.size(); ++_jGLhalfNV19) {
    v[_jGLhalfNV19] = (*_a_GLhalfNV19_0->values[_jGLhalfNV19]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs3hvNV(index, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribs4hvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLsizei n;
    n = (call.arg(1)).toSInt();

    GLhalfNV * v;
    v = static_cast<GLhalfNV *>(_allocator.alloc(&call.arg(2), sizeof *v));
    if (v) {
        const trace::Array *_a_GLhalfNV20_0 = (call.arg(2)).toArray();
        for (size_t _jGLhalfNV20 = 0; _jGLhalfNV20 < _a_GLhalfNV20_0->values.size(); ++_jGLhalfNV20) {
    v[_jGLhalfNV20] = (*_a_GLhalfNV20_0->values[_jGLhalfNV20]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribs4hvNV(index, n, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPixelDataRangeNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei length;
    length = (call.arg(1)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPixelDataRangeNV(target, length, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFlushPixelDataRangeNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlushPixelDataRangeNV(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPrimitiveRestartNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPrimitiveRestartNV();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPrimitiveRestartIndexNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPrimitiveRestartIndexNV(index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapObjectBufferATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLvoid * _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glMapObjectBufferATI(buffer);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to map buffer\n";
        }
    }
    GLint length = 0;
    glGetObjectBufferivATI(buffer, GL_OBJECT_BUFFER_SIZE_ATI, &length);
    retrace::addRegion((*call.ret).toUIntPtr(), _result, length);
}

static void retrace_glUnmapObjectBufferATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
        GLvoid *ptr = NULL;
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "no current context\n";
        }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUnmapObjectBufferATI(buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilOpSeparateATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum sfail;
    sfail = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum dpfail;
    dpfail = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum dppass;
    dppass = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilOpSeparateATI(face, sfail, dpfail, dppass);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStencilFuncSeparateATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum frontfunc;
    frontfunc = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum backfunc;
    backfunc = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint ref;
    ref = (call.arg(2)).toSInt();

    GLuint mask;
    mask = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribArrayObjectATI(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    GLuint buffer;
    buffer = (call.arg(5)).toUInt();

    GLuint offset;
    offset = (call.arg(6)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthBoundsEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLclampd zmin;
    zmin = (call.arg(0)).toDouble();

    GLclampd zmax;
    zmax = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthBoundsEXT(zmin, zmax);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationSeparateEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum modeRGB;
    modeRGB = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum modeAlpha;
    modeAlpha = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationSeparateEXT(modeRGB, modeAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindRenderbufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindRenderbufferEXT(target, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteRenderbuffersEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * renderbuffers;
    renderbuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *renderbuffers));
    if (renderbuffers) {
        const trace::Array *_a_GLuint157_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint157 = 0; _jGLuint157 < _a_GLuint157_0->values.size(); ++_jGLuint157) {
    renderbuffers[_jGLuint157] = (*_a_GLuint157_0->values[_jGLuint157]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffers[_jGLuint157]) << " <- " << size_t(_renderbuffer_map[renderbuffers[_jGLuint157]]) << "\n";
    }
    renderbuffers[_jGLuint157] = _renderbuffer_map[renderbuffers[_jGLuint157]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteRenderbuffersEXT(n, renderbuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenRenderbuffersEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * renderbuffers;
    renderbuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *renderbuffers));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenRenderbuffersEXT(n, renderbuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint159 = (call.arg(1)).toArray();
    if (_aGLuint159) {
        for (size_t _jGLuint159 = 0; _jGLuint159 < _aGLuint159->values.size(); ++_jGLuint159) {
    GLuint _origResult;
    _origResult = (*_aGLuint159->values[_jGLuint159]).toUInt();
    _renderbuffer_map[_origResult] = renderbuffers[_jGLuint159];
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << _origResult << " -> " << renderbuffers[_jGLuint159] << "\n";
    }
        }
    }
}

static void retrace_glRenderbufferStorageEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorageEXT(target, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindFramebufferEXT(trace::Call &call) {
    assert(call.flags & trace::CALL_FLAG_SWAP_RENDERTARGET);
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint framebuffer;
    framebuffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindFramebufferEXT(target, framebuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteFramebuffersEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * framebuffers;
    framebuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *framebuffers));
    if (framebuffers) {
        const trace::Array *_a_GLuint160_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint160 = 0; _jGLuint160 < _a_GLuint160_0->values.size(); ++_jGLuint160) {
    framebuffers[_jGLuint160] = (*_a_GLuint160_0->values[_jGLuint160]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffers[_jGLuint160]) << " <- " << size_t(_framebuffer_map[framebuffers[_jGLuint160]]) << "\n";
    }
    framebuffers[_jGLuint160] = _framebuffer_map[framebuffers[_jGLuint160]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteFramebuffersEXT(n, framebuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenFramebuffersEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * framebuffers;
    framebuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *framebuffers));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenFramebuffersEXT(n, framebuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint162 = (call.arg(1)).toArray();
    if (_aGLuint162) {
        for (size_t _jGLuint162 = 0; _jGLuint162 < _aGLuint162->values.size(); ++_jGLuint162) {
    GLuint _origResult;
    _origResult = (*_aGLuint162->values[_jGLuint162]).toUInt();
    _framebuffer_map[_origResult] = framebuffers[_jGLuint162];
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << _origResult << " -> " << framebuffers[_jGLuint162] << "\n";
    }
        }
    }
}

static void retrace_glCheckFramebufferStatusEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCheckFramebufferStatusEXT(target);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    GLint _origResult = call.ret->toSInt();
    if (_origResult == GL_FRAMEBUFFER_COMPLETE &&
        _result != GL_FRAMEBUFFER_COMPLETE) {
        retrace::warning(call) << "incomplete framebuffer (" << glstate::enumToString(_result) << ")\n";
    }
    }
}

static void retrace_glFramebufferTexture1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferRenderbufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum renderbuffertarget;
    renderbuffertarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenerateMipmapEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenerateMipmapEXT(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glStringMarkerGREMEDY(trace::Call &call) {
}

static void retrace_glStencilClearTagEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei stencilTagBits;
    stencilTagBits = (call.arg(0)).toSInt();

    GLuint stencilClearTag;
    stencilClearTag = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilClearTagEXT(stencilTagBits, stencilClearTag);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlitFramebufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint srcX0;
    srcX0 = (call.arg(0)).toSInt();

    GLint srcY0;
    srcY0 = (call.arg(1)).toSInt();

    GLint srcX1;
    srcX1 = (call.arg(2)).toSInt();

    GLint srcY1;
    srcY1 = (call.arg(3)).toSInt();

    GLint dstX0;
    dstX0 = (call.arg(4)).toSInt();

    GLint dstY0;
    dstY0 = (call.arg(5)).toSInt();

    GLint dstX1;
    dstX1 = (call.arg(6)).toSInt();

    GLint dstY1;
    dstY1 = (call.arg(7)).toSInt();

    GLbitfield mask;
    mask = (call.arg(8)).toUInt();

    GLenum filter;
    filter = static_cast<GLenum>((call.arg(9)).toSInt());

    glretrace::updateDrawable(std::max(dstX0, dstX1), std::max(dstY0, dstY1));
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glRenderbufferStorageMultisampleEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParameters4fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat272_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat272 = 0; _jGLfloat272 < _a_GLfloat272_0->values.size(); ++_jGLfloat272) {
    params[_jGLfloat272] = (*_a_GLfloat272_0->values[_jGLfloat272]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameters4fvEXT(target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameters4fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat273_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat273 = 0; _jGLfloat273 < _a_GLfloat273_0->values.size(); ++_jGLfloat273) {
    params[_jGLfloat273] = (*_a_GLfloat273_0->values[_jGLfloat273]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameters4fvEXT(target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBufferParameteriAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBufferParameteriAPPLE(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFlushMappedBufferRangeAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLintptr offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptr size;
    size = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlushMappedBufferRangeAPPLE(target, offset, size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameterI4iNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLint z;
    z = (call.arg(4)).toSInt();

    GLint w;
    w = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameterI4iNV(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameterI4ivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint203_0 = (call.arg(2)).toArray();
        for (size_t _jGLint203 = 0; _jGLint203 < _a_GLint203_0->values.size(); ++_jGLint203) {
    params[_jGLint203] = (*_a_GLint203_0->values[_jGLint203]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameterI4ivNV(target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParametersI4ivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint204_0 = (call.arg(3)).toArray();
        for (size_t _jGLint204 = 0; _jGLint204 < _a_GLint204_0->values.size(); ++_jGLint204) {
    params[_jGLint204] = (*_a_GLint204_0->values[_jGLint204]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParametersI4ivNV(target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameterI4uiNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint x;
    x = (call.arg(2)).toUInt();

    GLuint y;
    y = (call.arg(3)).toUInt();

    GLuint z;
    z = (call.arg(4)).toUInt();

    GLuint w;
    w = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParameterI4uivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint163_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint163 = 0; _jGLuint163 < _a_GLuint163_0->values.size(); ++_jGLuint163) {
    params[_jGLuint163] = (*_a_GLuint163_0->values[_jGLuint163]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParameterI4uivNV(target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramLocalParametersI4uivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint164_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint164 = 0; _jGLuint164 < _a_GLuint164_0->values.size(); ++_jGLuint164) {
    params[_jGLuint164] = (*_a_GLuint164_0->values[_jGLuint164]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramLocalParametersI4uivNV(target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParameterI4iNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLint x;
    x = (call.arg(2)).toSInt();

    GLint y;
    y = (call.arg(3)).toSInt();

    GLint z;
    z = (call.arg(4)).toSInt();

    GLint w;
    w = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameterI4iNV(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParameterI4ivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint205_0 = (call.arg(2)).toArray();
        for (size_t _jGLint205 = 0; _jGLint205 < _a_GLint205_0->values.size(); ++_jGLint205) {
    params[_jGLint205] = (*_a_GLint205_0->values[_jGLint205]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameterI4ivNV(target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParametersI4ivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint206_0 = (call.arg(3)).toArray();
        for (size_t _jGLint206 = 0; _jGLint206 < _a_GLint206_0->values.size(); ++_jGLint206) {
    params[_jGLint206] = (*_a_GLint206_0->values[_jGLint206]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParametersI4ivNV(target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParameterI4uiNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint x;
    x = (call.arg(2)).toUInt();

    GLuint y;
    y = (call.arg(3)).toUInt();

    GLuint z;
    z = (call.arg(4)).toUInt();

    GLuint w;
    w = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParameterI4uivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint165_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint165 = 0; _jGLuint165 < _a_GLuint165_0->values.size(); ++_jGLuint165) {
    params[_jGLuint165] = (*_a_GLuint165_0->values[_jGLuint165]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParameterI4uivNV(target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramEnvParametersI4uivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint166_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint166 = 0; _jGLuint166 < _a_GLuint166_0->values.size(); ++_jGLuint166) {
    params[_jGLuint166] = (*_a_GLuint166_0->values[_jGLuint166]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramEnvParametersI4uivNV(target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramVertexLimitNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint limit;
    limit = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramVertexLimitNV(target, limit);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTextureEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTextureEXT(target, attachment, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTextureLayerEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    GLint layer;
    layer = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTextureFaceEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    GLenum face;
    face = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramParameteriEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint value;
    value = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramParameteriEXT(program, pname, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI1iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI1iEXT(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI2iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI2iEXT(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI3iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    GLint z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI3iEXT(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    GLint z;
    z = (call.arg(3)).toSInt();

    GLint w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4iEXT(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI1uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint x;
    x = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI1uiEXT(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI2uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint x;
    x = (call.arg(1)).toUInt();

    GLuint y;
    y = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI2uiEXT(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI3uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint x;
    x = (call.arg(1)).toUInt();

    GLuint y;
    y = (call.arg(2)).toUInt();

    GLuint z;
    z = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI3uiEXT(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint x;
    x = (call.arg(1)).toUInt();

    GLuint y;
    y = (call.arg(2)).toUInt();

    GLuint z;
    z = (call.arg(3)).toUInt();

    GLuint w;
    w = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4uiEXT(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI1ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLint31_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLint31_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI1ivEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI2ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint207_0 = (call.arg(1)).toArray();
        for (size_t _jGLint207 = 0; _jGLint207 < _a_GLint207_0->values.size(); ++_jGLint207) {
    v[_jGLint207] = (*_a_GLint207_0->values[_jGLint207]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI2ivEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI3ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint208_0 = (call.arg(1)).toArray();
        for (size_t _jGLint208 = 0; _jGLint208 < _a_GLint208_0->values.size(); ++_jGLint208) {
    v[_jGLint208] = (*_a_GLint208_0->values[_jGLint208]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI3ivEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint * v;
    v = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint209_0 = (call.arg(1)).toArray();
        for (size_t _jGLint209 = 0; _jGLint209 < _a_GLint209_0->values.size(); ++_jGLint209) {
    v[_jGLint209] = (*_a_GLint209_0->values[_jGLint209]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4ivEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI1uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLuint55_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLuint55_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI1uivEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI2uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint167_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint167 = 0; _jGLuint167 < _a_GLuint167_0->values.size(); ++_jGLuint167) {
    v[_jGLuint167] = (*_a_GLuint167_0->values[_jGLuint167]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI2uivEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI3uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint168_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint168 = 0; _jGLuint168 < _a_GLuint168_0->values.size(); ++_jGLuint168) {
    v[_jGLuint168] = (*_a_GLuint168_0->values[_jGLuint168]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI3uivEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint * v;
    v = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint169_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint169 = 0; _jGLuint169 < _a_GLuint169_0->values.size(); ++_jGLuint169) {
    v[_jGLuint169] = (*_a_GLuint169_0->values[_jGLuint169]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4uivEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4bvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLbyte * v;
    v = static_cast<GLbyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLbyte15_0 = (call.arg(1)).toArray();
        for (size_t _jGLbyte15 = 0; _jGLbyte15 < _a_GLbyte15_0->values.size(); ++_jGLbyte15) {
    v[_jGLbyte15] = (*_a_GLbyte15_0->values[_jGLbyte15]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4bvEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4svEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLshort * v;
    v = static_cast<GLshort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLshort53_0 = (call.arg(1)).toArray();
        for (size_t _jGLshort53 = 0; _jGLshort53 < _a_GLshort53_0->values.size(); ++_jGLshort53) {
    v[_jGLshort53] = (*_a_GLshort53_0->values[_jGLshort53]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4svEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4ubvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLubyte * v;
    v = static_cast<GLubyte *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLubyte25_0 = (call.arg(1)).toArray();
        for (size_t _jGLubyte25 = 0; _jGLubyte25 < _a_GLubyte25_0->values.size(); ++_jGLubyte25) {
    v[_jGLubyte25] = (*_a_GLubyte25_0->values[_jGLubyte25]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4ubvEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribI4usvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLushort * v;
    v = static_cast<GLushort *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLushort16_0 = (call.arg(1)).toArray();
        for (size_t _jGLushort16 = 0; _jGLushort16 < _a_GLushort16_0->values.size(); ++_jGLushort16) {
    v[_jGLushort16] = (*_a_GLushort16_0->values[_jGLushort16]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribI4usvEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribIPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    const GLvoid * pointer;
    pointer = static_cast<const GLvoid *>(retrace::toPointer(call.arg(4), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribIPointerEXT(index, size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindFragDataLocationEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLuint color;
    color = (call.arg(1)).toUInt();

    const GLchar * name;
    name = (const GLchar *)((call.arg(2)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindFragDataLocationEXT(program, color, name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetFragDataLocationEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    const GLchar * name;
    name = (const GLchar *)((call.arg(1)).toString());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetFragDataLocationEXT(program, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLint _origResult;
    _origResult = (*call.ret).toSInt();
    _location_map[program][_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "location " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glUniform1uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1uiEXT(location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(1)).toUInt();

    GLuint v1;
    v1 = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2uiEXT(location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(1)).toUInt();

    GLuint v1;
    v1 = (call.arg(2)).toUInt();

    GLuint v2;
    v2 = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3uiEXT(location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(1)).toUInt();

    GLuint v1;
    v1 = (call.arg(2)).toUInt();

    GLuint v2;
    v2 = (call.arg(3)).toUInt();

    GLuint v3;
    v3 = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4uiEXT(location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint170_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint170 = 0; _jGLuint170 < _a_GLuint170_0->values.size(); ++_jGLuint170) {
    value[_jGLuint170] = (*_a_GLuint170_0->values[_jGLuint170]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1uivEXT(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint171_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint171 = 0; _jGLuint171 < _a_GLuint171_0->values.size(); ++_jGLuint171) {
    value[_jGLuint171] = (*_a_GLuint171_0->values[_jGLuint171]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2uivEXT(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint172_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint172 = 0; _jGLuint172 < _a_GLuint172_0->values.size(); ++_jGLuint172) {
    value[_jGLuint172] = (*_a_GLuint172_0->values[_jGLuint172]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3uivEXT(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint173_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint173 = 0; _jGLuint173 < _a_GLuint173_0->values.size(); ++_jGLuint173) {
    value[_jGLuint173] = (*_a_GLuint173_0->values[_jGLuint173]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4uivEXT(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawArraysInstancedEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint start;
    start = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawArraysInstancedEXT(mode, start, count, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glDrawElementsInstancedEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    const GLvoid * indices;
    indices = static_cast<const GLvoid *>((call.arg(3)).toPointer());

    GLsizei primcount;
    primcount = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glDrawElementsInstancedEXT(mode, count, type, indices, primcount);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glTexBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexBufferEXT(target, internalformat, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthRangedNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble zNear;
    zNear = (call.arg(0)).toDouble();

    GLdouble zFar;
    zFar = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthRangedNV(zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearDepthdNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble depth;
    depth = (call.arg(0)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearDepthdNV(depth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthBoundsdNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLdouble zmin;
    zmin = (call.arg(0)).toDouble();

    GLdouble zmax;
    zmax = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthBoundsdNV(zmin, zmax);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRenderbufferStorageMultisampleCoverageNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei coverageSamples;
    coverageSamples = (call.arg(1)).toSInt();

    GLsizei colorSamples;
    colorSamples = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramBufferParametersfvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat274_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat274 = 0; _jGLfloat274 < _a_GLfloat274_0->values.size(); ++_jGLfloat274) {
    params[_jGLfloat274] = (*_a_GLfloat274_0->values[_jGLfloat274]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramBufferParametersfvNV(target, buffer, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramBufferParametersIivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(4), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint210_0 = (call.arg(4)).toArray();
        for (size_t _jGLint210 = 0; _jGLint210 < _a_GLint210_0->values.size(); ++_jGLint210) {
    params[_jGLint210] = (*_a_GLint210_0->values[_jGLint210]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramBufferParametersIivNV(target, buffer, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramBufferParametersIuivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(4), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint174_0 = (call.arg(4)).toArray();
        for (size_t _jGLuint174 = 0; _jGLuint174 < _a_GLuint174_0->values.size(); ++_jGLuint174) {
    params[_jGLuint174] = (*_a_GLuint174_0->values[_jGLuint174]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramBufferParametersIuivNV(target, buffer, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorMaskIndexedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLboolean r;
    r = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLboolean g;
    g = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLboolean b;
    b = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLboolean a;
    a = static_cast<GLboolean>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorMaskIndexedEXT(index, r, g, b, a);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableIndexedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableIndexedEXT(target, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableIndexedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableIndexedEXT(target, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginTransformFeedbackNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum primitiveMode;
    primitiveMode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginTransformFeedbackNV(primitiveMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndTransformFeedbackNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndTransformFeedbackNV();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTransformFeedbackAttribsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint count;
    count = (call.arg(0)).toUInt();

    GLint * attribs;
    attribs = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *attribs));
    if (attribs) {
        const trace::Array *_a_GLint211_0 = (call.arg(1)).toArray();
        for (size_t _jGLint211 = 0; _jGLint211 < _a_GLint211_0->values.size(); ++_jGLint211) {
    attribs[_jGLint211] = (*_a_GLint211_0->values[_jGLint211]).toSInt();
        }
    }

    GLenum bufferMode;
    bufferMode = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTransformFeedbackAttribsNV(count, attribs, bufferMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferRangeNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(3)).toSInt();

    GLsizeiptr size;
    size = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferRangeNV(target, index, buffer, offset, size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferOffsetNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferOffsetNV(target, index, buffer, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferBaseNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferBaseNV(target, index, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTransformFeedbackVaryingsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint * locations;
    locations = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *locations));
    if (locations) {
        const trace::Array *_a_GLint212_0 = (call.arg(2)).toArray();
        for (size_t _jGLint212 = 0; _jGLint212 < _a_GLint212_0->values.size(); ++_jGLint212) {
    locations[_jGLint212] = (*_a_GLint212_0->values[_jGLint212]).toSInt();
        }
    }

    GLenum bufferMode;
    bufferMode = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glActiveVaryingNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    const GLchar * name;
    name = (const GLchar *)((call.arg(1)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glActiveVaryingNV(program, name);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetVaryingLocationNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    const GLchar * name;
    name = (const GLchar *)((call.arg(1)).toString());

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetVaryingLocationNV(program, name);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLint _origResult;
    _origResult = (*call.ret).toSInt();
    _location_map[program][_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "location " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glTransformFeedbackStreamAttribsNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei count;
    count = (call.arg(0)).toSInt();

    GLint * attribs;
    attribs = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *attribs));
    if (attribs) {
        const trace::Array *_a_GLint213_0 = (call.arg(1)).toArray();
        for (size_t _jGLint213 = 0; _jGLint213 < _a_GLint213_0->values.size(); ++_jGLint213) {
    attribs[_jGLint213] = (*_a_GLint213_0->values[_jGLint213]).toSInt();
        }
    }

    GLsizei nbuffers;
    nbuffers = (call.arg(2)).toSInt();

    GLint * bufstreams;
    bufstreams = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *bufstreams));
    if (bufstreams) {
        const trace::Array *_a_GLint214_0 = (call.arg(3)).toArray();
        for (size_t _jGLint214 = 0; _jGLint214 < _a_GLint214_0->values.size(); ++_jGLint214) {
    bufstreams[_jGLint214] = (*_a_GLint214_0->values[_jGLint214]).toSInt();
        }
    }

    GLenum bufferMode;
    bufferMode = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformBufferEXT(program, location, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetUniformBufferSizeEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetUniformBufferSizeEXT(program, location);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetUniformOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLintptr _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetUniformOffsetEXT(program, location);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameterIivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint215_0 = (call.arg(2)).toArray();
        for (size_t _jGLint215 = 0; _jGLint215 < _a_GLint215_0->values.size(); ++_jGLint215) {
    params[_jGLint215] = (*_a_GLint215_0->values[_jGLint215]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameterIivEXT(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameterIuivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint175_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint175 = 0; _jGLuint175 < _a_GLuint175_0->values.size(); ++_jGLuint175) {
    params[_jGLuint175] = (*_a_GLuint175_0->values[_jGLuint175]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameterIuivEXT(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearColorIiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint red;
    red = (call.arg(0)).toSInt();

    GLint green;
    green = (call.arg(1)).toSInt();

    GLint blue;
    blue = (call.arg(2)).toSInt();

    GLint alpha;
    alpha = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearColorIiEXT(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearColorIuiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint red;
    red = (call.arg(0)).toUInt();

    GLuint green;
    green = (call.arg(1)).toUInt();

    GLuint blue;
    blue = (call.arg(2)).toUInt();

    GLuint alpha;
    alpha = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearColorIuiEXT(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFrameTerminatorGREMEDY(trace::Call &call) {
    glretrace::frame_complete(call);
}

static void retrace_glBeginConditionalRenderNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(id) << " <- " << size_t(_query_map[id]) << "\n";
    }
    id = _query_map[id];

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginConditionalRenderNV(id, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndConditionalRenderNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndConditionalRenderNV();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPresentFrameKeyedNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_slot;
    video_slot = (call.arg(0)).toUInt();

    GLuint64EXT minPresentTime;
    minPresentTime = (call.arg(1)).toUInt();

    GLuint beginPresentTimeId;
    beginPresentTimeId = (call.arg(2)).toUInt();

    GLuint presentDurationId;
    presentDurationId = (call.arg(3)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum target0;
    target0 = static_cast<GLenum>((call.arg(5)).toSInt());

    GLuint fill0;
    fill0 = (call.arg(6)).toUInt();

    GLuint key0;
    key0 = (call.arg(7)).toUInt();

    GLenum target1;
    target1 = static_cast<GLenum>((call.arg(8)).toSInt());

    GLuint fill1;
    fill1 = (call.arg(9)).toUInt();

    GLuint key1;
    key1 = (call.arg(10)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPresentFrameDualFillNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_slot;
    video_slot = (call.arg(0)).toUInt();

    GLuint64EXT minPresentTime;
    minPresentTime = (call.arg(1)).toUInt();

    GLuint beginPresentTimeId;
    beginPresentTimeId = (call.arg(2)).toUInt();

    GLuint presentDurationId;
    presentDurationId = (call.arg(3)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLenum target0;
    target0 = static_cast<GLenum>((call.arg(5)).toSInt());

    GLuint fill0;
    fill0 = (call.arg(6)).toUInt();

    GLenum target1;
    target1 = static_cast<GLenum>((call.arg(7)).toSInt());

    GLuint fill1;
    fill1 = (call.arg(8)).toUInt();

    GLenum target2;
    target2 = static_cast<GLenum>((call.arg(9)).toSInt());

    GLuint fill2;
    fill2 = (call.arg(10)).toUInt();

    GLenum target3;
    target3 = static_cast<GLenum>((call.arg(11)).toSInt());

    GLuint fill3;
    fill3 = (call.arg(12)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginTransformFeedbackEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum primitiveMode;
    primitiveMode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginTransformFeedbackEXT(primitiveMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndTransformFeedbackEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndTransformFeedbackEXT();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferRangeEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(3)).toSInt();

    GLsizeiptr size;
    size = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferRangeEXT(target, index, buffer, offset, size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferOffsetEXT(target, index, buffer, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindBufferBaseEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint buffer;
    buffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindBufferBaseEXT(target, index, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTransformFeedbackVaryingsEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLsizei count;
    count = (call.arg(1)).toSInt();

    const GLchar * * varyings;
    varyings = static_cast<const GLchar * *>(_allocator.alloc(&call.arg(2), sizeof *varyings));
    if (varyings) {
        const trace::Array *_a_constGLchar16_0 = (call.arg(2)).toArray();
        for (size_t _jconstGLchar16 = 0; _jconstGLchar16 < _a_constGLchar16_0->values.size(); ++_jconstGLchar16) {
    varyings[_jconstGLchar16] = (const GLchar *)((*_a_constGLchar16_0->values[_jconstGLchar16]).toString());
        }
    }

    GLenum bufferMode;
    bufferMode = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClientAttribDefaultEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClientAttribDefaultEXT(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPushClientAttribDefaultEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield mask;
    mask = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPushClientAttribDefaultEXT(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixLoadfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat275_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat275 = 0; _jGLfloat275 < _a_GLfloat275_0->values.size(); ++_jGLfloat275) {
    m[_jGLfloat275] = (*_a_GLfloat275_0->values[_jGLfloat275]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixLoadfEXT(mode, m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixLoaddEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble120_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble120 = 0; _jGLdouble120 < _a_GLdouble120_0->values.size(); ++_jGLdouble120) {
    m[_jGLdouble120] = (*_a_GLdouble120_0->values[_jGLdouble120]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixLoaddEXT(mode, m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixMultfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat276_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat276 = 0; _jGLfloat276 < _a_GLfloat276_0->values.size(); ++_jGLfloat276) {
    m[_jGLfloat276] = (*_a_GLfloat276_0->values[_jGLfloat276]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixMultfEXT(mode, m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixMultdEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble121_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble121 = 0; _jGLdouble121 < _a_GLdouble121_0->values.size(); ++_jGLdouble121) {
    m[_jGLdouble121] = (*_a_GLdouble121_0->values[_jGLdouble121]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixMultdEXT(mode, m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixLoadIdentityEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixLoadIdentityEXT(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixRotatefEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat angle;
    angle = (call.arg(1)).toFloat();

    GLfloat x;
    x = (call.arg(2)).toFloat();

    GLfloat y;
    y = (call.arg(3)).toFloat();

    GLfloat z;
    z = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixRotatefEXT(mode, angle, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixRotatedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble angle;
    angle = (call.arg(1)).toDouble();

    GLdouble x;
    x = (call.arg(2)).toDouble();

    GLdouble y;
    y = (call.arg(3)).toDouble();

    GLdouble z;
    z = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixRotatedEXT(mode, angle, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixScalefEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixScalefEXT(mode, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixScaledEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixScaledEXT(mode, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixTranslatefEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat x;
    x = (call.arg(1)).toFloat();

    GLfloat y;
    y = (call.arg(2)).toFloat();

    GLfloat z;
    z = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixTranslatefEXT(mode, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixTranslatedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixTranslatedEXT(mode, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixFrustumEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble left;
    left = (call.arg(1)).toDouble();

    GLdouble right;
    right = (call.arg(2)).toDouble();

    GLdouble bottom;
    bottom = (call.arg(3)).toDouble();

    GLdouble top;
    top = (call.arg(4)).toDouble();

    GLdouble zNear;
    zNear = (call.arg(5)).toDouble();

    GLdouble zFar;
    zFar = (call.arg(6)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixOrthoEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble left;
    left = (call.arg(1)).toDouble();

    GLdouble right;
    right = (call.arg(2)).toDouble();

    GLdouble bottom;
    bottom = (call.arg(3)).toDouble();

    GLdouble top;
    top = (call.arg(4)).toDouble();

    GLdouble zNear;
    zNear = (call.arg(5)).toDouble();

    GLdouble zFar;
    zFar = (call.arg(6)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixPopEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixPopEXT(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixPushEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixPushEXT(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixLoadTransposefEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat277_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat277 = 0; _jGLfloat277 < _a_GLfloat277_0->values.size(); ++_jGLfloat277) {
    m[_jGLfloat277] = (*_a_GLfloat277_0->values[_jGLfloat277]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixLoadTransposefEXT(mode, m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixLoadTransposedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble122_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble122 = 0; _jGLdouble122 < _a_GLdouble122_0->values.size(); ++_jGLdouble122) {
    m[_jGLdouble122] = (*_a_GLdouble122_0->values[_jGLdouble122]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixLoadTransposedEXT(mode, m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixMultTransposefEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * m;
    m = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfloat278_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat278 = 0; _jGLfloat278 < _a_GLfloat278_0->values.size(); ++_jGLfloat278) {
    m[_jGLfloat278] = (*_a_GLfloat278_0->values[_jGLfloat278]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixMultTransposefEXT(mode, m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixMultTransposedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLdouble * m;
    m = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *m));
    if (m) {
        const trace::Array *_a_GLdouble123_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble123 = 0; _jGLdouble123 < _a_GLdouble123_0->values.size(); ++_jGLdouble123) {
    m[_jGLdouble123] = (*_a_GLdouble123_0->values[_jGLdouble123]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixMultTransposedEXT(mode, m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureParameterfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat param;
    param = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureParameterfEXT(texture, target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureParameterfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat279_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat279 = 0; _jGLfloat279 < _a_GLfloat279_0->values.size(); ++_jGLfloat279) {
    params[_jGLfloat279] = (*_a_GLfloat279_0->values[_jGLfloat279]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureParameterfvEXT(texture, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureParameteriEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint param;
    param = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureParameteriEXT(texture, target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureParameterivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint216_0 = (call.arg(3)).toArray();
        for (size_t _jGLint216 = 0; _jGLint216 < _a_GLint216_0->values.size(); ++_jGLint216) {
    params[_jGLint216] = (*_a_GLint216_0->values[_jGLint216]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureParameterivEXT(texture, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLint border;
    border = (call.arg(5)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(6)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(7)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(8)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureSubImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(5)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(6)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureSubImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(8)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTextureImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLint x;
    x = (call.arg(4)).toSInt();

    GLint y;
    y = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTextureImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLint x;
    x = (call.arg(4)).toSInt();

    GLint y;
    y = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    GLint border;
    border = (call.arg(8)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTextureSubImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint x;
    x = (call.arg(4)).toSInt();

    GLint y;
    y = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTextureSubImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLint x;
    x = (call.arg(5)).toSInt();

    GLint y;
    y = (call.arg(6)).toSInt();

    GLsizei width;
    width = (call.arg(7)).toSInt();

    GLsizei height;
    height = (call.arg(8)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetTextureImageEXT(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetTextureImageEXT(texture, target, level, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLsizei depth;
    depth = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(9)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(10)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureSubImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    GLsizei depth;
    depth = (call.arg(8)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(9)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(10)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(11)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTextureSubImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    GLint x;
    x = (call.arg(6)).toSInt();

    GLint y;
    y = (call.arg(7)).toSInt();

    GLsizei width;
    width = (call.arg(8)).toSInt();

    GLsizei height;
    height = (call.arg(9)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexParameterfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat param;
    param = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexParameterfEXT(texunit, target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexParameterfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat280_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat280 = 0; _jGLfloat280 < _a_GLfloat280_0->values.size(); ++_jGLfloat280) {
    params[_jGLfloat280] = (*_a_GLfloat280_0->values[_jGLfloat280]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexParameterfvEXT(texunit, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexParameteriEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint param;
    param = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexParameteriEXT(texunit, target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexParameterivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint217_0 = (call.arg(3)).toArray();
        for (size_t _jGLint217 = 0; _jGLint217 < _a_GLint217_0->values.size(); ++_jGLint217) {
    params[_jGLint217] = (*_a_GLint217_0->values[_jGLint217]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexParameterivEXT(texunit, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLint border;
    border = (call.arg(5)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(6)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(7)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(8)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexSubImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(5)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(6)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexSubImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(8)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyMultiTexImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLint x;
    x = (call.arg(4)).toSInt();

    GLint y;
    y = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyMultiTexImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLint x;
    x = (call.arg(4)).toSInt();

    GLint y;
    y = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    GLint border;
    border = (call.arg(8)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyMultiTexSubImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint x;
    x = (call.arg(4)).toSInt();

    GLint y;
    y = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyMultiTexSubImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLint x;
    x = (call.arg(5)).toSInt();

    GLint y;
    y = (call.arg(6)).toSInt();

    GLsizei width;
    width = (call.arg(7)).toSInt();

    GLsizei height;
    height = (call.arg(8)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetMultiTexImageEXT(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(5)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetMultiTexImageEXT(texunit, target, level, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLsizei depth;
    depth = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(9)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(10)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexSubImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    GLsizei depth;
    depth = (call.arg(8)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(9)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(10)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(11)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyMultiTexSubImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    GLint x;
    x = (call.arg(6)).toSInt();

    GLint y;
    y = (call.arg(7)).toSInt();

    GLsizei width;
    width = (call.arg(8)).toSInt();

    GLsizei height;
    height = (call.arg(9)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindMultiTextureEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindMultiTextureEXT(texunit, target, texture);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableClientStateIndexedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum array;
    array = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableClientStateIndexedEXT(array, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableClientStateIndexedEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum array;
    array = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableClientStateIndexedEXT(array, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableClientStateiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum array;
    array = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableClientStateiEXT(array, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableClientStateiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum array;
    array = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableClientStateiEXT(array, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoordPointerEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoordPointerEXT(texunit, size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexEnvfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat param;
    param = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexEnvfEXT(texunit, target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexEnvfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat281_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat281 = 0; _jGLfloat281 < _a_GLfloat281_0->values.size(); ++_jGLfloat281) {
    params[_jGLfloat281] = (*_a_GLfloat281_0->values[_jGLfloat281]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexEnvfvEXT(texunit, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexEnviEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint param;
    param = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexEnviEXT(texunit, target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexEnvivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint218_0 = (call.arg(3)).toArray();
        for (size_t _jGLint218 = 0; _jGLint218 < _a_GLint218_0->values.size(); ++_jGLint218) {
    params[_jGLint218] = (*_a_GLint218_0->values[_jGLint218]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexEnvivEXT(texunit, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexGendEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum coord;
    coord = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLdouble param;
    param = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexGendEXT(texunit, coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexGendvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum coord;
    coord = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLdouble * params;
    params = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLdouble124_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble124 = 0; _jGLdouble124 < _a_GLdouble124_0->values.size(); ++_jGLdouble124) {
    params[_jGLdouble124] = (*_a_GLdouble124_0->values[_jGLdouble124]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexGendvEXT(texunit, coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexGenfEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum coord;
    coord = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat param;
    param = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexGenfEXT(texunit, coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexGenfvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum coord;
    coord = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat282_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat282 = 0; _jGLfloat282 < _a_GLfloat282_0->values.size(); ++_jGLfloat282) {
    params[_jGLfloat282] = (*_a_GLfloat282_0->values[_jGLfloat282]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexGenfvEXT(texunit, coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexGeniEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum coord;
    coord = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint param;
    param = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexGeniEXT(texunit, coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexGenivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum coord;
    coord = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint219_0 = (call.arg(3)).toArray();
        for (size_t _jGLint219 = 0; _jGLint219 < _a_GLint219_0->values.size(); ++_jGLint219) {
    params[_jGLint219] = (*_a_GLint219_0->values[_jGLint219]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexGenivEXT(texunit, coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTextureImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLsizei depth;
    depth = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(8)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTextureImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(7)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTextureImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLint border;
    border = (call.arg(5)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(6)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTextureSubImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    GLsizei depth;
    depth = (call.arg(8)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(9)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(10)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(11)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTextureSubImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(8)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTextureSubImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(5)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(6)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetCompressedTextureImageEXT(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint lod;
    lod = (call.arg(2)).toSInt();

    GLvoid * img;
    img = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetCompressedTextureImageEXT(texture, target, lod, img);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedMultiTexImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLsizei depth;
    depth = (call.arg(6)).toSInt();

    GLint border;
    border = (call.arg(7)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(8)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedMultiTexImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(7)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedMultiTexImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLint border;
    border = (call.arg(5)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(6)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedMultiTexSubImage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    GLsizei width;
    width = (call.arg(6)).toSInt();

    GLsizei height;
    height = (call.arg(7)).toSInt();

    GLsizei depth;
    depth = (call.arg(8)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(9)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(10)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(11)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedMultiTexSubImage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(8)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedMultiTexSubImage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint level;
    level = (call.arg(2)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(5)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(6)).toSInt();

    GLvoid * bits;
    bits = static_cast<GLvoid *>((call.arg(7)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetCompressedMultiTexImageEXT(trace::Call &call) {
    GLint _pack_buffer = 0;
    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);
    if (!_pack_buffer) {
        return;
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint lod;
    lod = (call.arg(2)).toSInt();

    GLvoid * img;
    img = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGetCompressedMultiTexImageEXT(texunit, target, lod, img);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramStringEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum format;
    format = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei len;
    len = (call.arg(3)).toSInt();

    const GLvoid * string;
    string = (const GLvoid *)((call.arg(4)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramStringEXT(program, target, format, len, string);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameter4dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLdouble x;
    x = (call.arg(3)).toDouble();

    GLdouble y;
    y = (call.arg(4)).toDouble();

    GLdouble z;
    z = (call.arg(5)).toDouble();

    GLdouble w;
    w = (call.arg(6)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameter4dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLdouble * params;
    params = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLdouble125_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble125 = 0; _jGLdouble125 < _a_GLdouble125_0->values.size(); ++_jGLdouble125) {
    params[_jGLdouble125] = (*_a_GLdouble125_0->values[_jGLdouble125]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameter4dvEXT(program, target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameter4fEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLfloat x;
    x = (call.arg(3)).toFloat();

    GLfloat y;
    y = (call.arg(4)).toFloat();

    GLfloat z;
    z = (call.arg(5)).toFloat();

    GLfloat w;
    w = (call.arg(6)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameter4fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat283_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat283 = 0; _jGLfloat283 < _a_GLfloat283_0->values.size(); ++_jGLfloat283) {
    params[_jGLfloat283] = (*_a_GLfloat283_0->values[_jGLfloat283]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameter4fvEXT(program, target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameters4fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat284_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat284 = 0; _jGLfloat284 < _a_GLfloat284_0->values.size(); ++_jGLfloat284) {
    params[_jGLfloat284] = (*_a_GLfloat284_0->values[_jGLfloat284]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameters4fvEXT(program, target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameterI4iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLint x;
    x = (call.arg(3)).toSInt();

    GLint y;
    y = (call.arg(4)).toSInt();

    GLint z;
    z = (call.arg(5)).toSInt();

    GLint w;
    w = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameterI4ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint220_0 = (call.arg(3)).toArray();
        for (size_t _jGLint220 = 0; _jGLint220 < _a_GLint220_0->values.size(); ++_jGLint220) {
    params[_jGLint220] = (*_a_GLint220_0->values[_jGLint220]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameterI4ivEXT(program, target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParametersI4ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(4), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint221_0 = (call.arg(4)).toArray();
        for (size_t _jGLint221 = 0; _jGLint221 < _a_GLint221_0->values.size(); ++_jGLint221) {
    params[_jGLint221] = (*_a_GLint221_0->values[_jGLint221]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParametersI4ivEXT(program, target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameterI4uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLuint x;
    x = (call.arg(3)).toUInt();

    GLuint y;
    y = (call.arg(4)).toUInt();

    GLuint z;
    z = (call.arg(5)).toUInt();

    GLuint w;
    w = (call.arg(6)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParameterI4uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint176_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint176 = 0; _jGLuint176 < _a_GLuint176_0->values.size(); ++_jGLuint176) {
    params[_jGLuint176] = (*_a_GLuint176_0->values[_jGLuint176]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParameterI4uivEXT(program, target, index, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedProgramLocalParametersI4uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLsizei count;
    count = (call.arg(3)).toSInt();

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(4), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint177_0 = (call.arg(4)).toArray();
        for (size_t _jGLuint177 = 0; _jGLuint177 < _a_GLuint177_0->values.size(); ++_jGLuint177) {
    params[_jGLuint177] = (*_a_GLuint177_0->values[_jGLuint177]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedProgramLocalParametersI4uivEXT(program, target, index, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureParameterIivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint222_0 = (call.arg(3)).toArray();
        for (size_t _jGLint222 = 0; _jGLint222 < _a_GLint222_0->values.size(); ++_jGLint222) {
    params[_jGLint222] = (*_a_GLint222_0->values[_jGLint222]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureParameterIivEXT(texture, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureParameterIuivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint178_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint178 = 0; _jGLuint178 < _a_GLuint178_0->values.size(); ++_jGLuint178) {
    params[_jGLuint178] = (*_a_GLuint178_0->values[_jGLuint178]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureParameterIuivEXT(texture, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexParameterIivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint223_0 = (call.arg(3)).toArray();
        for (size_t _jGLint223 = 0; _jGLint223 < _a_GLint223_0->values.size(); ++_jGLint223) {
    params[_jGLint223] = (*_a_GLint223_0->values[_jGLint223]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexParameterIivEXT(texunit, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexParameterIuivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint179_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint179 = 0; _jGLuint179 < _a_GLuint179_0->values.size(); ++_jGLuint179) {
    params[_jGLuint179] = (*_a_GLuint179_0->values[_jGLuint179]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexParameterIuivEXT(texunit, target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1fEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1fEXT(program, location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2fEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(2)).toFloat();

    GLfloat v1;
    v1 = (call.arg(3)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2fEXT(program, location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3fEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(2)).toFloat();

    GLfloat v1;
    v1 = (call.arg(3)).toFloat();

    GLfloat v2;
    v2 = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3fEXT(program, location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4fEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLfloat v0;
    v0 = (call.arg(2)).toFloat();

    GLfloat v1;
    v1 = (call.arg(3)).toFloat();

    GLfloat v2;
    v2 = (call.arg(4)).toFloat();

    GLfloat v3;
    v3 = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1iEXT(program, location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(2)).toSInt();

    GLint v1;
    v1 = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2iEXT(program, location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(2)).toSInt();

    GLint v1;
    v1 = (call.arg(3)).toSInt();

    GLint v2;
    v2 = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3iEXT(program, location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4iEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLint v0;
    v0 = (call.arg(2)).toSInt();

    GLint v1;
    v1 = (call.arg(3)).toSInt();

    GLint v2;
    v2 = (call.arg(4)).toSInt();

    GLint v3;
    v3 = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat285_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat285 = 0; _jGLfloat285 < _a_GLfloat285_0->values.size(); ++_jGLfloat285) {
    value[_jGLfloat285] = (*_a_GLfloat285_0->values[_jGLfloat285]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1fvEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat286_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat286 = 0; _jGLfloat286 < _a_GLfloat286_0->values.size(); ++_jGLfloat286) {
    value[_jGLfloat286] = (*_a_GLfloat286_0->values[_jGLfloat286]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2fvEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat287_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat287 = 0; _jGLfloat287 < _a_GLfloat287_0->values.size(); ++_jGLfloat287) {
    value[_jGLfloat287] = (*_a_GLfloat287_0->values[_jGLfloat287]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3fvEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat288_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat288 = 0; _jGLfloat288 < _a_GLfloat288_0->values.size(); ++_jGLfloat288) {
    value[_jGLfloat288] = (*_a_GLfloat288_0->values[_jGLfloat288]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4fvEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint224_0 = (call.arg(3)).toArray();
        for (size_t _jGLint224 = 0; _jGLint224 < _a_GLint224_0->values.size(); ++_jGLint224) {
    value[_jGLint224] = (*_a_GLint224_0->values[_jGLint224]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1ivEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint225_0 = (call.arg(3)).toArray();
        for (size_t _jGLint225 = 0; _jGLint225 < _a_GLint225_0->values.size(); ++_jGLint225) {
    value[_jGLint225] = (*_a_GLint225_0->values[_jGLint225]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2ivEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint226_0 = (call.arg(3)).toArray();
        for (size_t _jGLint226 = 0; _jGLint226 < _a_GLint226_0->values.size(); ++_jGLint226) {
    value[_jGLint226] = (*_a_GLint226_0->values[_jGLint226]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3ivEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4ivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint * value;
    value = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint227_0 = (call.arg(3)).toArray();
        for (size_t _jGLint227 = 0; _jGLint227 < _a_GLint227_0->values.size(); ++_jGLint227) {
    value[_jGLint227] = (*_a_GLint227_0->values[_jGLint227]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4ivEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat289_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat289 = 0; _jGLfloat289 < _a_GLfloat289_0->values.size(); ++_jGLfloat289) {
    value[_jGLfloat289] = (*_a_GLfloat289_0->values[_jGLfloat289]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat290_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat290 = 0; _jGLfloat290 < _a_GLfloat290_0->values.size(); ++_jGLfloat290) {
    value[_jGLfloat290] = (*_a_GLfloat290_0->values[_jGLfloat290]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat291_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat291 = 0; _jGLfloat291 < _a_GLfloat291_0->values.size(); ++_jGLfloat291) {
    value[_jGLfloat291] = (*_a_GLfloat291_0->values[_jGLfloat291]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2x3fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat292_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat292 = 0; _jGLfloat292 < _a_GLfloat292_0->values.size(); ++_jGLfloat292) {
    value[_jGLfloat292] = (*_a_GLfloat292_0->values[_jGLfloat292]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3x2fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat293_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat293 = 0; _jGLfloat293 < _a_GLfloat293_0->values.size(); ++_jGLfloat293) {
    value[_jGLfloat293] = (*_a_GLfloat293_0->values[_jGLfloat293]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2x4fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat294_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat294 = 0; _jGLfloat294 < _a_GLfloat294_0->values.size(); ++_jGLfloat294) {
    value[_jGLfloat294] = (*_a_GLfloat294_0->values[_jGLfloat294]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4x2fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat295_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat295 = 0; _jGLfloat295 < _a_GLfloat295_0->values.size(); ++_jGLfloat295) {
    value[_jGLfloat295] = (*_a_GLfloat295_0->values[_jGLfloat295]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3x4fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat296_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat296 = 0; _jGLfloat296 < _a_GLfloat296_0->values.size(); ++_jGLfloat296) {
    value[_jGLfloat296] = (*_a_GLfloat296_0->values[_jGLfloat296]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4x3fvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLfloat * value;
    value = static_cast<GLfloat *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLfloat297_0 = (call.arg(4)).toArray();
        for (size_t _jGLfloat297 = 0; _jGLfloat297 < _a_GLfloat297_0->values.size(); ++_jGLfloat297) {
    value[_jGLfloat297] = (*_a_GLfloat297_0->values[_jGLfloat297]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1uiEXT(program, location, v0);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(2)).toUInt();

    GLuint v1;
    v1 = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2uiEXT(program, location, v0, v1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(2)).toUInt();

    GLuint v1;
    v1 = (call.arg(3)).toUInt();

    GLuint v2;
    v2 = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3uiEXT(program, location, v0, v1, v2);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4uiEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint v0;
    v0 = (call.arg(2)).toUInt();

    GLuint v1;
    v1 = (call.arg(3)).toUInt();

    GLuint v2;
    v2 = (call.arg(4)).toUInt();

    GLuint v3;
    v3 = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint180_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint180 = 0; _jGLuint180 < _a_GLuint180_0->values.size(); ++_jGLuint180) {
    value[_jGLuint180] = (*_a_GLuint180_0->values[_jGLuint180]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1uivEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint181_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint181 = 0; _jGLuint181 < _a_GLuint181_0->values.size(); ++_jGLuint181) {
    value[_jGLuint181] = (*_a_GLuint181_0->values[_jGLuint181]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2uivEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint182_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint182 = 0; _jGLuint182 < _a_GLuint182_0->values.size(); ++_jGLuint182) {
    value[_jGLuint182] = (*_a_GLuint182_0->values[_jGLuint182]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3uivEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4uivEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * value;
    value = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint183_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint183 = 0; _jGLuint183 < _a_GLuint183_0->values.size(); ++_jGLuint183) {
    value[_jGLuint183] = (*_a_GLuint183_0->values[_jGLuint183]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4uivEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedBufferDataEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLsizeiptr size;
    size = (call.arg(1)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLenum usage;
    usage = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedBufferDataEXT(buffer, size, data, usage);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedBufferSubDataEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptr size;
    size = (call.arg(2)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(3)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedBufferSubDataEXT(buffer, offset, size, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapNamedBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLenum access;
    access = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glMapNamedBufferEXT(buffer, access);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to map buffer\n";
        }
    }
    GLint length = 0;
    glGetNamedBufferParameterivEXT(buffer, GL_BUFFER_SIZE, &length);
    retrace::addRegion((*call.ret).toUIntPtr(), _result, length);
}

static void retrace_glUnmapNamedBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLboolean _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
        GLvoid *ptr = NULL;
            glGetNamedBufferPointervEXT(buffer, GL_BUFFER_MAP_POINTER, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "no current context\n";
        }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glUnmapNamedBufferEXT(buffer);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to unmap buffer\n";
        }
    }
}

static void retrace_glMapNamedBufferRangeEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptr length;
    length = (call.arg(2)).toSInt();

    GLbitfield access;
    access = (call.arg(3)).toUInt();

    GLvoid * _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glMapNamedBufferRangeEXT(buffer, offset, length, access);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to map buffer\n";
        }
    }
    retrace::addRegion((*call.ret).toUIntPtr(), _result, length);
}

static void retrace_glFlushMappedNamedBufferRangeEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLintptr offset;
    offset = (call.arg(1)).toSInt();

    GLsizeiptr length;
    length = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedCopyBufferSubDataEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint readBuffer;
    readBuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(readBuffer) << " <- " << size_t(_buffer_map[readBuffer]) << "\n";
    }
    readBuffer = _buffer_map[readBuffer];

    GLuint writeBuffer;
    writeBuffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(writeBuffer) << " <- " << size_t(_buffer_map[writeBuffer]) << "\n";
    }
    writeBuffer = _buffer_map[writeBuffer];

    GLintptr readOffset;
    readOffset = (call.arg(2)).toSInt();

    GLintptr writeOffset;
    writeOffset = (call.arg(3)).toSInt();

    GLsizeiptr size;
    size = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint buffer;
    buffer = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureBufferEXT(texture, target, internalformat, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint buffer;
    buffer = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexBufferEXT(texunit, target, internalformat, buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedRenderbufferStorageEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint renderbuffer;
    renderbuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCheckNamedFramebufferStatusEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCheckNamedFramebufferStatusEXT(framebuffer, target);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    GLint _origResult = call.ret->toSInt();
    if (_origResult == GL_FRAMEBUFFER_COMPLETE &&
        _result != GL_FRAMEBUFFER_COMPLETE) {
        retrace::warning(call) << "incomplete framebuffer (" << glstate::enumToString(_result) << ")\n";
    }
    }
}

static void retrace_glNamedFramebufferTexture1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedFramebufferTexture2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedFramebufferTexture3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedFramebufferRenderbufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum renderbuffertarget;
    renderbuffertarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenerateTextureMipmapEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenerateTextureMipmapEXT(texture, target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenerateMultiTexMipmapEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenerateMultiTexMipmapEXT(texunit, target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferDrawBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferDrawBufferEXT(framebuffer, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferDrawBuffersEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLsizei n;
    n = (call.arg(1)).toSInt();

    GLenum * bufs;
    bufs = static_cast<GLenum *>(_allocator.alloc(&call.arg(2), sizeof *bufs));
    if (bufs) {
        const trace::Array *_a_GLenum17_0 = (call.arg(2)).toArray();
        for (size_t _jGLenum17 = 0; _jGLenum17 < _a_GLenum17_0->values.size(); ++_jGLenum17) {
    bufs[_jGLenum17] = static_cast<GLenum>((*_a_GLenum17_0->values[_jGLenum17]).toSInt());
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferReadBufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferReadBufferEXT(framebuffer, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedRenderbufferStorageMultisampleEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint renderbuffer;
    renderbuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedRenderbufferStorageMultisampleCoverageEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint renderbuffer;
    renderbuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    GLsizei coverageSamples;
    coverageSamples = (call.arg(1)).toSInt();

    GLsizei colorSamples;
    colorSamples = (call.arg(2)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedFramebufferTextureEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedFramebufferTextureLayerEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    GLint layer;
    layer = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNamedFramebufferTextureFaceEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint framebuffer;
    framebuffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint texture;
    texture = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(3)).toSInt();

    GLenum face;
    face = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureRenderbufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureRenderbufferEXT(texture, target, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexRenderbufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexRenderbufferEXT(texunit, target, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble x;
    x = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1dEXT(program, location, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble x;
    x = (call.arg(2)).toDouble();

    GLdouble y;
    y = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2dEXT(program, location, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble x;
    x = (call.arg(2)).toDouble();

    GLdouble y;
    y = (call.arg(3)).toDouble();

    GLdouble z;
    z = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3dEXT(program, location, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLdouble x;
    x = (call.arg(2)).toDouble();

    GLdouble y;
    y = (call.arg(3)).toDouble();

    GLdouble z;
    z = (call.arg(4)).toDouble();

    GLdouble w;
    w = (call.arg(5)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4dEXT(program, location, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble126_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble126 = 0; _jGLdouble126 < _a_GLdouble126_0->values.size(); ++_jGLdouble126) {
    value[_jGLdouble126] = (*_a_GLdouble126_0->values[_jGLdouble126]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1dvEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble127_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble127 = 0; _jGLdouble127 < _a_GLdouble127_0->values.size(); ++_jGLdouble127) {
    value[_jGLdouble127] = (*_a_GLdouble127_0->values[_jGLdouble127]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2dvEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble128_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble128 = 0; _jGLdouble128 < _a_GLdouble128_0->values.size(); ++_jGLdouble128) {
    value[_jGLdouble128] = (*_a_GLdouble128_0->values[_jGLdouble128]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3dvEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble129_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble129 = 0; _jGLdouble129 < _a_GLdouble129_0->values.size(); ++_jGLdouble129) {
    value[_jGLdouble129] = (*_a_GLdouble129_0->values[_jGLdouble129]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4dvEXT(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble130_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble130 = 0; _jGLdouble130 < _a_GLdouble130_0->values.size(); ++_jGLdouble130) {
    value[_jGLdouble130] = (*_a_GLdouble130_0->values[_jGLdouble130]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble131_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble131 = 0; _jGLdouble131 < _a_GLdouble131_0->values.size(); ++_jGLdouble131) {
    value[_jGLdouble131] = (*_a_GLdouble131_0->values[_jGLdouble131]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble132_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble132 = 0; _jGLdouble132 < _a_GLdouble132_0->values.size(); ++_jGLdouble132) {
    value[_jGLdouble132] = (*_a_GLdouble132_0->values[_jGLdouble132]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2x3dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble133_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble133 = 0; _jGLdouble133 < _a_GLdouble133_0->values.size(); ++_jGLdouble133) {
    value[_jGLdouble133] = (*_a_GLdouble133_0->values[_jGLdouble133]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix2x4dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble134_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble134 = 0; _jGLdouble134 < _a_GLdouble134_0->values.size(); ++_jGLdouble134) {
    value[_jGLdouble134] = (*_a_GLdouble134_0->values[_jGLdouble134]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3x2dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble135_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble135 = 0; _jGLdouble135 < _a_GLdouble135_0->values.size(); ++_jGLdouble135) {
    value[_jGLdouble135] = (*_a_GLdouble135_0->values[_jGLdouble135]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix3x4dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble136_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble136 = 0; _jGLdouble136 < _a_GLdouble136_0->values.size(); ++_jGLdouble136) {
    value[_jGLdouble136] = (*_a_GLdouble136_0->values[_jGLdouble136]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4x2dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble137_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble137 = 0; _jGLdouble137 < _a_GLdouble137_0->values.size(); ++_jGLdouble137) {
    value[_jGLdouble137] = (*_a_GLdouble137_0->values[_jGLdouble137]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformMatrix4x3dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLboolean transpose;
    transpose = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLdouble * value;
    value = static_cast<GLdouble *>(_allocator.alloc(&call.arg(4), sizeof *value));
    if (value) {
        const trace::Array *_a_GLdouble138_0 = (call.arg(4)).toArray();
        for (size_t _jGLdouble138 = 0; _jGLdouble138 < _a_GLdouble138_0->values.size(); ++_jGLdouble138) {
    value[_jGLdouble138] = (*_a_GLdouble138_0->values[_jGLdouble138]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLint size;
    size = (call.arg(2)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    GLintptr offset;
    offset = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayColorOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLint size;
    size = (call.arg(2)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    GLintptr offset;
    offset = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayEdgeFlagOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    GLintptr offset;
    offset = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayIndexOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    GLintptr offset;
    offset = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayNormalOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    GLintptr offset;
    offset = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayTexCoordOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLint size;
    size = (call.arg(2)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    GLintptr offset;
    offset = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayMultiTexCoordOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLenum texunit;
    texunit = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint size;
    size = (call.arg(3)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLsizei stride;
    stride = (call.arg(5)).toSInt();

    GLintptr offset;
    offset = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayFogCoordOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    GLintptr offset;
    offset = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArraySecondaryColorOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLint size;
    size = (call.arg(2)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(3)).toSInt());

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    GLintptr offset;
    offset = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexAttribOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLint size;
    size = (call.arg(3)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(5)).toSInt());

    GLsizei stride;
    stride = (call.arg(6)).toSInt();

    GLintptr offset;
    offset = (call.arg(7)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexAttribIOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLint size;
    size = (call.arg(3)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLsizei stride;
    stride = (call.arg(5)).toSInt();

    GLintptr offset;
    offset = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableVertexArrayEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLenum array;
    array = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableVertexArrayEXT(vaobj, array);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableVertexArrayEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLenum array;
    array = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableVertexArrayEXT(vaobj, array);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableVertexArrayAttribEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableVertexArrayAttribEXT(vaobj, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableVertexArrayAttribEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint index;
    index = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableVertexArrayAttribEXT(vaobj, index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSampleMaskIndexedNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLbitfield mask;
    mask = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSampleMaskIndexedNV(index, mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexRenderbufferNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexRenderbufferNV(target, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindTransformFeedbackNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(id) << " <- " << size_t(_feedback_map[id]) << "\n";
    }
    id = _feedback_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindTransformFeedbackNV(target, id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteTransformFeedbacksNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint184_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint184 = 0; _jGLuint184 < _a_GLuint184_0->values.size(); ++_jGLuint184) {
    ids[_jGLuint184] = (*_a_GLuint184_0->values[_jGLuint184]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(ids[_jGLuint184]) << " <- " << size_t(_feedback_map[ids[_jGLuint184]]) << "\n";
    }
    ids[_jGLuint184] = _feedback_map[ids[_jGLuint184]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteTransformFeedbacksNV(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenTransformFeedbacksNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenTransformFeedbacksNV(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint186 = (call.arg(1)).toArray();
    if (_aGLuint186) {
        for (size_t _jGLuint186 = 0; _jGLuint186 < _aGLuint186->values.size(); ++_jGLuint186) {
    GLuint _origResult;
    _origResult = (*_aGLuint186->values[_jGLuint186]).toUInt();
    _feedback_map[_origResult] = ids[_jGLuint186];
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << _origResult << " -> " << ids[_jGLuint186] << "\n";
    }
        }
    }
}

static void retrace_glPauseTransformFeedbackNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPauseTransformFeedbackNV();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glResumeTransformFeedbackNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glResumeTransformFeedbackNV();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTransformFeedbackNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "feedback " << size_t(id) << " <- " << size_t(_feedback_map[id]) << "\n";
    }
    id = _feedback_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTransformFeedbackNV(mode, id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenPerfMonitorsAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * monitors;
    monitors = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *monitors));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenPerfMonitorsAMD(n, monitors);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint188 = (call.arg(1)).toArray();
    if (_aGLuint188) {
        for (size_t _jGLuint188 = 0; _jGLuint188 < _aGLuint188->values.size(); ++_jGLuint188) {
        }
    }
}

static void retrace_glDeletePerfMonitorsAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * monitors;
    monitors = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *monitors));
    if (monitors) {
        const trace::Array *_a_GLuint189_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint189 = 0; _jGLuint189 < _a_GLuint189_0->values.size(); ++_jGLuint189) {
    monitors[_jGLuint189] = (*_a_GLuint189_0->values[_jGLuint189]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeletePerfMonitorsAMD(n, monitors);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSelectPerfMonitorCountersAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint monitor;
    monitor = (call.arg(0)).toUInt();

    GLboolean enable;
    enable = static_cast<GLboolean>((call.arg(1)).toSInt());

    GLuint group;
    group = (call.arg(2)).toUInt();

    GLint numCounters;
    numCounters = (call.arg(3)).toSInt();

    GLuint * counterList;
    counterList = static_cast<GLuint *>(_allocator.alloc(&call.arg(4), sizeof *counterList));
    if (counterList) {
        const trace::Array *_a_GLuint190_0 = (call.arg(4)).toArray();
        for (size_t _jGLuint190 = 0; _jGLuint190 < _a_GLuint190_0->values.size(); ++_jGLuint190) {
    counterList[_jGLuint190] = (*_a_GLuint190_0->values[_jGLuint190]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginPerfMonitorAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint monitor;
    monitor = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginPerfMonitorAMD(monitor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndPerfMonitorAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint monitor;
    monitor = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndPerfMonitorAMD(monitor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTessellationFactorAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat factor;
    factor = (call.arg(0)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTessellationFactorAMD(factor);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTessellationModeAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTessellationModeAMD(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProvokingVertexEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProvokingVertexEXT(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFuncIndexedAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum src;
    src = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum dst;
    dst = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFuncIndexedAMD(buf, src, dst);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFuncSeparateIndexedAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum srcRGB;
    srcRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum dstRGB;
    dstRGB = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum srcAlpha;
    srcAlpha = static_cast<GLenum>((call.arg(3)).toSInt());

    GLenum dstAlpha;
    dstAlpha = static_cast<GLenum>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationIndexedAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum mode;
    mode = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationIndexedAMD(buf, mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationSeparateIndexedAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buf;
    buf = (call.arg(0)).toUInt();

    GLenum modeRGB;
    modeRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum modeAlpha;
    modeAlpha = static_cast<GLenum>((call.arg(2)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureRangeAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei length;
    length = (call.arg(1)).toSInt();

    GLvoid * pointer;
    pointer = static_cast<GLvoid *>((call.arg(2)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureRangeAPPLE(target, length, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEnableVertexAttribAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEnableVertexAttribAPPLE(index, pname);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDisableVertexAttribAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDisableVertexAttribAPPLE(index, pname);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapVertexAttrib1dAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint size;
    size = (call.arg(1)).toUInt();

    GLdouble u1;
    u1 = (call.arg(2)).toDouble();

    GLdouble u2;
    u2 = (call.arg(3)).toDouble();

    GLint stride;
    stride = (call.arg(4)).toSInt();

    GLint order;
    order = (call.arg(5)).toSInt();

    const GLdouble * points;
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapVertexAttrib1fAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint size;
    size = (call.arg(1)).toUInt();

    GLfloat u1;
    u1 = (call.arg(2)).toFloat();

    GLfloat u2;
    u2 = (call.arg(3)).toFloat();

    GLint stride;
    stride = (call.arg(4)).toSInt();

    GLint order;
    order = (call.arg(5)).toSInt();

    const GLfloat * points;
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapVertexAttrib2dAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint size;
    size = (call.arg(1)).toUInt();

    GLdouble u1;
    u1 = (call.arg(2)).toDouble();

    GLdouble u2;
    u2 = (call.arg(3)).toDouble();

    GLint ustride;
    ustride = (call.arg(4)).toSInt();

    GLint uorder;
    uorder = (call.arg(5)).toSInt();

    GLdouble v1;
    v1 = (call.arg(6)).toDouble();

    GLdouble v2;
    v2 = (call.arg(7)).toDouble();

    GLint vstride;
    vstride = (call.arg(8)).toSInt();

    GLint vorder;
    vorder = (call.arg(9)).toSInt();

    const GLdouble * points;
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapVertexAttrib2fAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint size;
    size = (call.arg(1)).toUInt();

    GLfloat u1;
    u1 = (call.arg(2)).toFloat();

    GLfloat u2;
    u2 = (call.arg(3)).toFloat();

    GLint ustride;
    ustride = (call.arg(4)).toSInt();

    GLint uorder;
    uorder = (call.arg(5)).toSInt();

    GLfloat v1;
    v1 = (call.arg(6)).toFloat();

    GLfloat v2;
    v2 = (call.arg(7)).toFloat();

    GLint vstride;
    vstride = (call.arg(8)).toSInt();

    GLint vorder;
    vorder = (call.arg(9)).toSInt();

    const GLfloat * points;
    memset(&points, 0, sizeof points); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glObjectPurgeableAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum objectType;
    objectType = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint name;
    name = (call.arg(1)).toUInt();

    GLenum option;
    option = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glObjectPurgeableAPPLE(objectType, name, option);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glObjectUnpurgeableAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum objectType;
    objectType = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint name;
    name = (call.arg(1)).toUInt();

    GLenum option;
    option = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glObjectUnpurgeableAPPLE(objectType, name, option);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginVideoCaptureNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_capture_slot;
    video_capture_slot = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginVideoCaptureNV(video_capture_slot);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindVideoCaptureStreamBufferNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_capture_slot;
    video_capture_slot = (call.arg(0)).toUInt();

    GLuint stream;
    stream = (call.arg(1)).toUInt();

    GLenum frame_region;
    frame_region = static_cast<GLenum>((call.arg(2)).toSInt());

    GLintptrARB offset;
    offset = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindVideoCaptureStreamTextureNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_capture_slot;
    video_capture_slot = (call.arg(0)).toUInt();

    GLuint stream;
    stream = (call.arg(1)).toUInt();

    GLenum frame_region;
    frame_region = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum target;
    target = static_cast<GLenum>((call.arg(3)).toSInt());

    GLuint texture;
    texture = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndVideoCaptureNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_capture_slot;
    video_capture_slot = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndVideoCaptureNV(video_capture_slot);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVideoCaptureNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_capture_slot;
    video_capture_slot = (call.arg(0)).toUInt();

    GLuint * sequence_num;
    sequence_num = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *sequence_num));

    GLuint64EXT * capture_time;
    capture_time = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *capture_time));

    GLenum _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aPGLuint25 = (call.arg(1)).toArray();
    if (_aPGLuint25) {
    }
    const trace::Array *_aPGLuint64EXT = (call.arg(2)).toArray();
    if (_aPGLuint64EXT) {
    }
}

static void retrace_glVideoCaptureStreamParameterivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_capture_slot;
    video_capture_slot = (call.arg(0)).toUInt();

    GLuint stream;
    stream = (call.arg(1)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint228_0 = (call.arg(3)).toArray();
        for (size_t _jGLint228 = 0; _jGLint228 < _a_GLint228_0->values.size(); ++_jGLint228) {
    params[_jGLint228] = (*_a_GLint228_0->values[_jGLint228]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVideoCaptureStreamParameterfvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_capture_slot;
    video_capture_slot = (call.arg(0)).toUInt();

    GLuint stream;
    stream = (call.arg(1)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat298_0 = (call.arg(3)).toArray();
        for (size_t _jGLfloat298 = 0; _jGLfloat298 < _a_GLfloat298_0->values.size(); ++_jGLfloat298) {
    params[_jGLfloat298] = (*_a_GLfloat298_0->values[_jGLfloat298]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVideoCaptureStreamParameterdvNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint video_capture_slot;
    video_capture_slot = (call.arg(0)).toUInt();

    GLuint stream;
    stream = (call.arg(1)).toUInt();

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(2)).toSInt());

    GLdouble * params;
    params = static_cast<GLdouble *>(_allocator.alloc(&call.arg(3), sizeof *params));
    if (params) {
        const trace::Array *_a_GLdouble139_0 = (call.arg(3)).toArray();
        for (size_t _jGLdouble139 = 0; _jGLdouble139 < _a_GLdouble139_0->values.size(); ++_jGLdouble139) {
    params[_jGLdouble139] = (*_a_GLdouble139_0->values[_jGLdouble139]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyImageSubDataNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint srcName;
    srcName = (call.arg(0)).toUInt();

    GLenum srcTarget;
    srcTarget = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint srcLevel;
    srcLevel = (call.arg(2)).toSInt();

    GLint srcX;
    srcX = (call.arg(3)).toSInt();

    GLint srcY;
    srcY = (call.arg(4)).toSInt();

    GLint srcZ;
    srcZ = (call.arg(5)).toSInt();

    GLuint dstName;
    dstName = (call.arg(6)).toUInt();

    GLenum dstTarget;
    dstTarget = static_cast<GLenum>((call.arg(7)).toSInt());

    GLint dstLevel;
    dstLevel = (call.arg(8)).toSInt();

    GLint dstX;
    dstX = (call.arg(9)).toSInt();

    GLint dstY;
    dstY = (call.arg(10)).toSInt();

    GLint dstZ;
    dstZ = (call.arg(11)).toSInt();

    GLsizei width;
    width = (call.arg(12)).toSInt();

    GLsizei height;
    height = (call.arg(13)).toSInt();

    GLsizei depth;
    depth = (call.arg(14)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUseShaderProgramEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint program;
    program = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUseShaderProgramEXT(type, program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glActiveProgramEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glActiveProgramEXT(program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCreateShaderProgramEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    const GLchar * string;
    string = (const GLchar *)((call.arg(1)).toString());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCreateShaderProgramEXT(type, string);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        GLuint program = _result;
        GLint link_status = 0;
        glGetProgramiv(program, GL_LINK_STATUS, &link_status);
        if (!link_status) {
             GLint info_log_length = 0;
             glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
             GLchar *infoLog = new GLchar[info_log_length];
             glGetProgramInfoLog(program, info_log_length, NULL, infoLog);
             retrace::warning(call) << infoLog << "\n";
             delete [] infoLog;
        }
    }
    GLuint _origResult;
    _origResult = (*call.ret).toUInt();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _program_map[_origResult] = _result;
}
    if (retrace::verbosity >= 2) {
        std::cout << "program " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glMakeBufferResidentNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum access;
    access = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMakeBufferResidentNV(target, access);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMakeBufferNonResidentNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMakeBufferNonResidentNV(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMakeNamedBufferResidentNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    GLenum access;
    access = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMakeNamedBufferResidentNV(buffer, access);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMakeNamedBufferNonResidentNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint buffer;
    buffer = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "buffer " << size_t(buffer) << " <- " << size_t(_buffer_map[buffer]) << "\n";
    }
    buffer = _buffer_map[buffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMakeNamedBufferNonResidentNV(buffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLuint64EXT value;
    value = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformui64NV(location, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT9_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint64EXT9 = 0; _jGLuint64EXT9 < _a_GLuint64EXT9_0->values.size(); ++_jGLuint64EXT9) {
    value[_jGLuint64EXT9] = (*_a_GLuint64EXT9_0->values[_jGLuint64EXT9]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformui64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();

    GLuint64EXT value;
    value = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformui64NV(program, location, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT10_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint64EXT10 = 0; _jGLuint64EXT10 < _a_GLuint64EXT10_0->values.size(); ++_jGLuint64EXT10) {
    value[_jGLuint64EXT10] = (*_a_GLuint64EXT10_0->values[_jGLuint64EXT10]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformui64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBufferAddressRangeNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLuint64EXT address;
    address = (call.arg(2)).toUInt();

    GLsizeiptr length;
    length = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBufferAddressRangeNV(pname, index, address, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexFormatNV(size, type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormalFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormalFormatNV(type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColorFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColorFormatNV(size, type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glIndexFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glIndexFormatNV(type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexCoordFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexCoordFormatNV(size, type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEdgeFlagFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei stride;
    stride = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEdgeFlagFormatNV(stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSecondaryColorFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSecondaryColorFormatNV(size, type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogCoordFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogCoordFormatNV(type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLboolean normalized;
    normalized = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribFormatNV(index, size, type, normalized, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribIFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribIFormatNV(index, size, type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureBarrierNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureBarrierNV();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindImageTextureEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint texture;
    texture = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(2)).toSInt();

    GLboolean layered;
    layered = static_cast<GLboolean>((call.arg(3)).toSInt());

    GLint layer;
    layer = (call.arg(4)).toSInt();

    GLenum access;
    access = static_cast<GLenum>((call.arg(5)).toSInt());

    GLint format;
    format = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMemoryBarrierEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLbitfield barriers;
    barriers = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMemoryBarrierEXT(barriers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL1dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL1dEXT(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL2dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL2dEXT(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL3dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL3dEXT(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL4dEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble x;
    x = (call.arg(1)).toDouble();

    GLdouble y;
    y = (call.arg(2)).toDouble();

    GLdouble z;
    z = (call.arg(3)).toDouble();

    GLdouble w;
    w = (call.arg(4)).toDouble();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL4dEXT(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL1dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLdouble13_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLdouble13_0->values[0]).toDouble();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL1dvEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL2dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble140_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble140 = 0; _jGLdouble140 < _a_GLdouble140_0->values.size(); ++_jGLdouble140) {
    v[_jGLdouble140] = (*_a_GLdouble140_0->values[_jGLdouble140]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL2dvEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL3dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble141_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble141 = 0; _jGLdouble141 < _a_GLdouble141_0->values.size(); ++_jGLdouble141) {
    v[_jGLdouble141] = (*_a_GLdouble141_0->values[_jGLdouble141]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL3dvEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL4dvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLdouble * v;
    v = static_cast<GLdouble *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLdouble142_0 = (call.arg(1)).toArray();
        for (size_t _jGLdouble142 = 0; _jGLdouble142 < _a_GLdouble142_0->values.size(); ++_jGLdouble142) {
    v[_jGLdouble142] = (*_a_GLdouble142_0->values[_jGLdouble142]).toDouble();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL4dvEXT(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribLPointerEXT(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    GLvoid * pointer;
    pointer = static_cast<GLvoid *>(retrace::toPointer(call.arg(4), true));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribLPointerEXT(index, size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexArrayVertexAttribLOffsetEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint vaobj;
    vaobj = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(vaobj) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj]) << "\n";
    }
    vaobj = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][vaobj];

    GLuint buffer;
    buffer = (call.arg(1)).toUInt();

    GLuint index;
    index = (call.arg(2)).toUInt();

    GLint size;
    size = (call.arg(3)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(4)).toSInt());

    GLsizei stride;
    stride = (call.arg(5)).toSInt();

    GLintptr offset;
    offset = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramSubroutineParametersuivNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint * params;
    params = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLuint193_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint193 = 0; _jGLuint193 < _a_GLuint193_0->values.size(); ++_jGLuint193) {
    params[_jGLuint193] = (*_a_GLuint193_0->values[_jGLuint193]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramSubroutineParametersuivNV(target, count, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLint64EXT x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1i64NV(location, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLint64EXT x;
    x = (call.arg(1)).toSInt();

    GLint64EXT y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2i64NV(location, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLint64EXT x;
    x = (call.arg(1)).toSInt();

    GLint64EXT y;
    y = (call.arg(2)).toSInt();

    GLint64EXT z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3i64NV(location, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLint64EXT x;
    x = (call.arg(1)).toSInt();

    GLint64EXT y;
    y = (call.arg(2)).toSInt();

    GLint64EXT z;
    z = (call.arg(3)).toSInt();

    GLint64EXT w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4i64NV(location, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint64EXT * value;
    value = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint64EXT5_0 = (call.arg(2)).toArray();
        for (size_t _jGLint64EXT5 = 0; _jGLint64EXT5 < _a_GLint64EXT5_0->values.size(); ++_jGLint64EXT5) {
    value[_jGLint64EXT5] = (*_a_GLint64EXT5_0->values[_jGLint64EXT5]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1i64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint64EXT * value;
    value = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint64EXT6_0 = (call.arg(2)).toArray();
        for (size_t _jGLint64EXT6 = 0; _jGLint64EXT6 < _a_GLint64EXT6_0->values.size(); ++_jGLint64EXT6) {
    value[_jGLint64EXT6] = (*_a_GLint64EXT6_0->values[_jGLint64EXT6]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2i64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint64EXT * value;
    value = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint64EXT7_0 = (call.arg(2)).toArray();
        for (size_t _jGLint64EXT7 = 0; _jGLint64EXT7 < _a_GLint64EXT7_0->values.size(); ++_jGLint64EXT7) {
    value[_jGLint64EXT7] = (*_a_GLint64EXT7_0->values[_jGLint64EXT7]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3i64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLint64EXT * value;
    value = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint64EXT8_0 = (call.arg(2)).toArray();
        for (size_t _jGLint64EXT8 = 0; _jGLint64EXT8 < _a_GLint64EXT8_0->values.size(); ++_jGLint64EXT8) {
    value[_jGLint64EXT8] = (*_a_GLint64EXT8_0->values[_jGLint64EXT8]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4i64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLuint64EXT x;
    x = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1ui64NV(location, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLuint64EXT x;
    x = (call.arg(1)).toUInt();

    GLuint64EXT y;
    y = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2ui64NV(location, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLuint64EXT x;
    x = (call.arg(1)).toUInt();

    GLuint64EXT y;
    y = (call.arg(2)).toUInt();

    GLuint64EXT z;
    z = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3ui64NV(location, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLuint64EXT x;
    x = (call.arg(1)).toUInt();

    GLuint64EXT y;
    y = (call.arg(2)).toUInt();

    GLuint64EXT z;
    z = (call.arg(3)).toUInt();

    GLuint64EXT w;
    w = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4ui64NV(location, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform1ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT11_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint64EXT11 = 0; _jGLuint64EXT11 < _a_GLuint64EXT11_0->values.size(); ++_jGLuint64EXT11) {
    value[_jGLuint64EXT11] = (*_a_GLuint64EXT11_0->values[_jGLuint64EXT11]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform1ui64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform2ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT12_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint64EXT12 = 0; _jGLuint64EXT12 < _a_GLuint64EXT12_0->values.size(); ++_jGLuint64EXT12) {
    value[_jGLuint64EXT12] = (*_a_GLuint64EXT12_0->values[_jGLuint64EXT12]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform2ui64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform3ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT13_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint64EXT13 = 0; _jGLuint64EXT13 < _a_GLuint64EXT13_0->values.size(); ++_jGLuint64EXT13) {
    value[_jGLuint64EXT13] = (*_a_GLuint64EXT13_0->values[_jGLuint64EXT13]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform3ui64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniform4ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    location = (call.arg(0)).toSInt();

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT14_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint64EXT14 = 0; _jGLuint64EXT14 < _a_GLuint64EXT14_0->values.size(); ++_jGLuint64EXT14) {
    value[_jGLuint64EXT14] = (*_a_GLuint64EXT14_0->values[_jGLuint64EXT14]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniform4ui64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLint64EXT x;
    x = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1i64NV(program, location, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLint64EXT x;
    x = (call.arg(2)).toSInt();

    GLint64EXT y;
    y = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2i64NV(program, location, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLint64EXT x;
    x = (call.arg(2)).toSInt();

    GLint64EXT y;
    y = (call.arg(3)).toSInt();

    GLint64EXT z;
    z = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3i64NV(program, location, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLint64EXT x;
    x = (call.arg(2)).toSInt();

    GLint64EXT y;
    y = (call.arg(3)).toSInt();

    GLint64EXT z;
    z = (call.arg(4)).toSInt();

    GLint64EXT w;
    w = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4i64NV(program, location, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint64EXT * value;
    value = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint64EXT9_0 = (call.arg(3)).toArray();
        for (size_t _jGLint64EXT9 = 0; _jGLint64EXT9 < _a_GLint64EXT9_0->values.size(); ++_jGLint64EXT9) {
    value[_jGLint64EXT9] = (*_a_GLint64EXT9_0->values[_jGLint64EXT9]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1i64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint64EXT * value;
    value = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint64EXT10_0 = (call.arg(3)).toArray();
        for (size_t _jGLint64EXT10 = 0; _jGLint64EXT10 < _a_GLint64EXT10_0->values.size(); ++_jGLint64EXT10) {
    value[_jGLint64EXT10] = (*_a_GLint64EXT10_0->values[_jGLint64EXT10]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2i64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint64EXT * value;
    value = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint64EXT11_0 = (call.arg(3)).toArray();
        for (size_t _jGLint64EXT11 = 0; _jGLint64EXT11 < _a_GLint64EXT11_0->values.size(); ++_jGLint64EXT11) {
    value[_jGLint64EXT11] = (*_a_GLint64EXT11_0->values[_jGLint64EXT11]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3i64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLint64EXT * value;
    value = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLint64EXT12_0 = (call.arg(3)).toArray();
        for (size_t _jGLint64EXT12 = 0; _jGLint64EXT12 < _a_GLint64EXT12_0->values.size(); ++_jGLint64EXT12) {
    value[_jGLint64EXT12] = (*_a_GLint64EXT12_0->values[_jGLint64EXT12]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4i64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLuint64EXT x;
    x = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1ui64NV(program, location, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLuint64EXT x;
    x = (call.arg(2)).toUInt();

    GLuint64EXT y;
    y = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2ui64NV(program, location, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLuint64EXT x;
    x = (call.arg(2)).toUInt();

    GLuint64EXT y;
    y = (call.arg(3)).toUInt();

    GLuint64EXT z;
    z = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3ui64NV(program, location, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLuint64EXT x;
    x = (call.arg(2)).toUInt();

    GLuint64EXT y;
    y = (call.arg(3)).toUInt();

    GLuint64EXT z;
    z = (call.arg(4)).toUInt();

    GLuint64EXT w;
    w = (call.arg(5)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4ui64NV(program, location, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform1ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT15_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint64EXT15 = 0; _jGLuint64EXT15 < _a_GLuint64EXT15_0->values.size(); ++_jGLuint64EXT15) {
    value[_jGLuint64EXT15] = (*_a_GLuint64EXT15_0->values[_jGLuint64EXT15]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform1ui64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform2ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT16_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint64EXT16 = 0; _jGLuint64EXT16 < _a_GLuint64EXT16_0->values.size(); ++_jGLuint64EXT16) {
    value[_jGLuint64EXT16] = (*_a_GLuint64EXT16_0->values[_jGLuint64EXT16]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform2ui64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform3ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT17_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint64EXT17 = 0; _jGLuint64EXT17 < _a_GLuint64EXT17_0->values.size(); ++_jGLuint64EXT17) {
    value[_jGLuint64EXT17] = (*_a_GLuint64EXT17_0->values[_jGLuint64EXT17]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform3ui64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniform4ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();

    GLint location;
    location = (call.arg(1)).toSInt();

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint64EXT * value;
    value = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(3), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint64EXT18_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint64EXT18 = 0; _jGLuint64EXT18 < _a_GLuint64EXT18_0->values.size(); ++_jGLuint64EXT18) {
    value[_jGLuint64EXT18] = (*_a_GLuint64EXT18_0->values[_jGLuint64EXT18]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniform4ui64vNV(program, location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL1i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint64EXT x;
    x = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL1i64NV(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL2i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint64EXT x;
    x = (call.arg(1)).toSInt();

    GLint64EXT y;
    y = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL2i64NV(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL3i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint64EXT x;
    x = (call.arg(1)).toSInt();

    GLint64EXT y;
    y = (call.arg(2)).toSInt();

    GLint64EXT z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL3i64NV(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL4i64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint64EXT x;
    x = (call.arg(1)).toSInt();

    GLint64EXT y;
    y = (call.arg(2)).toSInt();

    GLint64EXT z;
    z = (call.arg(3)).toSInt();

    GLint64EXT w;
    w = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL4i64NV(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL1i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint64EXT * v;
    v = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLint64EXT_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLint64EXT_0->values[0]).toSInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL1i64vNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL2i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint64EXT * v;
    v = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint64EXT13_0 = (call.arg(1)).toArray();
        for (size_t _jGLint64EXT13 = 0; _jGLint64EXT13 < _a_GLint64EXT13_0->values.size(); ++_jGLint64EXT13) {
    v[_jGLint64EXT13] = (*_a_GLint64EXT13_0->values[_jGLint64EXT13]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL2i64vNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL3i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint64EXT * v;
    v = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint64EXT14_0 = (call.arg(1)).toArray();
        for (size_t _jGLint64EXT14 = 0; _jGLint64EXT14 < _a_GLint64EXT14_0->values.size(); ++_jGLint64EXT14) {
    v[_jGLint64EXT14] = (*_a_GLint64EXT14_0->values[_jGLint64EXT14]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL3i64vNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL4i64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint64EXT * v;
    v = static_cast<GLint64EXT *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLint64EXT15_0 = (call.arg(1)).toArray();
        for (size_t _jGLint64EXT15 = 0; _jGLint64EXT15 < _a_GLint64EXT15_0->values.size(); ++_jGLint64EXT15) {
    v[_jGLint64EXT15] = (*_a_GLint64EXT15_0->values[_jGLint64EXT15]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL4i64vNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL1ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint64EXT x;
    x = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL1ui64NV(index, x);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL2ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint64EXT x;
    x = (call.arg(1)).toUInt();

    GLuint64EXT y;
    y = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL2ui64NV(index, x, y);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL3ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint64EXT x;
    x = (call.arg(1)).toUInt();

    GLuint64EXT y;
    y = (call.arg(2)).toUInt();

    GLuint64EXT z;
    z = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL3ui64NV(index, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL4ui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint64EXT x;
    x = (call.arg(1)).toUInt();

    GLuint64EXT y;
    y = (call.arg(2)).toUInt();

    GLuint64EXT z;
    z = (call.arg(3)).toUInt();

    GLuint64EXT w;
    w = (call.arg(4)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL4ui64NV(index, x, y, z, w);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL1ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint64EXT * v;
    v = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_PGLuint64EXT1_0 = (call.arg(1)).toArray();
    v[0] = (*_a_PGLuint64EXT1_0->values[0]).toUInt();
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL1ui64vNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL2ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint64EXT * v;
    v = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint64EXT19_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint64EXT19 = 0; _jGLuint64EXT19 < _a_GLuint64EXT19_0->values.size(); ++_jGLuint64EXT19) {
    v[_jGLuint64EXT19] = (*_a_GLuint64EXT19_0->values[_jGLuint64EXT19]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL2ui64vNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL3ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint64EXT * v;
    v = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint64EXT20_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint64EXT20 = 0; _jGLuint64EXT20 < _a_GLuint64EXT20_0->values.size(); ++_jGLuint64EXT20) {
    v[_jGLuint64EXT20] = (*_a_GLuint64EXT20_0->values[_jGLuint64EXT20]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL3ui64vNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribL4ui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLuint64EXT * v;
    v = static_cast<GLuint64EXT *>(_allocator.alloc(&call.arg(1), sizeof *v));
    if (v) {
        const trace::Array *_a_GLuint64EXT21_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint64EXT21 = 0; _jGLuint64EXT21 < _a_GLuint64EXT21_0->values.size(); ++_jGLuint64EXT21) {
    v[_jGLuint64EXT21] = (*_a_GLuint64EXT21_0->values[_jGLuint64EXT21]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribL4ui64vNV(index, v);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glVertexAttribLFormatNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    GLint size;
    size = (call.arg(1)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glVertexAttribLFormatNV(index, size, type, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenNamesAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum identifier;
    identifier = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint num;
    num = (call.arg(1)).toUInt();

    GLuint * names;
    names = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *names));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenNamesAMD(identifier, num, names);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint195 = (call.arg(2)).toArray();
    if (_aGLuint195) {
        for (size_t _jGLuint195 = 0; _jGLuint195 < _aGLuint195->values.size(); ++_jGLuint195) {
        }
    }
}

static void retrace_glDeleteNamesAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum identifier;
    identifier = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint num;
    num = (call.arg(1)).toUInt();

    GLuint * names;
    names = static_cast<GLuint *>(_allocator.alloc(&call.arg(2), sizeof *names));
    if (names) {
        const trace::Array *_a_GLuint196_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint196 = 0; _jGLuint196 < _a_GLuint196_0->values.size(); ++_jGLuint196) {
    names[_jGLuint196] = (*_a_GLuint196_0->values[_jGLuint196]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteNamesAMD(identifier, num, names);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDebugMessageEnableAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum category;
    category = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum severity;
    severity = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(3), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint197_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint197 = 0; _jGLuint197 < _a_GLuint197_0->values.size(); ++_jGLuint197) {
    ids[_jGLuint197] = (*_a_GLuint197_0->values[_jGLuint197]).toUInt();
        }
    }

    GLboolean enabled;
    enabled = static_cast<GLboolean>((call.arg(4)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDebugMessageEnableAMD(category, severity, count, ids, enabled);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDebugMessageInsertAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum category;
    category = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum severity;
    severity = static_cast<GLenum>((call.arg(1)).toSInt());

    GLuint id;
    id = (call.arg(2)).toUInt();

    GLsizei length;
    length = (call.arg(3)).toSInt();

    const GLchar * buf;
    buf = (const GLchar *)((call.arg(4)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDebugMessageInsertAMD(category, severity, id, length, buf);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexImage2DMultisampleCoverageNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei coverageSamples;
    coverageSamples = (call.arg(1)).toSInt();

    GLsizei colorSamples;
    colorSamples = (call.arg(2)).toSInt();

    GLint internalFormat;
    internalFormat = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLboolean fixedSampleLocations;
    fixedSampleLocations = static_cast<GLboolean>((call.arg(6)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexImage3DMultisampleCoverageNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei coverageSamples;
    coverageSamples = (call.arg(1)).toSInt();

    GLsizei colorSamples;
    colorSamples = (call.arg(2)).toSInt();

    GLint internalFormat;
    internalFormat = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLsizei depth;
    depth = (call.arg(6)).toSInt();

    GLboolean fixedSampleLocations;
    fixedSampleLocations = static_cast<GLboolean>((call.arg(7)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureImage2DMultisampleNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei samples;
    samples = (call.arg(2)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLint internalFormat;
    internalFormat = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLboolean fixedSampleLocations;
    fixedSampleLocations = static_cast<GLboolean>((call.arg(6)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureImage3DMultisampleNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei samples;
    samples = (call.arg(2)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLint internalFormat;
    internalFormat = (call.arg(3)).toSInt();

    GLsizei width;
    width = (call.arg(4)).toSInt();

    GLsizei height;
    height = (call.arg(5)).toSInt();

    GLsizei depth;
    depth = (call.arg(6)).toSInt();

    GLboolean fixedSampleLocations;
    fixedSampleLocations = static_cast<GLboolean>((call.arg(7)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureImage2DMultisampleCoverageNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei coverageSamples;
    coverageSamples = (call.arg(2)).toSInt();

    GLsizei colorSamples;
    colorSamples = (call.arg(3)).toSInt();

    GLint internalFormat;
    internalFormat = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLboolean fixedSampleLocations;
    fixedSampleLocations = static_cast<GLboolean>((call.arg(7)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureImage3DMultisampleCoverageNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei coverageSamples;
    coverageSamples = (call.arg(2)).toSInt();

    GLsizei colorSamples;
    colorSamples = (call.arg(3)).toSInt();

    GLint internalFormat;
    internalFormat = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLsizei depth;
    depth = (call.arg(7)).toSInt();

    GLboolean fixedSampleLocations;
    fixedSampleLocations = static_cast<GLboolean>((call.arg(8)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSetMultisamplefvAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint index;
    index = (call.arg(1)).toUInt();

    GLfloat * val;
    val = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *val));
    if (val) {
        const trace::Array *_a_GLfloat299_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat299 = 0; _jGLfloat299 < _a_GLfloat299_0->values.size(); ++_jGLfloat299) {
    val[_jGLfloat299] = (*_a_GLfloat299_0->values[_jGLfloat299]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSetMultisamplefvAMD(pname, index, val);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glImportSyncEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum external_sync_type;
    external_sync_type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLintptr external_sync;
    external_sync = (call.arg(1)).toSInt();

    GLbitfield flags;
    flags = (call.arg(2)).toUInt();

    GLsync _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glImportSyncEXT(external_sync_type, external_sync, flags);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLsync _origResult;
    _origResult = static_cast<GLsync>((*call.ret).toPointer());
    _sync_map[_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "sync " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glMultiDrawArraysIndirectAMD(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _array_buffer = 0;
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);
        if (!_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    const GLvoid * indirect;
    indirect = static_cast<const GLvoid *>(retrace::toPointer(call.arg(1)));

    GLsizei primcount;
    primcount = (call.arg(2)).toSInt();

    GLsizei stride;
    stride = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glMultiDrawElementsIndirectAMD(trace::Call &call) {
    if (retrace::parser.version < 1) {
        GLint _element_array_buffer = 0;
        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);
        if (!_element_array_buffer) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
        }
    }
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    const GLvoid * indirect;
    indirect = static_cast<const GLvoid *>(retrace::toPointer(call.arg(2)));

    GLsizei primcount;
    primcount = (call.arg(3)).toSInt();

    GLsizei stride;
    stride = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, true);
    }
    glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, true);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    assert(call.flags & trace::CALL_FLAG_RENDER);
}

static void retrace_glStencilOpValueAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint value;
    value = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glStencilOpValueAMD(face, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetTextureHandleNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLuint64 _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetTextureHandleNV(texture);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetTextureSamplerHandleNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLuint sampler;
    sampler = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    GLuint64 _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetTextureSamplerHandleNV(texture, sampler);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMakeTextureHandleResidentNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint64 handle;
    handle = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMakeTextureHandleResidentNV(handle);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMakeTextureHandleNonResidentNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint64 handle;
    handle = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMakeTextureHandleNonResidentNV(handle);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGetImageHandleNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(1)).toSInt();

    GLboolean layered;
    layered = static_cast<GLboolean>((call.arg(2)).toSInt());

    GLint layer;
    layer = (call.arg(3)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(4)).toSInt());

    GLuint64 _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glGetImageHandleNV(texture, level, layered, layer, format);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMakeImageHandleResidentNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint64 handle;
    handle = (call.arg(0)).toUInt();

    GLenum access;
    access = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMakeImageHandleResidentNV(handle, access);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMakeImageHandleNonResidentNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint64 handle;
    handle = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMakeImageHandleNonResidentNV(handle);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformHandleui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint64 value;
    value = (call.arg(1)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformHandleui64NV(location, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUniformHandleui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint location;
    GLint program = -1;
    if (glretrace::insideList) {
        // glUseProgram & glUseProgramObjectARB are display-list-able
    glretrace::Context *currentContext = glretrace::getCurrentContext();
        program = _program_map[currentContext->activeProgram];
    } else {
        GLint pipeline = 0;
        if (_pipelineHasBeenBound) {
            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);
        }
        if (pipeline) {
            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);
        } else {
            glGetIntegerv(GL_CURRENT_PROGRAM, &program);
        }
    }

    location = (call.arg(0)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(1)).toSInt();

    GLuint64 * value;
    value = static_cast<GLuint64 *>(_allocator.alloc(&call.arg(2), sizeof *value));
    if (value) {
        const trace::Array *_a_GLuint642_0 = (call.arg(2)).toArray();
        for (size_t _jGLuint642 = 0; _jGLuint642 < _a_GLuint642_0->values.size(); ++_jGLuint642) {
    value[_jGLuint642] = (*_a_GLuint642_0->values[_jGLuint642]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUniformHandleui64vNV(location, count, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformHandleui64NV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLuint64 value;
    value = (call.arg(2)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformHandleui64NV(program, location, value);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramUniformHandleui64vNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLint location;
    location = (call.arg(1)).toSInt();
    if (retrace::verbosity >= 2) {
        std::cout << "location " << size_t(location) << " <- " << size_t(_location_map[program].lookupUniformLocation(location)) << "\n";
    }
    location = _location_map[program].lookupUniformLocation(location);

    GLsizei count;
    count = (call.arg(2)).toSInt();

    GLuint64 * values;
    values = static_cast<GLuint64 *>(_allocator.alloc(&call.arg(3), sizeof *values));
    if (values) {
        const trace::Array *_a_GLuint643_0 = (call.arg(3)).toArray();
        for (size_t _jGLuint643 = 0; _jGLuint643 < _a_GLuint643_0->values.size(); ++_jGLuint643) {
    values[_jGLuint643] = (*_a_GLuint643_0->values[_jGLuint643]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramUniformHandleui64vNV(program, location, count, values);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginConditionalRenderNVX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint id;
    id = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(id) << " <- " << size_t(_query_map[id]) << "\n";
    }
    id = _query_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginConditionalRenderNVX(id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndConditionalRenderNVX(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndConditionalRenderNVX();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorageSparseAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalFormat;
    internalFormat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    GLsizei depth;
    depth = (call.arg(4)).toSInt();

    GLsizei layers;
    layers = (call.arg(5)).toSInt();

    GLbitfield flags;
    flags = (call.arg(6)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTextureStorageSparseAMD(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLenum target;
    target = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum internalFormat;
    internalFormat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLsizei layers;
    layers = (call.arg(6)).toSInt();

    GLbitfield flags;
    flags = (call.arg(7)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTextureNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint texture;
    texture = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLuint sampler;
    sampler = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "sampler " << size_t(sampler) << " <- " << size_t(_sampler_map[sampler]) << "\n";
    }
    sampler = _sampler_map[sampler];

    GLfloat x0;
    x0 = (call.arg(2)).toFloat();

    GLfloat y0;
    y0 = (call.arg(3)).toFloat();

    GLfloat x1;
    x1 = (call.arg(4)).toFloat();

    GLfloat y1;
    y1 = (call.arg(5)).toFloat();

    GLfloat z;
    z = (call.arg(6)).toFloat();

    GLfloat s0;
    s0 = (call.arg(7)).toFloat();

    GLfloat t0;
    t0 = (call.arg(8)).toFloat();

    GLfloat s1;
    s1 = (call.arg(9)).toFloat();

    GLfloat t1;
    t1 = (call.arg(10)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNewBufferRegion(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glNewBufferRegion(type);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLuint _origResult;
    _origResult = (*call.ret).toUInt();
    _region_map[_origResult] = _result;
    if (retrace::verbosity >= 2) {
        std::cout << "region " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glDeleteBufferRegion(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint region;
    region = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "region " << size_t(region) << " <- " << size_t(_region_map[region]) << "\n";
    }
    region = _region_map[region];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteBufferRegion(region);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReadBufferRegion(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint region;
    region = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "region " << size_t(region) << " <- " << size_t(_region_map[region]) << "\n";
    }
    region = _region_map[region];

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReadBufferRegion(region, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawBufferRegion(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint region;
    region = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "region " << size_t(region) << " <- " << size_t(_region_map[region]) << "\n";
    }
    region = _region_map[region];

    GLint x;
    x = (call.arg(1)).toSInt();

    GLint y;
    y = (call.arg(2)).toSInt();

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLint xDest;
    xDest = (call.arg(5)).toSInt();

    GLint yDest;
    yDest = (call.arg(6)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawBufferRegion(region, x, y, width, height, xDest, yDest);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAddSwapHintRectWIN(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAddSwapHintRectWIN(x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFrustumf(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat left;
    left = (call.arg(0)).toFloat();

    GLfloat right;
    right = (call.arg(1)).toFloat();

    GLfloat bottom;
    bottom = (call.arg(2)).toFloat();

    GLfloat top;
    top = (call.arg(3)).toFloat();

    GLfloat zNear;
    zNear = (call.arg(4)).toFloat();

    GLfloat zFar;
    zFar = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFrustumf(left, right, bottom, top, zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glOrthof(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat left;
    left = (call.arg(0)).toFloat();

    GLfloat right;
    right = (call.arg(1)).toFloat();

    GLfloat bottom;
    bottom = (call.arg(2)).toFloat();

    GLfloat top;
    top = (call.arg(3)).toFloat();

    GLfloat zNear;
    zNear = (call.arg(4)).toFloat();

    GLfloat zFar;
    zFar = (call.arg(5)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glOrthof(left, right, bottom, top, zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClipPlanef(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum plane;
    plane = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfloat * equation;
    equation = static_cast<GLfloat *>(_allocator.alloc(&call.arg(1), sizeof *equation));
    if (equation) {
        const trace::Array *_a_GLfloat300_0 = (call.arg(1)).toArray();
        for (size_t _jGLfloat300 = 0; _jGLfloat300 < _a_GLfloat300_0->values.size(); ++_jGLfloat300) {
    equation[_jGLfloat300] = (*_a_GLfloat300_0->values[_jGLfloat300]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClipPlanef(plane, equation);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glAlphaFuncx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum func;
    func = static_cast<GLenum>((call.arg(0)).toSInt());

    GLclampx ref;
    ref = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glAlphaFuncx(func, ref);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearColorx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLclampx red;
    red = (call.arg(0)).toSInt();

    GLclampx green;
    green = (call.arg(1)).toSInt();

    GLclampx blue;
    blue = (call.arg(2)).toSInt();

    GLclampx alpha;
    alpha = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearColorx(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClearDepthx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLclampx depth;
    depth = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClearDepthx(depth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glColor4x(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed red;
    red = (call.arg(0)).toSInt();

    GLfixed green;
    green = (call.arg(1)).toSInt();

    GLfixed blue;
    blue = (call.arg(2)).toSInt();

    GLfixed alpha;
    alpha = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glColor4x(red, green, blue, alpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDepthRangex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLclampx zNear;
    zNear = (call.arg(0)).toSInt();

    GLclampx zFar;
    zFar = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDepthRangex(zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfixed param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogx(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFogxv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfixed * params;
    params = static_cast<GLfixed *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfixed9_0 = (call.arg(1)).toArray();
        for (size_t _jGLfixed9 = 0; _jGLfixed9 < _a_GLfixed9_0->values.size(); ++_jGLfixed9) {
    params[_jGLfixed9] = (*_a_GLfixed9_0->values[_jGLfixed9]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFogxv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFrustumx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed left;
    left = (call.arg(0)).toSInt();

    GLfixed right;
    right = (call.arg(1)).toSInt();

    GLfixed bottom;
    bottom = (call.arg(2)).toSInt();

    GLfixed top;
    top = (call.arg(3)).toSInt();

    GLfixed zNear;
    zNear = (call.arg(4)).toSInt();

    GLfixed zFar;
    zFar = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFrustumx(left, right, bottom, top, zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightModelx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfixed param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightModelx(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightModelxv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfixed * params;
    params = static_cast<GLfixed *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfixed10_0 = (call.arg(1)).toArray();
        for (size_t _jGLfixed10 = 0; _jGLfixed10 < _a_GLfixed10_0->values.size(); ++_jGLfixed10) {
    params[_jGLfixed10] = (*_a_GLfixed10_0->values[_jGLfixed10]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightModelxv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightx(light, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLightxv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum light;
    light = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed * params;
    params = static_cast<GLfixed *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfixed11_0 = (call.arg(2)).toArray();
        for (size_t _jGLfixed11 = 0; _jGLfixed11 < _a_GLfixed11_0->values.size(); ++_jGLfixed11) {
    params[_jGLfixed11] = (*_a_GLfixed11_0->values[_jGLfixed11]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLightxv(light, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLineWidthx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed width;
    width = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLineWidthx(width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadMatrixx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed * m;
    m = static_cast<GLfixed *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfixed12_0 = (call.arg(0)).toArray();
        for (size_t _jGLfixed12 = 0; _jGLfixed12 < _a_GLfixed12_0->values.size(); ++_jGLfixed12) {
    m[_jGLfixed12] = (*_a_GLfixed12_0->values[_jGLfixed12]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadMatrixx(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMaterialx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMaterialx(face, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMaterialxv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum face;
    face = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed * params;
    params = static_cast<GLfixed *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfixed13_0 = (call.arg(2)).toArray();
        for (size_t _jGLfixed13 = 0; _jGLfixed13 < _a_GLfixed13_0->values.size(); ++_jGLfixed13) {
    params[_jGLfixed13] = (*_a_GLfixed13_0->values[_jGLfixed13]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMaterialxv(face, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultMatrixx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed * m;
    m = static_cast<GLfixed *>(_allocator.alloc(&call.arg(0), sizeof *m));
    if (m) {
        const trace::Array *_a_GLfixed14_0 = (call.arg(0)).toArray();
        for (size_t _jGLfixed14 = 0; _jGLfixed14 < _a_GLfixed14_0->values.size(); ++_jGLfixed14) {
    m[_jGLfixed14] = (*_a_GLfixed14_0->values[_jGLfixed14]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultMatrixx(m);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMultiTexCoord4x(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfixed s;
    s = (call.arg(1)).toSInt();

    GLfixed t;
    t = (call.arg(2)).toSInt();

    GLfixed r;
    r = (call.arg(3)).toSInt();

    GLfixed q;
    q = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMultiTexCoord4x(target, s, t, r, q);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glNormal3x(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed nx;
    nx = (call.arg(0)).toSInt();

    GLfixed ny;
    ny = (call.arg(1)).toSInt();

    GLfixed nz;
    nz = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glNormal3x(nx, ny, nz);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glOrthox(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed left;
    left = (call.arg(0)).toSInt();

    GLfixed right;
    right = (call.arg(1)).toSInt();

    GLfixed bottom;
    bottom = (call.arg(2)).toSInt();

    GLfixed top;
    top = (call.arg(3)).toSInt();

    GLfixed zNear;
    zNear = (call.arg(4)).toSInt();

    GLfixed zFar;
    zFar = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glOrthox(left, right, bottom, top, zNear, zFar);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointSizex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed size;
    size = (call.arg(0)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointSizex(size);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPolygonOffsetx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed factor;
    factor = (call.arg(0)).toSInt();

    GLfixed units;
    units = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPolygonOffsetx(factor, units);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRotatex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed angle;
    angle = (call.arg(0)).toSInt();

    GLfixed x;
    x = (call.arg(1)).toSInt();

    GLfixed y;
    y = (call.arg(2)).toSInt();

    GLfixed z;
    z = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRotatex(angle, x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glSampleCoveragex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLclampx value;
    value = (call.arg(0)).toSInt();

    GLboolean invert;
    invert = static_cast<GLboolean>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glSampleCoveragex(value, invert);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glScalex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed x;
    x = (call.arg(0)).toSInt();

    GLfixed y;
    y = (call.arg(1)).toSInt();

    GLfixed z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glScalex(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexEnvx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexEnvx(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexEnvxv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed * params;
    params = static_cast<GLfixed *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfixed15_0 = (call.arg(2)).toArray();
        for (size_t _jGLfixed15 = 0; _jGLfixed15 < _a_GLfixed15_0->values.size(); ++_jGLfixed15) {
    params[_jGLfixed15] = (*_a_GLfixed15_0->values[_jGLfixed15]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexEnvxv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameterx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameterx(target, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTranslatex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed x;
    x = (call.arg(0)).toSInt();

    GLfixed y;
    y = (call.arg(1)).toSInt();

    GLfixed z;
    z = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTranslatex(x, y, z);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glClipPlanex(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum plane;
    plane = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfixed * equation;
    equation = static_cast<GLfixed *>(_allocator.alloc(&call.arg(1), sizeof *equation));
    if (equation) {
        const trace::Array *_a_GLfixed16_0 = (call.arg(1)).toArray();
        for (size_t _jGLfixed16 = 0; _jGLfixed16 < _a_GLfixed16_0->values.size(); ++_jGLfixed16) {
    equation[_jGLfixed16] = (*_a_GLfixed16_0->values[_jGLfixed16]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glClipPlanex(plane, equation);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterx(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfixed param;
    param = (call.arg(1)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterx(pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointParameterxv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum pname;
    pname = static_cast<GLenum>((call.arg(0)).toSInt());

    GLfixed * params;
    params = static_cast<GLfixed *>(_allocator.alloc(&call.arg(1), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfixed17_0 = (call.arg(1)).toArray();
        for (size_t _jGLfixed17 = 0; _jGLfixed17 < _a_GLfixed17_0->values.size(); ++_jGLfixed17) {
    params[_jGLfixed17] = (*_a_GLfixed17_0->values[_jGLfixed17]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointParameterxv(pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexParameterxv(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed * params;
    params = static_cast<GLfixed *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfixed18_0 = (call.arg(2)).toArray();
        for (size_t _jGLfixed18 = 0; _jGLfixed18 < _a_GLfixed18_0->values.size(); ++_jGLfixed18) {
    params[_jGLfixed18] = (*_a_GLfixed18_0->values[_jGLfixed18]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexParameterxv(target, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationSeparateOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum modeRGB;
    modeRGB = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum modeAlpha;
    modeAlpha = static_cast<GLenum>((call.arg(1)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationSeparateOES(modeRGB, modeAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendFuncSeparateOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum sfactorRGB;
    sfactorRGB = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum dfactorRGB;
    dfactorRGB = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum sfactorAlpha;
    sfactorAlpha = static_cast<GLenum>((call.arg(2)).toSInt());

    GLenum dfactorAlpha;
    dfactorAlpha = static_cast<GLenum>((call.arg(3)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendFuncSeparateOES(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlendEquationOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlendEquationOES(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindRenderbufferOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffer) << " <- " << size_t(_renderbuffer_map[renderbuffer]) << "\n";
    }
    renderbuffer = _renderbuffer_map[renderbuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindRenderbufferOES(target, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteRenderbuffersOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * renderbuffers;
    renderbuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *renderbuffers));
    if (renderbuffers) {
        const trace::Array *_a_GLuint198_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint198 = 0; _jGLuint198 < _a_GLuint198_0->values.size(); ++_jGLuint198) {
    renderbuffers[_jGLuint198] = (*_a_GLuint198_0->values[_jGLuint198]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << size_t(renderbuffers[_jGLuint198]) << " <- " << size_t(_renderbuffer_map[renderbuffers[_jGLuint198]]) << "\n";
    }
    renderbuffers[_jGLuint198] = _renderbuffer_map[renderbuffers[_jGLuint198]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteRenderbuffersOES(n, renderbuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenRenderbuffersOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * renderbuffers;
    renderbuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *renderbuffers));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenRenderbuffersOES(n, renderbuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint200 = (call.arg(1)).toArray();
    if (_aGLuint200) {
        for (size_t _jGLuint200 = 0; _jGLuint200 < _aGLuint200->values.size(); ++_jGLuint200) {
    GLuint _origResult;
    _origResult = (*_aGLuint200->values[_jGLuint200]).toUInt();
    _renderbuffer_map[_origResult] = renderbuffers[_jGLuint200];
    if (retrace::verbosity >= 2) {
        std::cout << "renderbuffer " << _origResult << " -> " << renderbuffers[_jGLuint200] << "\n";
    }
        }
    }
}

static void retrace_glRenderbufferStorageOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei width;
    width = (call.arg(2)).toSInt();

    GLsizei height;
    height = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorageOES(target, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindFramebufferOES(trace::Call &call) {
    assert(call.flags & trace::CALL_FLAG_SWAP_RENDERTARGET);
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint framebuffer;
    framebuffer = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffer) << " <- " << size_t(_framebuffer_map[framebuffer]) << "\n";
    }
    framebuffer = _framebuffer_map[framebuffer];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindFramebufferOES(target, framebuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteFramebuffersOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * framebuffers;
    framebuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *framebuffers));
    if (framebuffers) {
        const trace::Array *_a_GLuint201_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint201 = 0; _jGLuint201 < _a_GLuint201_0->values.size(); ++_jGLuint201) {
    framebuffers[_jGLuint201] = (*_a_GLuint201_0->values[_jGLuint201]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << size_t(framebuffers[_jGLuint201]) << " <- " << size_t(_framebuffer_map[framebuffers[_jGLuint201]]) << "\n";
    }
    framebuffers[_jGLuint201] = _framebuffer_map[framebuffers[_jGLuint201]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteFramebuffersOES(n, framebuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenFramebuffersOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * framebuffers;
    framebuffers = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *framebuffers));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenFramebuffersOES(n, framebuffers);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint203 = (call.arg(1)).toArray();
    if (_aGLuint203) {
        for (size_t _jGLuint203 = 0; _jGLuint203 < _aGLuint203->values.size(); ++_jGLuint203) {
    GLuint _origResult;
    _origResult = (*_aGLuint203->values[_jGLuint203]).toUInt();
    _framebuffer_map[_origResult] = framebuffers[_jGLuint203];
    if (retrace::verbosity >= 2) {
        std::cout << "framebuffer " << _origResult << " -> " << framebuffers[_jGLuint203] << "\n";
    }
        }
    }
}

static void retrace_glCheckFramebufferStatusOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCheckFramebufferStatusOES(target);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture2DOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture2DOES(target, attachment, textarget, texture, level);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferRenderbufferOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum renderbuffertarget;
    renderbuffertarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint renderbuffer;
    renderbuffer = (call.arg(3)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenerateMipmapOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenerateMipmapOES(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCurrentPaletteMatrixOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint index;
    index = (call.arg(0)).toUInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCurrentPaletteMatrixOES(index);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLoadPaletteFromModelViewMatrixOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLoadPaletteFromModelViewMatrixOES();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMatrixIndexPointerOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glMatrixIndexPointerOES(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glWeightPointerOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint size;
    size = (call.arg(0)).toSInt();

    GLenum type;
    type = static_cast<GLenum>((call.arg(1)).toSInt());

    GLsizei stride;
    stride = (call.arg(2)).toSInt();

    const GLvoid * pointer;
    memset(&pointer, 0, sizeof pointer); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glWeightPointerOES(size, type, stride, pointer);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glPointSizePointerOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei stride;
    stride = (call.arg(1)).toSInt();

    const GLvoid * ptr;
    memset(&ptr, 0, sizeof ptr); // FIXME

    if (1) {
    if (retrace::verbosity >= 0) {
        retrace::unsupported(call);
    }
    return;
    }
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glPointSizePointerOES(type, stride, ptr);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glQueryMatrixxOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfixed * mantissa;
    mantissa = static_cast<GLfixed *>(_allocator.alloc(&call.arg(0), sizeof *mantissa));
    if (mantissa) {
        const trace::Array *_a_GLfixed19_0 = (call.arg(0)).toArray();
        for (size_t _jGLfixed19 = 0; _jGLfixed19 < _a_GLfixed19_0->values.size(); ++_jGLfixed19) {
    mantissa[_jGLfixed19] = (*_a_GLfixed19_0->values[_jGLfixed19]).toSInt();
        }
    }

    GLint * exponent;
    exponent = static_cast<GLint *>(_allocator.alloc(&call.arg(1), sizeof *exponent));
    if (exponent) {
        const trace::Array *_a_GLint229_0 = (call.arg(1)).toArray();
        for (size_t _jGLint229 = 0; _jGLint229 < _a_GLint229_0->values.size(); ++_jGLint229) {
    exponent[_jGLint229] = (*_a_GLint229_0->values[_jGLint229]).toSInt();
        }
    }

    GLbitfield _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glQueryMatrixxOES(mantissa, exponent);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGenfOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat param;
    param = (call.arg(2)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGenfOES(coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGenfvOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfloat * params;
    params = static_cast<GLfloat *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfloat301_0 = (call.arg(2)).toArray();
        for (size_t _jGLfloat301 = 0; _jGLfloat301 < _a_GLfloat301_0->values.size(); ++_jGLfloat301) {
    params[_jGLfloat301] = (*_a_GLfloat301_0->values[_jGLfloat301]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGenfvOES(coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGeniOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGeniOES(coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGenivOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLint * params;
    params = static_cast<GLint *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLint230_0 = (call.arg(2)).toArray();
        for (size_t _jGLint230 = 0; _jGLint230 < _a_GLint230_0->values.size(); ++_jGLint230) {
    params[_jGLint230] = (*_a_GLint230_0->values[_jGLint230]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGenivOES(coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGenxOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed param;
    param = (call.arg(2)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGenxOES(coord, pname, param);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexGenxvOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum coord;
    coord = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum pname;
    pname = static_cast<GLenum>((call.arg(1)).toSInt());

    GLfixed * params;
    params = static_cast<GLfixed *>(_allocator.alloc(&call.arg(2), sizeof *params));
    if (params) {
        const trace::Array *_a_GLfixed20_0 = (call.arg(2)).toArray();
        for (size_t _jGLfixed20 = 0; _jGLfixed20 < _a_GLfixed20_0->values.size(); ++_jGLfixed20) {
    params[_jGLfixed20] = (*_a_GLfixed20_0->values[_jGLfixed20]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexGenxvOES(coord, pname, params);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glMapBufferOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum access;
    access = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glMapBufferOES(target, access);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to map buffer\n";
        }
    }
    GLint length = 0;
    glGetBufferParameteriv(target, GL_BUFFER_SIZE, &length);
    retrace::addRegion((*call.ret).toUIntPtr(), _result, length);
}

static void retrace_glUnmapBufferOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLboolean _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
        GLvoid *ptr = NULL;
            glGetBufferPointervOES(target, GL_BUFFER_MAP_POINTER_OES, &ptr);
        if (ptr) {
            retrace::delRegionByPointer(ptr);
        } else {
            retrace::warning(call) << "no current context\n";
        }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glUnmapBufferOES(target);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
        if (!_result) {
             retrace::warning(call) << "failed to unmap buffer\n";
        }
    }
}

static void retrace_glTexImage3DOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(7)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(8)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(9)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexImage3DOES(target, level, internalformat, width, height, depth, border, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexSubImage3DOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLsizei depth;
    depth = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLenum type;
    type = static_cast<GLenum>((call.arg(9)).toSInt());

    GLvoid * pixels;
    pixels = static_cast<GLvoid *>((call.arg(10)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCopyTexSubImage3DOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLint x;
    x = (call.arg(5)).toSInt();

    GLint y;
    y = (call.arg(6)).toSInt();

    GLsizei width;
    width = (call.arg(7)).toSInt();

    GLsizei height;
    height = (call.arg(8)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexImage3DOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    GLint border;
    border = (call.arg(6)).toSInt();

    GLsizei imageSize;
    imageSize = (call.arg(7)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(8)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCompressedTexSubImage3DOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLint level;
    level = (call.arg(1)).toSInt();

    GLint xoffset;
    xoffset = (call.arg(2)).toSInt();

    GLint yoffset;
    yoffset = (call.arg(3)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(4)).toSInt();

    GLsizei width;
    width = (call.arg(5)).toSInt();

    GLsizei height;
    height = (call.arg(6)).toSInt();

    GLsizei depth;
    depth = (call.arg(7)).toSInt();

    GLenum format;
    format = static_cast<GLenum>((call.arg(8)).toSInt());

    GLsizei imageSize;
    imageSize = (call.arg(9)).toSInt();

    GLvoid * data;
    data = static_cast<GLvoid *>((call.arg(10)).toPointer());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture3DOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    GLint zoffset;
    zoffset = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glProgramBinaryOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint program;
    program = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    GLenum binaryFormat;
    binaryFormat = static_cast<GLenum>((call.arg(1)).toSInt());

    GLvoid * binary;
    binary = static_cast<GLvoid *>((call.arg(2)).toPointer());

    GLsizei length;
    length = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glProgramBinaryOES(program, binaryFormat, binary, length);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTexfOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat x;
    x = (call.arg(0)).toFloat();

    GLfloat y;
    y = (call.arg(1)).toFloat();

    GLfloat z;
    z = (call.arg(2)).toFloat();

    GLfloat width;
    width = (call.arg(3)).toFloat();

    GLfloat height;
    height = (call.arg(4)).toFloat();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTexfOES(x, y, z, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTexfvOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLfloat * coords;
    coords = static_cast<GLfloat *>(_allocator.alloc(&call.arg(0), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLfloat302_0 = (call.arg(0)).toArray();
        for (size_t _jGLfloat302 = 0; _jGLfloat302 < _a_GLfloat302_0->values.size(); ++_jGLfloat302) {
    coords[_jGLfloat302] = (*_a_GLfloat302_0->values[_jGLfloat302]).toFloat();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTexfvOES(coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTexiOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint x;
    x = (call.arg(0)).toSInt();

    GLint y;
    y = (call.arg(1)).toSInt();

    GLint z;
    z = (call.arg(2)).toSInt();

    GLint width;
    width = (call.arg(3)).toSInt();

    GLint height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTexiOES(x, y, z, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTexivOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint * coords;
    coords = static_cast<GLint *>(_allocator.alloc(&call.arg(0), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLint231_0 = (call.arg(0)).toArray();
        for (size_t _jGLint231 = 0; _jGLint231 < _a_GLint231_0->values.size(); ++_jGLint231) {
    coords[_jGLint231] = (*_a_GLint231_0->values[_jGLint231]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTexivOES(coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTexsOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort x;
    x = (call.arg(0)).toSInt();

    GLshort y;
    y = (call.arg(1)).toSInt();

    GLshort z;
    z = (call.arg(2)).toSInt();

    GLshort width;
    width = (call.arg(3)).toSInt();

    GLshort height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTexsOES(x, y, z, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawTexsvOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLshort * coords;
    coords = static_cast<GLshort *>(_allocator.alloc(&call.arg(0), sizeof *coords));
    if (coords) {
        const trace::Array *_a_GLshort54_0 = (call.arg(0)).toArray();
        for (size_t _jGLshort54 = 0; _jGLshort54 < _a_GLshort54_0->values.size(); ++_jGLshort54) {
    coords[_jGLshort54] = (*_a_GLshort54_0->values[_jGLshort54]).toSInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawTexsvOES(coords);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDiscardFramebufferEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei numAttachments;
    numAttachments = (call.arg(1)).toSInt();

    GLenum * attachments;
    attachments = static_cast<GLenum *>(_allocator.alloc(&call.arg(2), sizeof *attachments));
    if (attachments) {
        const trace::Array *_a_GLenum18_0 = (call.arg(2)).toArray();
        for (size_t _jGLenum18 = 0; _jGLenum18 < _a_GLenum18_0->values.size(); ++_jGLenum18) {
    attachments[_jGLenum18] = static_cast<GLenum>((*_a_GLenum18_0->values[_jGLenum18]).toSInt());
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDiscardFramebufferEXT(target, numAttachments, attachments);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBindVertexArrayOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint array;
    array = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(array) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][array]) << "\n";
    }
    array = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][array];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindVertexArrayOES(array);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteVertexArraysOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * arrays;
    arrays = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *arrays));
    if (arrays) {
        const trace::Array *_a_GLuint204_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint204 = 0; _jGLuint204 < _a_GLuint204_0->values.size(); ++_jGLuint204) {
    arrays[_jGLuint204] = (*_a_GLuint204_0->values[_jGLuint204]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "array " << size_t(arrays[_jGLuint204]) << " <- " << size_t(_array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][arrays[_jGLuint204]]) << "\n";
    }
    arrays[_jGLuint204] = _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][arrays[_jGLuint204]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteVertexArraysOES(n, arrays);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenVertexArraysOES(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * arrays;
    arrays = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *arrays));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenVertexArraysOES(n, arrays);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint206 = (call.arg(1)).toArray();
    if (_aGLuint206) {
        for (size_t _jGLuint206 = 0; _jGLuint206 < _aGLuint206->values.size(); ++_jGLuint206) {
    GLuint _origResult;
    _origResult = (*_aGLuint206->values[_jGLuint206]).toUInt();
    _array_map[reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())][_origResult] = arrays[_jGLuint206];
    if (retrace::verbosity >= 2) {
        std::cout << "array " << _origResult << " -> " << arrays[_jGLuint206] << "\n";
    }
        }
    }
}

static void retrace_glCoverageMaskNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLboolean mask;
    mask = static_cast<GLboolean>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCoverageMaskNV(mask);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCoverageOperationNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum operation;
    operation = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glCoverageOperationNV(operation);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRenderbufferStorageMultisampleIMG(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture2DMultisampleIMG(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    GLsizei samples;
    samples = (call.arg(5)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRenderbufferStorageMultisampleAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glResolveMultisampleFramebufferAPPLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glResolveMultisampleFramebufferAPPLE();
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBlitFramebufferANGLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLint srcX0;
    srcX0 = (call.arg(0)).toSInt();

    GLint srcY0;
    srcY0 = (call.arg(1)).toSInt();

    GLint srcX1;
    srcX1 = (call.arg(2)).toSInt();

    GLint srcY1;
    srcY1 = (call.arg(3)).toSInt();

    GLint dstX0;
    dstX0 = (call.arg(4)).toSInt();

    GLint dstY0;
    dstY0 = (call.arg(5)).toSInt();

    GLint dstX1;
    dstX1 = (call.arg(6)).toSInt();

    GLint dstY1;
    dstY1 = (call.arg(7)).toSInt();

    GLbitfield mask;
    mask = (call.arg(8)).toUInt();

    GLenum filter;
    filter = static_cast<GLenum>((call.arg(9)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glRenderbufferStorageMultisampleANGLE(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei samples;
    samples = (call.arg(1)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glRenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDrawBuffersNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLenum * bufs;
    bufs = static_cast<GLenum *>(_allocator.alloc(&call.arg(1), sizeof *bufs));
    if (bufs) {
        const trace::Array *_a_GLenum19_0 = (call.arg(1)).toArray();
        for (size_t _jGLenum19 = 0; _jGLenum19 < _a_GLenum19_0->values.size(); ++_jGLenum19) {
    bufs[_jGLenum19] = static_cast<GLenum>((*_a_GLenum19_0->values[_jGLenum19]).toSInt());
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDrawBuffersNV(n, bufs);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glReadBufferNV(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum mode;
    mode = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glReadBufferNV(mode);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glLabelObjectEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint object;
    object = (call.arg(1)).toUInt();

    GLsizei length;
    length = (call.arg(2)).toSInt();

    const GLchar * label;
    label = (const GLchar *)((call.arg(3)).toString());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glLabelObjectEXT(type, object, length, label);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenQueriesEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenQueriesEXT(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint208 = (call.arg(1)).toArray();
    if (_aGLuint208) {
        for (size_t _jGLuint208 = 0; _jGLuint208 < _aGLuint208->values.size(); ++_jGLuint208) {
    GLuint _origResult;
    _origResult = (*_aGLuint208->values[_jGLuint208]).toUInt();
    _query_map[_origResult] = ids[_jGLuint208];
    if (retrace::verbosity >= 2) {
        std::cout << "query " << _origResult << " -> " << ids[_jGLuint208] << "\n";
    }
        }
    }
}

static void retrace_glDeleteQueriesEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * ids;
    ids = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *ids));
    if (ids) {
        const trace::Array *_a_GLuint209_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint209 = 0; _jGLuint209 < _a_GLuint209_0->values.size(); ++_jGLuint209) {
    ids[_jGLuint209] = (*_a_GLuint209_0->values[_jGLuint209]).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(ids[_jGLuint209]) << " <- " << size_t(_query_map[ids[_jGLuint209]]) << "\n";
    }
    ids[_jGLuint209] = _query_map[ids[_jGLuint209]];
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteQueriesEXT(n, ids);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glBeginQueryEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLuint id;
    id = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "query " << size_t(id) << " <- " << size_t(_query_map[id]) << "\n";
    }
    id = _query_map[id];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBeginQueryEXT(target, id);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glEndQueryEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glEndQueryEXT(target);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glUseProgramStagesEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint pipeline;
    pipeline = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << size_t(pipeline) << " <- " << size_t(_pipeline_map[pipeline]) << "\n";
    }
    pipeline = _pipeline_map[pipeline];

    GLbitfield stages;
    stages = (call.arg(1)).toUInt();

    GLuint program;
    program = (call.arg(2)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glUseProgramStagesEXT(pipeline, stages, program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glActiveShaderProgramEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint pipeline;
    pipeline = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << size_t(pipeline) << " <- " << size_t(_pipeline_map[pipeline]) << "\n";
    }
    pipeline = _pipeline_map[pipeline];

    GLuint program;
    program = (call.arg(1)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "program " << size_t(program) << " <- " << size_t(_program_map[program]) << "\n";
    }
if (glretrace::supportsARBShaderObjects) {
    program = _handleARB_map[program];
} else {
    program = _program_map[program];
}

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glActiveShaderProgramEXT(pipeline, program);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glCreateShaderProgramvEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum type;
    type = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei count;
    count = (call.arg(1)).toSInt();

    const GLchar * * strings;
    strings = static_cast<const GLchar * *>(_allocator.alloc(&call.arg(2), sizeof *strings));
    if (strings) {
        const trace::Array *_a_constGLchar20_0 = (call.arg(2)).toArray();
        for (size_t _jconstGLchar20 = 0; _jconstGLchar20 < _a_constGLchar20_0->values.size(); ++_jconstGLchar20) {
    strings[_jconstGLchar20] = (const GLchar *)((*_a_constGLchar20_0->values[_jconstGLchar20]).toString());
        }
    }

    GLuint _result;
    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    _result = glCreateShaderProgramvEXT(type, count, strings);
    (void)_result;
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    GLuint _origResult;
    _origResult = (*call.ret).toUInt();
if (glretrace::supportsARBShaderObjects) {
    _handleARB_map[_origResult] = _result;
} else {
    _program_map[_origResult] = _result;
}
    if (retrace::verbosity >= 2) {
        std::cout << "program " << _origResult << " -> " << _result << "\n";
    }
}

static void retrace_glBindProgramPipelineEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint pipeline;
    pipeline = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << size_t(pipeline) << " <- " << size_t(_pipeline_map[pipeline]) << "\n";
    }
    pipeline = _pipeline_map[pipeline];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (pipeline) {
        _pipelineHasBeenBound = true;
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glBindProgramPipelineEXT(pipeline);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glDeleteProgramPipelinesEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * pipelines;
    pipelines = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *pipelines));
    if (pipelines) {
        const trace::Array *_a_GLuint210_0 = (call.arg(1)).toArray();
        for (size_t _jGLuint210 = 0; _jGLuint210 < _a_GLuint210_0->values.size(); ++_jGLuint210) {
    pipelines[_jGLuint210] = (*_a_GLuint210_0->values[_jGLuint210]).toUInt();
        }
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glDeleteProgramPipelinesEXT(n, pipelines);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glGenProgramPipelinesEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLsizei n;
    n = (call.arg(0)).toSInt();

    GLuint * pipelines;
    pipelines = static_cast<GLuint *>(_allocator.alloc(&call.arg(1), sizeof *pipelines));

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glGenProgramPipelinesEXT(n, pipelines);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
    const trace::Array *_aGLuint212 = (call.arg(1)).toArray();
    if (_aGLuint212) {
        for (size_t _jGLuint212 = 0; _jGLuint212 < _aGLuint212->values.size(); ++_jGLuint212) {
    GLuint _origResult;
    _origResult = (*_aGLuint212->values[_jGLuint212]).toUInt();
    _pipeline_map[_origResult] = pipelines[_jGLuint212];
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << _origResult << " -> " << pipelines[_jGLuint212] << "\n";
    }
        }
    }
}

static void retrace_glValidateProgramPipelineEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLuint pipeline;
    pipeline = (call.arg(0)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "pipeline " << size_t(pipeline) << " <- " << size_t(_pipeline_map[pipeline]) << "\n";
    }
    pipeline = _pipeline_map[pipeline];

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glValidateProgramPipelineEXT(pipeline);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glFramebufferTexture2DMultisampleEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLenum attachment;
    attachment = static_cast<GLenum>((call.arg(1)).toSInt());

    GLenum textarget;
    textarget = static_cast<GLenum>((call.arg(2)).toSInt());

    GLuint texture;
    texture = (call.arg(3)).toUInt();
    if (retrace::verbosity >= 2) {
        std::cout << "texture " << size_t(texture) << " <- " << size_t(_texture_map[texture]) << "\n";
    }
    texture = _texture_map[texture];

    GLint level;
    level = (call.arg(4)).toSInt();

    GLsizei samples;
    samples = (call.arg(5)).toSInt();
    GLint max_samples = 0;
    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
    if (samples > max_samples) {
        samples = max_samples;
    }

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glFramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorage1DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei levels;
    levels = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorage1DEXT(target, levels, internalformat, width);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorage2DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei levels;
    levels = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorage2DEXT(target, levels, internalformat, width, height);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

static void retrace_glTexStorage3DEXT(trace::Call &call) {
    retrace::ScopedAllocator _allocator;
    (void)_allocator;
    GLenum target;
    target = static_cast<GLenum>((call.arg(0)).toSInt());

    GLsizei levels;
    levels = (call.arg(1)).toSInt();

    GLenum internalformat;
    internalformat = static_cast<GLenum>((call.arg(2)).toSInt());

    GLsizei width;
    width = (call.arg(3)).toSInt();

    GLsizei height;
    height = (call.arg(4)).toSInt();

    GLsizei depth;
    depth = (call.arg(5)).toSInt();

    if (retrace::debug && !glretrace::getCurrentContext()) {
        retrace::warning(call) << "no current context\n";
    }
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::beginProfile(call, false);
    }
    glTexStorage3DEXT(target, levels, internalformat, width, height, depth);
    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {
        glretrace::endProfile(call, false);
    }
    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {
        glretrace::checkGlError(call);
    }
}

const retrace::Entry glretrace::gl_callbacks[] = {
    {"glCullFace", &retrace_glCullFace},
    {"glFrontFace", &retrace_glFrontFace},
    {"glHint", &retrace_glHint},
    {"glLineWidth", &retrace_glLineWidth},
    {"glPointSize", &retrace_glPointSize},
    {"glPolygonMode", &retrace_glPolygonMode},
    {"glScissor", &retrace_glScissor},
    {"glTexParameterf", &retrace_glTexParameterf},
    {"glTexParameterfv", &retrace_glTexParameterfv},
    {"glTexParameteri", &retrace_glTexParameteri},
    {"glTexParameteriv", &retrace_glTexParameteriv},
    {"glTexImage1D", &retrace_glTexImage1D},
    {"glTexImage2D", &retrace_glTexImage2D},
    {"glDrawBuffer", &retrace_glDrawBuffer},
    {"glClear", &retrace_glClear},
    {"glClearColor", &retrace_glClearColor},
    {"glClearStencil", &retrace_glClearStencil},
    {"glClearDepth", &retrace_glClearDepth},
    {"glStencilMask", &retrace_glStencilMask},
    {"glColorMask", &retrace_glColorMask},
    {"glDepthMask", &retrace_glDepthMask},
    {"glDisable", &retrace_glDisable},
    {"glEnable", &retrace_glEnable},
    {"glFinish", &retrace_glFinish},
    {"glFlush", &retrace_glFlush},
    {"glBlendFunc", &retrace_glBlendFunc},
    {"glLogicOp", &retrace_glLogicOp},
    {"glStencilFunc", &retrace_glStencilFunc},
    {"glStencilOp", &retrace_glStencilOp},
    {"glDepthFunc", &retrace_glDepthFunc},
    {"glPixelStoref", &retrace_glPixelStoref},
    {"glPixelStorei", &retrace_glPixelStorei},
    {"glReadBuffer", &retrace_glReadBuffer},
    {"glReadPixels", &retrace_glReadPixels},
    {"glGetBooleanv", &retrace::ignore},
    {"glGetDoublev", &retrace::ignore},
    {"glGetError", &retrace::ignore},
    {"glGetFloatv", &retrace::ignore},
    {"glGetIntegerv", &retrace::ignore},
    {"glGetString", &retrace::ignore},
    {"glGetTexImage", &retrace_glGetTexImage},
    {"glGetTexParameterfv", &retrace::ignore},
    {"glGetTexParameteriv", &retrace::ignore},
    {"glGetTexLevelParameterfv", &retrace::ignore},
    {"glGetTexLevelParameteriv", &retrace::ignore},
    {"glIsEnabled", &retrace::ignore},
    {"glDepthRange", &retrace_glDepthRange},
    {"glViewport", &retrace_glViewport},
    {"glNewList", &retrace_glNewList},
    {"glEndList", &retrace_glEndList},
    {"glCallList", &retrace_glCallList},
    {"glCallLists", &retrace_glCallLists},
    {"glDeleteLists", &retrace_glDeleteLists},
    {"glGenLists", &retrace_glGenLists},
    {"glListBase", &retrace_glListBase},
    {"glBegin", &retrace_glBegin},
    {"glBitmap", &retrace_glBitmap},
    {"glColor3b", &retrace_glColor3b},
    {"glColor3bv", &retrace_glColor3bv},
    {"glColor3d", &retrace_glColor3d},
    {"glColor3dv", &retrace_glColor3dv},
    {"glColor3f", &retrace_glColor3f},
    {"glColor3fv", &retrace_glColor3fv},
    {"glColor3i", &retrace_glColor3i},
    {"glColor3iv", &retrace_glColor3iv},
    {"glColor3s", &retrace_glColor3s},
    {"glColor3sv", &retrace_glColor3sv},
    {"glColor3ub", &retrace_glColor3ub},
    {"glColor3ubv", &retrace_glColor3ubv},
    {"glColor3ui", &retrace_glColor3ui},
    {"glColor3uiv", &retrace_glColor3uiv},
    {"glColor3us", &retrace_glColor3us},
    {"glColor3usv", &retrace_glColor3usv},
    {"glColor4b", &retrace_glColor4b},
    {"glColor4bv", &retrace_glColor4bv},
    {"glColor4d", &retrace_glColor4d},
    {"glColor4dv", &retrace_glColor4dv},
    {"glColor4f", &retrace_glColor4f},
    {"glColor4fv", &retrace_glColor4fv},
    {"glColor4i", &retrace_glColor4i},
    {"glColor4iv", &retrace_glColor4iv},
    {"glColor4s", &retrace_glColor4s},
    {"glColor4sv", &retrace_glColor4sv},
    {"glColor4ub", &retrace_glColor4ub},
    {"glColor4ubv", &retrace_glColor4ubv},
    {"glColor4ui", &retrace_glColor4ui},
    {"glColor4uiv", &retrace_glColor4uiv},
    {"glColor4us", &retrace_glColor4us},
    {"glColor4usv", &retrace_glColor4usv},
    {"glEdgeFlag", &retrace_glEdgeFlag},
    {"glEdgeFlagv", &retrace_glEdgeFlagv},
    {"glEnd", &retrace_glEnd},
    {"glIndexd", &retrace_glIndexd},
    {"glIndexdv", &retrace_glIndexdv},
    {"glIndexf", &retrace_glIndexf},
    {"glIndexfv", &retrace_glIndexfv},
    {"glIndexi", &retrace_glIndexi},
    {"glIndexiv", &retrace_glIndexiv},
    {"glIndexs", &retrace_glIndexs},
    {"glIndexsv", &retrace_glIndexsv},
    {"glNormal3b", &retrace_glNormal3b},
    {"glNormal3bv", &retrace_glNormal3bv},
    {"glNormal3d", &retrace_glNormal3d},
    {"glNormal3dv", &retrace_glNormal3dv},
    {"glNormal3f", &retrace_glNormal3f},
    {"glNormal3fv", &retrace_glNormal3fv},
    {"glNormal3i", &retrace_glNormal3i},
    {"glNormal3iv", &retrace_glNormal3iv},
    {"glNormal3s", &retrace_glNormal3s},
    {"glNormal3sv", &retrace_glNormal3sv},
    {"glRasterPos2d", &retrace_glRasterPos2d},
    {"glRasterPos2dv", &retrace_glRasterPos2dv},
    {"glRasterPos2f", &retrace_glRasterPos2f},
    {"glRasterPos2fv", &retrace_glRasterPos2fv},
    {"glRasterPos2i", &retrace_glRasterPos2i},
    {"glRasterPos2iv", &retrace_glRasterPos2iv},
    {"glRasterPos2s", &retrace_glRasterPos2s},
    {"glRasterPos2sv", &retrace_glRasterPos2sv},
    {"glRasterPos3d", &retrace_glRasterPos3d},
    {"glRasterPos3dv", &retrace_glRasterPos3dv},
    {"glRasterPos3f", &retrace_glRasterPos3f},
    {"glRasterPos3fv", &retrace_glRasterPos3fv},
    {"glRasterPos3i", &retrace_glRasterPos3i},
    {"glRasterPos3iv", &retrace_glRasterPos3iv},
    {"glRasterPos3s", &retrace_glRasterPos3s},
    {"glRasterPos3sv", &retrace_glRasterPos3sv},
    {"glRasterPos4d", &retrace_glRasterPos4d},
    {"glRasterPos4dv", &retrace_glRasterPos4dv},
    {"glRasterPos4f", &retrace_glRasterPos4f},
    {"glRasterPos4fv", &retrace_glRasterPos4fv},
    {"glRasterPos4i", &retrace_glRasterPos4i},
    {"glRasterPos4iv", &retrace_glRasterPos4iv},
    {"glRasterPos4s", &retrace_glRasterPos4s},
    {"glRasterPos4sv", &retrace_glRasterPos4sv},
    {"glRectd", &retrace_glRectd},
    {"glRectdv", &retrace_glRectdv},
    {"glRectf", &retrace_glRectf},
    {"glRectfv", &retrace_glRectfv},
    {"glRecti", &retrace_glRecti},
    {"glRectiv", &retrace_glRectiv},
    {"glRects", &retrace_glRects},
    {"glRectsv", &retrace_glRectsv},
    {"glTexCoord1d", &retrace_glTexCoord1d},
    {"glTexCoord1dv", &retrace_glTexCoord1dv},
    {"glTexCoord1f", &retrace_glTexCoord1f},
    {"glTexCoord1fv", &retrace_glTexCoord1fv},
    {"glTexCoord1i", &retrace_glTexCoord1i},
    {"glTexCoord1iv", &retrace_glTexCoord1iv},
    {"glTexCoord1s", &retrace_glTexCoord1s},
    {"glTexCoord1sv", &retrace_glTexCoord1sv},
    {"glTexCoord2d", &retrace_glTexCoord2d},
    {"glTexCoord2dv", &retrace_glTexCoord2dv},
    {"glTexCoord2f", &retrace_glTexCoord2f},
    {"glTexCoord2fv", &retrace_glTexCoord2fv},
    {"glTexCoord2i", &retrace_glTexCoord2i},
    {"glTexCoord2iv", &retrace_glTexCoord2iv},
    {"glTexCoord2s", &retrace_glTexCoord2s},
    {"glTexCoord2sv", &retrace_glTexCoord2sv},
    {"glTexCoord3d", &retrace_glTexCoord3d},
    {"glTexCoord3dv", &retrace_glTexCoord3dv},
    {"glTexCoord3f", &retrace_glTexCoord3f},
    {"glTexCoord3fv", &retrace_glTexCoord3fv},
    {"glTexCoord3i", &retrace_glTexCoord3i},
    {"glTexCoord3iv", &retrace_glTexCoord3iv},
    {"glTexCoord3s", &retrace_glTexCoord3s},
    {"glTexCoord3sv", &retrace_glTexCoord3sv},
    {"glTexCoord4d", &retrace_glTexCoord4d},
    {"glTexCoord4dv", &retrace_glTexCoord4dv},
    {"glTexCoord4f", &retrace_glTexCoord4f},
    {"glTexCoord4fv", &retrace_glTexCoord4fv},
    {"glTexCoord4i", &retrace_glTexCoord4i},
    {"glTexCoord4iv", &retrace_glTexCoord4iv},
    {"glTexCoord4s", &retrace_glTexCoord4s},
    {"glTexCoord4sv", &retrace_glTexCoord4sv},
    {"glVertex2d", &retrace_glVertex2d},
    {"glVertex2dv", &retrace_glVertex2dv},
    {"glVertex2f", &retrace_glVertex2f},
    {"glVertex2fv", &retrace_glVertex2fv},
    {"glVertex2i", &retrace_glVertex2i},
    {"glVertex2iv", &retrace_glVertex2iv},
    {"glVertex2s", &retrace_glVertex2s},
    {"glVertex2sv", &retrace_glVertex2sv},
    {"glVertex3d", &retrace_glVertex3d},
    {"glVertex3dv", &retrace_glVertex3dv},
    {"glVertex3f", &retrace_glVertex3f},
    {"glVertex3fv", &retrace_glVertex3fv},
    {"glVertex3i", &retrace_glVertex3i},
    {"glVertex3iv", &retrace_glVertex3iv},
    {"glVertex3s", &retrace_glVertex3s},
    {"glVertex3sv", &retrace_glVertex3sv},
    {"glVertex4d", &retrace_glVertex4d},
    {"glVertex4dv", &retrace_glVertex4dv},
    {"glVertex4f", &retrace_glVertex4f},
    {"glVertex4fv", &retrace_glVertex4fv},
    {"glVertex4i", &retrace_glVertex4i},
    {"glVertex4iv", &retrace_glVertex4iv},
    {"glVertex4s", &retrace_glVertex4s},
    {"glVertex4sv", &retrace_glVertex4sv},
    {"glClipPlane", &retrace_glClipPlane},
    {"glColorMaterial", &retrace_glColorMaterial},
    {"glFogf", &retrace_glFogf},
    {"glFogfv", &retrace_glFogfv},
    {"glFogi", &retrace_glFogi},
    {"glFogiv", &retrace_glFogiv},
    {"glLightf", &retrace_glLightf},
    {"glLightfv", &retrace_glLightfv},
    {"glLighti", &retrace_glLighti},
    {"glLightiv", &retrace_glLightiv},
    {"glLightModelf", &retrace_glLightModelf},
    {"glLightModelfv", &retrace_glLightModelfv},
    {"glLightModeli", &retrace_glLightModeli},
    {"glLightModeliv", &retrace_glLightModeliv},
    {"glLineStipple", &retrace_glLineStipple},
    {"glMaterialf", &retrace_glMaterialf},
    {"glMaterialfv", &retrace_glMaterialfv},
    {"glMateriali", &retrace_glMateriali},
    {"glMaterialiv", &retrace_glMaterialiv},
    {"glPolygonStipple", &retrace_glPolygonStipple},
    {"glShadeModel", &retrace_glShadeModel},
    {"glTexEnvf", &retrace_glTexEnvf},
    {"glTexEnvfv", &retrace_glTexEnvfv},
    {"glTexEnvi", &retrace_glTexEnvi},
    {"glTexEnviv", &retrace_glTexEnviv},
    {"glTexGend", &retrace_glTexGend},
    {"glTexGendv", &retrace_glTexGendv},
    {"glTexGenf", &retrace_glTexGenf},
    {"glTexGenfv", &retrace_glTexGenfv},
    {"glTexGeni", &retrace_glTexGeni},
    {"glTexGeniv", &retrace_glTexGeniv},
    {"glFeedbackBuffer", &retrace_glFeedbackBuffer},
    {"glSelectBuffer", &retrace_glSelectBuffer},
    {"glRenderMode", &retrace_glRenderMode},
    {"glInitNames", &retrace_glInitNames},
    {"glLoadName", &retrace_glLoadName},
    {"glPassThrough", &retrace_glPassThrough},
    {"glPopName", &retrace_glPopName},
    {"glPushName", &retrace_glPushName},
    {"glClearAccum", &retrace_glClearAccum},
    {"glClearIndex", &retrace_glClearIndex},
    {"glIndexMask", &retrace_glIndexMask},
    {"glAccum", &retrace_glAccum},
    {"glPopAttrib", &retrace_glPopAttrib},
    {"glPushAttrib", &retrace_glPushAttrib},
    {"glMap1d", &retrace_glMap1d},
    {"glMap1f", &retrace_glMap1f},
    {"glMap2d", &retrace_glMap2d},
    {"glMap2f", &retrace_glMap2f},
    {"glMapGrid1d", &retrace_glMapGrid1d},
    {"glMapGrid1f", &retrace_glMapGrid1f},
    {"glMapGrid2d", &retrace_glMapGrid2d},
    {"glMapGrid2f", &retrace_glMapGrid2f},
    {"glEvalCoord1d", &retrace_glEvalCoord1d},
    {"glEvalCoord1dv", &retrace_glEvalCoord1dv},
    {"glEvalCoord1f", &retrace_glEvalCoord1f},
    {"glEvalCoord1fv", &retrace_glEvalCoord1fv},
    {"glEvalCoord2d", &retrace_glEvalCoord2d},
    {"glEvalCoord2dv", &retrace_glEvalCoord2dv},
    {"glEvalCoord2f", &retrace_glEvalCoord2f},
    {"glEvalCoord2fv", &retrace_glEvalCoord2fv},
    {"glEvalMesh1", &retrace_glEvalMesh1},
    {"glEvalPoint1", &retrace_glEvalPoint1},
    {"glEvalMesh2", &retrace_glEvalMesh2},
    {"glEvalPoint2", &retrace_glEvalPoint2},
    {"glAlphaFunc", &retrace_glAlphaFunc},
    {"glPixelZoom", &retrace_glPixelZoom},
    {"glPixelTransferf", &retrace_glPixelTransferf},
    {"glPixelTransferi", &retrace_glPixelTransferi},
    {"glPixelMapfv", &retrace_glPixelMapfv},
    {"glPixelMapuiv", &retrace_glPixelMapuiv},
    {"glPixelMapusv", &retrace_glPixelMapusv},
    {"glCopyPixels", &retrace_glCopyPixels},
    {"glDrawPixels", &retrace_glDrawPixels},
    {"glGetClipPlane", &retrace::ignore},
    {"glGetLightfv", &retrace::ignore},
    {"glGetLightiv", &retrace::ignore},
    {"glGetMapdv", &retrace::ignore},
    {"glGetMapfv", &retrace::ignore},
    {"glGetMapiv", &retrace::ignore},
    {"glGetMaterialfv", &retrace::ignore},
    {"glGetMaterialiv", &retrace::ignore},
    {"glGetPixelMapfv", &retrace_glGetPixelMapfv},
    {"glGetPixelMapuiv", &retrace_glGetPixelMapuiv},
    {"glGetPixelMapusv", &retrace_glGetPixelMapusv},
    {"glGetPolygonStipple", &retrace_glGetPolygonStipple},
    {"glGetTexEnvfv", &retrace::ignore},
    {"glGetTexEnviv", &retrace::ignore},
    {"glGetTexGendv", &retrace::ignore},
    {"glGetTexGenfv", &retrace::ignore},
    {"glGetTexGeniv", &retrace::ignore},
    {"glIsList", &retrace::ignore},
    {"glFrustum", &retrace_glFrustum},
    {"glLoadIdentity", &retrace_glLoadIdentity},
    {"glLoadMatrixf", &retrace_glLoadMatrixf},
    {"glLoadMatrixd", &retrace_glLoadMatrixd},
    {"glMatrixMode", &retrace_glMatrixMode},
    {"glMultMatrixf", &retrace_glMultMatrixf},
    {"glMultMatrixd", &retrace_glMultMatrixd},
    {"glOrtho", &retrace_glOrtho},
    {"glPopMatrix", &retrace_glPopMatrix},
    {"glPushMatrix", &retrace_glPushMatrix},
    {"glRotated", &retrace_glRotated},
    {"glRotatef", &retrace_glRotatef},
    {"glScaled", &retrace_glScaled},
    {"glScalef", &retrace_glScalef},
    {"glTranslated", &retrace_glTranslated},
    {"glTranslatef", &retrace_glTranslatef},
    {"glDrawArrays", &retrace_glDrawArrays},
    {"glDrawElements", &retrace_glDrawElements},
    {"glGetPointerv", &retrace::ignore},
    {"glPolygonOffset", &retrace_glPolygonOffset},
    {"glCopyTexImage1D", &retrace_glCopyTexImage1D},
    {"glCopyTexImage2D", &retrace_glCopyTexImage2D},
    {"glCopyTexSubImage1D", &retrace_glCopyTexSubImage1D},
    {"glCopyTexSubImage2D", &retrace_glCopyTexSubImage2D},
    {"glTexSubImage1D", &retrace_glTexSubImage1D},
    {"glTexSubImage2D", &retrace_glTexSubImage2D},
    {"glBindTexture", &retrace_glBindTexture},
    {"glDeleteTextures", &retrace_glDeleteTextures},
    {"glGenTextures", &retrace_glGenTextures},
    {"glIsTexture", &retrace::ignore},
    {"glArrayElement", &retrace_glArrayElement},
    {"glColorPointer", &retrace_glColorPointer},
    {"glDisableClientState", &retrace_glDisableClientState},
    {"glEdgeFlagPointer", &retrace_glEdgeFlagPointer},
    {"glEnableClientState", &retrace_glEnableClientState},
    {"glIndexPointer", &retrace_glIndexPointer},
    {"glInterleavedArrays", &retrace_glInterleavedArrays},
    {"glNormalPointer", &retrace_glNormalPointer},
    {"glTexCoordPointer", &retrace_glTexCoordPointer},
    {"glVertexPointer", &retrace_glVertexPointer},
    {"glAreTexturesResident", &retrace::ignore},
    {"glPrioritizeTextures", &retrace_glPrioritizeTextures},
    {"glIndexub", &retrace_glIndexub},
    {"glIndexubv", &retrace_glIndexubv},
    {"glPopClientAttrib", &retrace_glPopClientAttrib},
    {"glPushClientAttrib", &retrace_glPushClientAttrib},
    {"glBlendColor", &retrace_glBlendColor},
    {"glBlendEquation", &retrace_glBlendEquation},
    {"glDrawRangeElements", &retrace_glDrawRangeElements},
    {"glTexImage3D", &retrace_glTexImage3D},
    {"glTexSubImage3D", &retrace_glTexSubImage3D},
    {"glCopyTexSubImage3D", &retrace_glCopyTexSubImage3D},
    {"glColorTable", &retrace_glColorTable},
    {"glColorTableParameterfv", &retrace_glColorTableParameterfv},
    {"glColorTableParameteriv", &retrace_glColorTableParameteriv},
    {"glCopyColorTable", &retrace_glCopyColorTable},
    {"glGetColorTable", &retrace::ignore},
    {"glGetColorTableParameterfv", &retrace::ignore},
    {"glGetColorTableParameteriv", &retrace::ignore},
    {"glColorSubTable", &retrace_glColorSubTable},
    {"glCopyColorSubTable", &retrace_glCopyColorSubTable},
    {"glConvolutionFilter1D", &retrace_glConvolutionFilter1D},
    {"glConvolutionFilter2D", &retrace_glConvolutionFilter2D},
    {"glConvolutionParameterf", &retrace_glConvolutionParameterf},
    {"glConvolutionParameterfv", &retrace_glConvolutionParameterfv},
    {"glConvolutionParameteri", &retrace_glConvolutionParameteri},
    {"glConvolutionParameteriv", &retrace_glConvolutionParameteriv},
    {"glCopyConvolutionFilter1D", &retrace_glCopyConvolutionFilter1D},
    {"glCopyConvolutionFilter2D", &retrace_glCopyConvolutionFilter2D},
    {"glGetConvolutionFilter", &retrace_glGetConvolutionFilter},
    {"glGetConvolutionParameterfv", &retrace::ignore},
    {"glGetConvolutionParameteriv", &retrace::ignore},
    {"glGetSeparableFilter", &retrace_glGetSeparableFilter},
    {"glSeparableFilter2D", &retrace_glSeparableFilter2D},
    {"glGetHistogram", &retrace_glGetHistogram},
    {"glGetHistogramParameterfv", &retrace::ignore},
    {"glGetHistogramParameteriv", &retrace::ignore},
    {"glGetMinmax", &retrace_glGetMinmax},
    {"glGetMinmaxParameterfv", &retrace::ignore},
    {"glGetMinmaxParameteriv", &retrace::ignore},
    {"glHistogram", &retrace_glHistogram},
    {"glMinmax", &retrace_glMinmax},
    {"glResetHistogram", &retrace_glResetHistogram},
    {"glResetMinmax", &retrace_glResetMinmax},
    {"glActiveTexture", &retrace_glActiveTexture},
    {"glSampleCoverage", &retrace_glSampleCoverage},
    {"glCompressedTexImage3D", &retrace_glCompressedTexImage3D},
    {"glCompressedTexImage2D", &retrace_glCompressedTexImage2D},
    {"glCompressedTexImage1D", &retrace_glCompressedTexImage1D},
    {"glCompressedTexSubImage3D", &retrace_glCompressedTexSubImage3D},
    {"glCompressedTexSubImage2D", &retrace_glCompressedTexSubImage2D},
    {"glCompressedTexSubImage1D", &retrace_glCompressedTexSubImage1D},
    {"glGetCompressedTexImage", &retrace_glGetCompressedTexImage},
    {"glClientActiveTexture", &retrace_glClientActiveTexture},
    {"glMultiTexCoord1d", &retrace_glMultiTexCoord1d},
    {"glMultiTexCoord1dv", &retrace_glMultiTexCoord1dv},
    {"glMultiTexCoord1f", &retrace_glMultiTexCoord1f},
    {"glMultiTexCoord1fv", &retrace_glMultiTexCoord1fv},
    {"glMultiTexCoord1i", &retrace_glMultiTexCoord1i},
    {"glMultiTexCoord1iv", &retrace_glMultiTexCoord1iv},
    {"glMultiTexCoord1s", &retrace_glMultiTexCoord1s},
    {"glMultiTexCoord1sv", &retrace_glMultiTexCoord1sv},
    {"glMultiTexCoord2d", &retrace_glMultiTexCoord2d},
    {"glMultiTexCoord2dv", &retrace_glMultiTexCoord2dv},
    {"glMultiTexCoord2f", &retrace_glMultiTexCoord2f},
    {"glMultiTexCoord2fv", &retrace_glMultiTexCoord2fv},
    {"glMultiTexCoord2i", &retrace_glMultiTexCoord2i},
    {"glMultiTexCoord2iv", &retrace_glMultiTexCoord2iv},
    {"glMultiTexCoord2s", &retrace_glMultiTexCoord2s},
    {"glMultiTexCoord2sv", &retrace_glMultiTexCoord2sv},
    {"glMultiTexCoord3d", &retrace_glMultiTexCoord3d},
    {"glMultiTexCoord3dv", &retrace_glMultiTexCoord3dv},
    {"glMultiTexCoord3f", &retrace_glMultiTexCoord3f},
    {"glMultiTexCoord3fv", &retrace_glMultiTexCoord3fv},
    {"glMultiTexCoord3i", &retrace_glMultiTexCoord3i},
    {"glMultiTexCoord3iv", &retrace_glMultiTexCoord3iv},
    {"glMultiTexCoord3s", &retrace_glMultiTexCoord3s},
    {"glMultiTexCoord3sv", &retrace_glMultiTexCoord3sv},
    {"glMultiTexCoord4d", &retrace_glMultiTexCoord4d},
    {"glMultiTexCoord4dv", &retrace_glMultiTexCoord4dv},
    {"glMultiTexCoord4f", &retrace_glMultiTexCoord4f},
    {"glMultiTexCoord4fv", &retrace_glMultiTexCoord4fv},
    {"glMultiTexCoord4i", &retrace_glMultiTexCoord4i},
    {"glMultiTexCoord4iv", &retrace_glMultiTexCoord4iv},
    {"glMultiTexCoord4s", &retrace_glMultiTexCoord4s},
    {"glMultiTexCoord4sv", &retrace_glMultiTexCoord4sv},
    {"glLoadTransposeMatrixf", &retrace_glLoadTransposeMatrixf},
    {"glLoadTransposeMatrixd", &retrace_glLoadTransposeMatrixd},
    {"glMultTransposeMatrixf", &retrace_glMultTransposeMatrixf},
    {"glMultTransposeMatrixd", &retrace_glMultTransposeMatrixd},
    {"glBlendFuncSeparate", &retrace_glBlendFuncSeparate},
    {"glMultiDrawArrays", &retrace_glMultiDrawArrays},
    {"glMultiDrawElements", &retrace_glMultiDrawElements},
    {"glPointParameterf", &retrace_glPointParameterf},
    {"glPointParameterfv", &retrace_glPointParameterfv},
    {"glPointParameteri", &retrace_glPointParameteri},
    {"glPointParameteriv", &retrace_glPointParameteriv},
    {"glFogCoordf", &retrace_glFogCoordf},
    {"glFogCoordfv", &retrace_glFogCoordfv},
    {"glFogCoordd", &retrace_glFogCoordd},
    {"glFogCoorddv", &retrace_glFogCoorddv},
    {"glFogCoordPointer", &retrace_glFogCoordPointer},
    {"glSecondaryColor3b", &retrace_glSecondaryColor3b},
    {"glSecondaryColor3bv", &retrace_glSecondaryColor3bv},
    {"glSecondaryColor3d", &retrace_glSecondaryColor3d},
    {"glSecondaryColor3dv", &retrace_glSecondaryColor3dv},
    {"glSecondaryColor3f", &retrace_glSecondaryColor3f},
    {"glSecondaryColor3fv", &retrace_glSecondaryColor3fv},
    {"glSecondaryColor3i", &retrace_glSecondaryColor3i},
    {"glSecondaryColor3iv", &retrace_glSecondaryColor3iv},
    {"glSecondaryColor3s", &retrace_glSecondaryColor3s},
    {"glSecondaryColor3sv", &retrace_glSecondaryColor3sv},
    {"glSecondaryColor3ub", &retrace_glSecondaryColor3ub},
    {"glSecondaryColor3ubv", &retrace_glSecondaryColor3ubv},
    {"glSecondaryColor3ui", &retrace_glSecondaryColor3ui},
    {"glSecondaryColor3uiv", &retrace_glSecondaryColor3uiv},
    {"glSecondaryColor3us", &retrace_glSecondaryColor3us},
    {"glSecondaryColor3usv", &retrace_glSecondaryColor3usv},
    {"glSecondaryColorPointer", &retrace_glSecondaryColorPointer},
    {"glWindowPos2d", &retrace_glWindowPos2d},
    {"glWindowPos2dv", &retrace_glWindowPos2dv},
    {"glWindowPos2f", &retrace_glWindowPos2f},
    {"glWindowPos2fv", &retrace_glWindowPos2fv},
    {"glWindowPos2i", &retrace_glWindowPos2i},
    {"glWindowPos2iv", &retrace_glWindowPos2iv},
    {"glWindowPos2s", &retrace_glWindowPos2s},
    {"glWindowPos2sv", &retrace_glWindowPos2sv},
    {"glWindowPos3d", &retrace_glWindowPos3d},
    {"glWindowPos3dv", &retrace_glWindowPos3dv},
    {"glWindowPos3f", &retrace_glWindowPos3f},
    {"glWindowPos3fv", &retrace_glWindowPos3fv},
    {"glWindowPos3i", &retrace_glWindowPos3i},
    {"glWindowPos3iv", &retrace_glWindowPos3iv},
    {"glWindowPos3s", &retrace_glWindowPos3s},
    {"glWindowPos3sv", &retrace_glWindowPos3sv},
    {"glGenQueries", &retrace_glGenQueries},
    {"glDeleteQueries", &retrace_glDeleteQueries},
    {"glIsQuery", &retrace::ignore},
    {"glBeginQuery", &retrace_glBeginQuery},
    {"glEndQuery", &retrace_glEndQuery},
    {"glGetQueryiv", &retrace::ignore},
    {"glGetQueryObjectiv", &retrace::ignore},
    {"glGetQueryObjectuiv", &retrace::ignore},
    {"glBindBuffer", &retrace_glBindBuffer},
    {"glDeleteBuffers", &retrace_glDeleteBuffers},
    {"glGenBuffers", &retrace_glGenBuffers},
    {"glIsBuffer", &retrace::ignore},
    {"glBufferData", &retrace_glBufferData},
    {"glBufferSubData", &retrace_glBufferSubData},
    {"glGetBufferSubData", &retrace::ignore},
    {"glMapBuffer", &retrace_glMapBuffer},
    {"glUnmapBuffer", &retrace_glUnmapBuffer},
    {"glGetBufferParameteriv", &retrace::ignore},
    {"glGetBufferPointerv", &retrace::ignore},
    {"glBlendEquationSeparate", &retrace_glBlendEquationSeparate},
    {"glDrawBuffers", &retrace_glDrawBuffers},
    {"glStencilOpSeparate", &retrace_glStencilOpSeparate},
    {"glStencilFuncSeparate", &retrace_glStencilFuncSeparate},
    {"glStencilMaskSeparate", &retrace_glStencilMaskSeparate},
    {"glAttachShader", &retrace_glAttachShader},
    {"glBindAttribLocation", &retrace_glBindAttribLocation},
    {"glCompileShader", &retrace_glCompileShader},
    {"glCreateProgram", &retrace_glCreateProgram},
    {"glCreateShader", &retrace_glCreateShader},
    {"glDeleteProgram", &retrace_glDeleteProgram},
    {"glDeleteShader", &retrace_glDeleteShader},
    {"glDetachShader", &retrace_glDetachShader},
    {"glDisableVertexAttribArray", &retrace_glDisableVertexAttribArray},
    {"glEnableVertexAttribArray", &retrace_glEnableVertexAttribArray},
    {"glGetActiveAttrib", &retrace::ignore},
    {"glGetActiveUniform", &retrace::ignore},
    {"glGetAttachedShaders", &retrace::ignore},
    {"glGetAttribLocation", &retrace_glGetAttribLocation},
    {"glGetProgramiv", &retrace::ignore},
    {"glGetProgramInfoLog", &retrace::ignore},
    {"glGetShaderiv", &retrace::ignore},
    {"glGetShaderInfoLog", &retrace::ignore},
    {"glGetShaderSource", &retrace::ignore},
    {"glGetUniformLocation", &retrace_glGetUniformLocation},
    {"glGetUniformfv", &retrace::ignore},
    {"glGetUniformiv", &retrace::ignore},
    {"glGetVertexAttribdv", &retrace::ignore},
    {"glGetVertexAttribfv", &retrace::ignore},
    {"glGetVertexAttribiv", &retrace::ignore},
    {"glGetVertexAttribPointerv", &retrace::ignore},
    {"glIsProgram", &retrace::ignore},
    {"glIsShader", &retrace::ignore},
    {"glLinkProgram", &retrace_glLinkProgram},
    {"glShaderSource", &retrace_glShaderSource},
    {"glUseProgram", &retrace_glUseProgram},
    {"glUniform1f", &retrace_glUniform1f},
    {"glUniform2f", &retrace_glUniform2f},
    {"glUniform3f", &retrace_glUniform3f},
    {"glUniform4f", &retrace_glUniform4f},
    {"glUniform1i", &retrace_glUniform1i},
    {"glUniform2i", &retrace_glUniform2i},
    {"glUniform3i", &retrace_glUniform3i},
    {"glUniform4i", &retrace_glUniform4i},
    {"glUniform1fv", &retrace_glUniform1fv},
    {"glUniform2fv", &retrace_glUniform2fv},
    {"glUniform3fv", &retrace_glUniform3fv},
    {"glUniform4fv", &retrace_glUniform4fv},
    {"glUniform1iv", &retrace_glUniform1iv},
    {"glUniform2iv", &retrace_glUniform2iv},
    {"glUniform3iv", &retrace_glUniform3iv},
    {"glUniform4iv", &retrace_glUniform4iv},
    {"glUniformMatrix2fv", &retrace_glUniformMatrix2fv},
    {"glUniformMatrix3fv", &retrace_glUniformMatrix3fv},
    {"glUniformMatrix4fv", &retrace_glUniformMatrix4fv},
    {"glValidateProgram", &retrace_glValidateProgram},
    {"glVertexAttrib1d", &retrace_glVertexAttrib1d},
    {"glVertexAttrib1dv", &retrace_glVertexAttrib1dv},
    {"glVertexAttrib1f", &retrace_glVertexAttrib1f},
    {"glVertexAttrib1fv", &retrace_glVertexAttrib1fv},
    {"glVertexAttrib1s", &retrace_glVertexAttrib1s},
    {"glVertexAttrib1sv", &retrace_glVertexAttrib1sv},
    {"glVertexAttrib2d", &retrace_glVertexAttrib2d},
    {"glVertexAttrib2dv", &retrace_glVertexAttrib2dv},
    {"glVertexAttrib2f", &retrace_glVertexAttrib2f},
    {"glVertexAttrib2fv", &retrace_glVertexAttrib2fv},
    {"glVertexAttrib2s", &retrace_glVertexAttrib2s},
    {"glVertexAttrib2sv", &retrace_glVertexAttrib2sv},
    {"glVertexAttrib3d", &retrace_glVertexAttrib3d},
    {"glVertexAttrib3dv", &retrace_glVertexAttrib3dv},
    {"glVertexAttrib3f", &retrace_glVertexAttrib3f},
    {"glVertexAttrib3fv", &retrace_glVertexAttrib3fv},
    {"glVertexAttrib3s", &retrace_glVertexAttrib3s},
    {"glVertexAttrib3sv", &retrace_glVertexAttrib3sv},
    {"glVertexAttrib4Nbv", &retrace_glVertexAttrib4Nbv},
    {"glVertexAttrib4Niv", &retrace_glVertexAttrib4Niv},
    {"glVertexAttrib4Nsv", &retrace_glVertexAttrib4Nsv},
    {"glVertexAttrib4Nub", &retrace_glVertexAttrib4Nub},
    {"glVertexAttrib4Nubv", &retrace_glVertexAttrib4Nubv},
    {"glVertexAttrib4Nuiv", &retrace_glVertexAttrib4Nuiv},
    {"glVertexAttrib4Nusv", &retrace_glVertexAttrib4Nusv},
    {"glVertexAttrib4bv", &retrace_glVertexAttrib4bv},
    {"glVertexAttrib4d", &retrace_glVertexAttrib4d},
    {"glVertexAttrib4dv", &retrace_glVertexAttrib4dv},
    {"glVertexAttrib4f", &retrace_glVertexAttrib4f},
    {"glVertexAttrib4fv", &retrace_glVertexAttrib4fv},
    {"glVertexAttrib4iv", &retrace_glVertexAttrib4iv},
    {"glVertexAttrib4s", &retrace_glVertexAttrib4s},
    {"glVertexAttrib4sv", &retrace_glVertexAttrib4sv},
    {"glVertexAttrib4ubv", &retrace_glVertexAttrib4ubv},
    {"glVertexAttrib4uiv", &retrace_glVertexAttrib4uiv},
    {"glVertexAttrib4usv", &retrace_glVertexAttrib4usv},
    {"glVertexAttribPointer", &retrace_glVertexAttribPointer},
    {"glUniformMatrix2x3fv", &retrace_glUniformMatrix2x3fv},
    {"glUniformMatrix3x2fv", &retrace_glUniformMatrix3x2fv},
    {"glUniformMatrix2x4fv", &retrace_glUniformMatrix2x4fv},
    {"glUniformMatrix4x2fv", &retrace_glUniformMatrix4x2fv},
    {"glUniformMatrix3x4fv", &retrace_glUniformMatrix3x4fv},
    {"glUniformMatrix4x3fv", &retrace_glUniformMatrix4x3fv},
    {"glColorMaski", &retrace_glColorMaski},
    {"glGetBooleani_v", &retrace::ignore},
    {"glGetIntegeri_v", &retrace::ignore},
    {"glEnablei", &retrace_glEnablei},
    {"glDisablei", &retrace_glDisablei},
    {"glIsEnabledi", &retrace::ignore},
    {"glBeginTransformFeedback", &retrace_glBeginTransformFeedback},
    {"glEndTransformFeedback", &retrace_glEndTransformFeedback},
    {"glBindBufferRange", &retrace_glBindBufferRange},
    {"glBindBufferBase", &retrace_glBindBufferBase},
    {"glTransformFeedbackVaryings", &retrace_glTransformFeedbackVaryings},
    {"glGetTransformFeedbackVarying", &retrace::ignore},
    {"glClampColor", &retrace_glClampColor},
    {"glBeginConditionalRender", &retrace_glBeginConditionalRender},
    {"glEndConditionalRender", &retrace_glEndConditionalRender},
    {"glVertexAttribIPointer", &retrace_glVertexAttribIPointer},
    {"glGetVertexAttribIiv", &retrace::ignore},
    {"glGetVertexAttribIuiv", &retrace::ignore},
    {"glVertexAttribI1i", &retrace_glVertexAttribI1i},
    {"glVertexAttribI2i", &retrace_glVertexAttribI2i},
    {"glVertexAttribI3i", &retrace_glVertexAttribI3i},
    {"glVertexAttribI4i", &retrace_glVertexAttribI4i},
    {"glVertexAttribI1ui", &retrace_glVertexAttribI1ui},
    {"glVertexAttribI2ui", &retrace_glVertexAttribI2ui},
    {"glVertexAttribI3ui", &retrace_glVertexAttribI3ui},
    {"glVertexAttribI4ui", &retrace_glVertexAttribI4ui},
    {"glVertexAttribI1iv", &retrace_glVertexAttribI1iv},
    {"glVertexAttribI2iv", &retrace_glVertexAttribI2iv},
    {"glVertexAttribI3iv", &retrace_glVertexAttribI3iv},
    {"glVertexAttribI4iv", &retrace_glVertexAttribI4iv},
    {"glVertexAttribI1uiv", &retrace_glVertexAttribI1uiv},
    {"glVertexAttribI2uiv", &retrace_glVertexAttribI2uiv},
    {"glVertexAttribI3uiv", &retrace_glVertexAttribI3uiv},
    {"glVertexAttribI4uiv", &retrace_glVertexAttribI4uiv},
    {"glVertexAttribI4bv", &retrace_glVertexAttribI4bv},
    {"glVertexAttribI4sv", &retrace_glVertexAttribI4sv},
    {"glVertexAttribI4ubv", &retrace_glVertexAttribI4ubv},
    {"glVertexAttribI4usv", &retrace_glVertexAttribI4usv},
    {"glGetUniformuiv", &retrace::ignore},
    {"glBindFragDataLocation", &retrace_glBindFragDataLocation},
    {"glGetFragDataLocation", &retrace_glGetFragDataLocation},
    {"glUniform1ui", &retrace_glUniform1ui},
    {"glUniform2ui", &retrace_glUniform2ui},
    {"glUniform3ui", &retrace_glUniform3ui},
    {"glUniform4ui", &retrace_glUniform4ui},
    {"glUniform1uiv", &retrace_glUniform1uiv},
    {"glUniform2uiv", &retrace_glUniform2uiv},
    {"glUniform3uiv", &retrace_glUniform3uiv},
    {"glUniform4uiv", &retrace_glUniform4uiv},
    {"glTexParameterIiv", &retrace_glTexParameterIiv},
    {"glTexParameterIuiv", &retrace_glTexParameterIuiv},
    {"glGetTexParameterIiv", &retrace::ignore},
    {"glGetTexParameterIuiv", &retrace::ignore},
    {"glClearBufferiv", &retrace_glClearBufferiv},
    {"glClearBufferuiv", &retrace_glClearBufferuiv},
    {"glClearBufferfv", &retrace_glClearBufferfv},
    {"glClearBufferfi", &retrace_glClearBufferfi},
    {"glGetStringi", &retrace::ignore},
    {"glDrawArraysInstanced", &retrace_glDrawArraysInstanced},
    {"glDrawElementsInstanced", &retrace_glDrawElementsInstanced},
    {"glTexBuffer", &retrace_glTexBuffer},
    {"glPrimitiveRestartIndex", &retrace_glPrimitiveRestartIndex},
    {"glGetInteger64i_v", &retrace::ignore},
    {"glGetBufferParameteri64v", &retrace::ignore},
    {"glFramebufferTexture", &retrace_glFramebufferTexture},
    {"glVertexAttribDivisor", &retrace_glVertexAttribDivisor},
    {"glMinSampleShading", &retrace_glMinSampleShading},
    {"glBlendEquationi", &retrace_glBlendEquationi},
    {"glBlendEquationSeparatei", &retrace_glBlendEquationSeparatei},
    {"glBlendFunci", &retrace_glBlendFunci},
    {"glBlendFuncSeparatei", &retrace_glBlendFuncSeparatei},
    {"glActiveTextureARB", &retrace_glActiveTextureARB},
    {"glClientActiveTextureARB", &retrace_glClientActiveTextureARB},
    {"glMultiTexCoord1dARB", &retrace_glMultiTexCoord1dARB},
    {"glMultiTexCoord1dvARB", &retrace_glMultiTexCoord1dvARB},
    {"glMultiTexCoord1fARB", &retrace_glMultiTexCoord1fARB},
    {"glMultiTexCoord1fvARB", &retrace_glMultiTexCoord1fvARB},
    {"glMultiTexCoord1iARB", &retrace_glMultiTexCoord1iARB},
    {"glMultiTexCoord1ivARB", &retrace_glMultiTexCoord1ivARB},
    {"glMultiTexCoord1sARB", &retrace_glMultiTexCoord1sARB},
    {"glMultiTexCoord1svARB", &retrace_glMultiTexCoord1svARB},
    {"glMultiTexCoord2dARB", &retrace_glMultiTexCoord2dARB},
    {"glMultiTexCoord2dvARB", &retrace_glMultiTexCoord2dvARB},
    {"glMultiTexCoord2fARB", &retrace_glMultiTexCoord2fARB},
    {"glMultiTexCoord2fvARB", &retrace_glMultiTexCoord2fvARB},
    {"glMultiTexCoord2iARB", &retrace_glMultiTexCoord2iARB},
    {"glMultiTexCoord2ivARB", &retrace_glMultiTexCoord2ivARB},
    {"glMultiTexCoord2sARB", &retrace_glMultiTexCoord2sARB},
    {"glMultiTexCoord2svARB", &retrace_glMultiTexCoord2svARB},
    {"glMultiTexCoord3dARB", &retrace_glMultiTexCoord3dARB},
    {"glMultiTexCoord3dvARB", &retrace_glMultiTexCoord3dvARB},
    {"glMultiTexCoord3fARB", &retrace_glMultiTexCoord3fARB},
    {"glMultiTexCoord3fvARB", &retrace_glMultiTexCoord3fvARB},
    {"glMultiTexCoord3iARB", &retrace_glMultiTexCoord3iARB},
    {"glMultiTexCoord3ivARB", &retrace_glMultiTexCoord3ivARB},
    {"glMultiTexCoord3sARB", &retrace_glMultiTexCoord3sARB},
    {"glMultiTexCoord3svARB", &retrace_glMultiTexCoord3svARB},
    {"glMultiTexCoord4dARB", &retrace_glMultiTexCoord4dARB},
    {"glMultiTexCoord4dvARB", &retrace_glMultiTexCoord4dvARB},
    {"glMultiTexCoord4fARB", &retrace_glMultiTexCoord4fARB},
    {"glMultiTexCoord4fvARB", &retrace_glMultiTexCoord4fvARB},
    {"glMultiTexCoord4iARB", &retrace_glMultiTexCoord4iARB},
    {"glMultiTexCoord4ivARB", &retrace_glMultiTexCoord4ivARB},
    {"glMultiTexCoord4sARB", &retrace_glMultiTexCoord4sARB},
    {"glMultiTexCoord4svARB", &retrace_glMultiTexCoord4svARB},
    {"glLoadTransposeMatrixfARB", &retrace_glLoadTransposeMatrixfARB},
    {"glLoadTransposeMatrixdARB", &retrace_glLoadTransposeMatrixdARB},
    {"glMultTransposeMatrixfARB", &retrace_glMultTransposeMatrixfARB},
    {"glMultTransposeMatrixdARB", &retrace_glMultTransposeMatrixdARB},
    {"glSampleCoverageARB", &retrace_glSampleCoverageARB},
    {"glCompressedTexImage3DARB", &retrace_glCompressedTexImage3DARB},
    {"glCompressedTexImage2DARB", &retrace_glCompressedTexImage2DARB},
    {"glCompressedTexImage1DARB", &retrace_glCompressedTexImage1DARB},
    {"glCompressedTexSubImage3DARB", &retrace_glCompressedTexSubImage3DARB},
    {"glCompressedTexSubImage2DARB", &retrace_glCompressedTexSubImage2DARB},
    {"glCompressedTexSubImage1DARB", &retrace_glCompressedTexSubImage1DARB},
    {"glGetCompressedTexImageARB", &retrace_glGetCompressedTexImageARB},
    {"glPointParameterfARB", &retrace_glPointParameterfARB},
    {"glPointParameterfvARB", &retrace_glPointParameterfvARB},
    {"glWeightbvARB", &retrace_glWeightbvARB},
    {"glWeightsvARB", &retrace_glWeightsvARB},
    {"glWeightivARB", &retrace_glWeightivARB},
    {"glWeightfvARB", &retrace_glWeightfvARB},
    {"glWeightdvARB", &retrace_glWeightdvARB},
    {"glWeightubvARB", &retrace_glWeightubvARB},
    {"glWeightusvARB", &retrace_glWeightusvARB},
    {"glWeightuivARB", &retrace_glWeightuivARB},
    {"glWeightPointerARB", &retrace_glWeightPointerARB},
    {"glVertexBlendARB", &retrace_glVertexBlendARB},
    {"glCurrentPaletteMatrixARB", &retrace_glCurrentPaletteMatrixARB},
    {"glMatrixIndexubvARB", &retrace_glMatrixIndexubvARB},
    {"glMatrixIndexusvARB", &retrace_glMatrixIndexusvARB},
    {"glMatrixIndexuivARB", &retrace_glMatrixIndexuivARB},
    {"glMatrixIndexPointerARB", &retrace_glMatrixIndexPointerARB},
    {"glWindowPos2dARB", &retrace_glWindowPos2dARB},
    {"glWindowPos2dvARB", &retrace_glWindowPos2dvARB},
    {"glWindowPos2fARB", &retrace_glWindowPos2fARB},
    {"glWindowPos2fvARB", &retrace_glWindowPos2fvARB},
    {"glWindowPos2iARB", &retrace_glWindowPos2iARB},
    {"glWindowPos2ivARB", &retrace_glWindowPos2ivARB},
    {"glWindowPos2sARB", &retrace_glWindowPos2sARB},
    {"glWindowPos2svARB", &retrace_glWindowPos2svARB},
    {"glWindowPos3dARB", &retrace_glWindowPos3dARB},
    {"glWindowPos3dvARB", &retrace_glWindowPos3dvARB},
    {"glWindowPos3fARB", &retrace_glWindowPos3fARB},
    {"glWindowPos3fvARB", &retrace_glWindowPos3fvARB},
    {"glWindowPos3iARB", &retrace_glWindowPos3iARB},
    {"glWindowPos3ivARB", &retrace_glWindowPos3ivARB},
    {"glWindowPos3sARB", &retrace_glWindowPos3sARB},
    {"glWindowPos3svARB", &retrace_glWindowPos3svARB},
    {"glVertexAttrib1dARB", &retrace_glVertexAttrib1dARB},
    {"glVertexAttrib1dvARB", &retrace_glVertexAttrib1dvARB},
    {"glVertexAttrib1fARB", &retrace_glVertexAttrib1fARB},
    {"glVertexAttrib1fvARB", &retrace_glVertexAttrib1fvARB},
    {"glVertexAttrib1sARB", &retrace_glVertexAttrib1sARB},
    {"glVertexAttrib1svARB", &retrace_glVertexAttrib1svARB},
    {"glVertexAttrib2dARB", &retrace_glVertexAttrib2dARB},
    {"glVertexAttrib2dvARB", &retrace_glVertexAttrib2dvARB},
    {"glVertexAttrib2fARB", &retrace_glVertexAttrib2fARB},
    {"glVertexAttrib2fvARB", &retrace_glVertexAttrib2fvARB},
    {"glVertexAttrib2sARB", &retrace_glVertexAttrib2sARB},
    {"glVertexAttrib2svARB", &retrace_glVertexAttrib2svARB},
    {"glVertexAttrib3dARB", &retrace_glVertexAttrib3dARB},
    {"glVertexAttrib3dvARB", &retrace_glVertexAttrib3dvARB},
    {"glVertexAttrib3fARB", &retrace_glVertexAttrib3fARB},
    {"glVertexAttrib3fvARB", &retrace_glVertexAttrib3fvARB},
    {"glVertexAttrib3sARB", &retrace_glVertexAttrib3sARB},
    {"glVertexAttrib3svARB", &retrace_glVertexAttrib3svARB},
    {"glVertexAttrib4NbvARB", &retrace_glVertexAttrib4NbvARB},
    {"glVertexAttrib4NivARB", &retrace_glVertexAttrib4NivARB},
    {"glVertexAttrib4NsvARB", &retrace_glVertexAttrib4NsvARB},
    {"glVertexAttrib4NubARB", &retrace_glVertexAttrib4NubARB},
    {"glVertexAttrib4NubvARB", &retrace_glVertexAttrib4NubvARB},
    {"glVertexAttrib4NuivARB", &retrace_glVertexAttrib4NuivARB},
    {"glVertexAttrib4NusvARB", &retrace_glVertexAttrib4NusvARB},
    {"glVertexAttrib4bvARB", &retrace_glVertexAttrib4bvARB},
    {"glVertexAttrib4dARB", &retrace_glVertexAttrib4dARB},
    {"glVertexAttrib4dvARB", &retrace_glVertexAttrib4dvARB},
    {"glVertexAttrib4fARB", &retrace_glVertexAttrib4fARB},
    {"glVertexAttrib4fvARB", &retrace_glVertexAttrib4fvARB},
    {"glVertexAttrib4ivARB", &retrace_glVertexAttrib4ivARB},
    {"glVertexAttrib4sARB", &retrace_glVertexAttrib4sARB},
    {"glVertexAttrib4svARB", &retrace_glVertexAttrib4svARB},
    {"glVertexAttrib4ubvARB", &retrace_glVertexAttrib4ubvARB},
    {"glVertexAttrib4uivARB", &retrace_glVertexAttrib4uivARB},
    {"glVertexAttrib4usvARB", &retrace_glVertexAttrib4usvARB},
    {"glVertexAttribPointerARB", &retrace_glVertexAttribPointerARB},
    {"glEnableVertexAttribArrayARB", &retrace_glEnableVertexAttribArrayARB},
    {"glDisableVertexAttribArrayARB", &retrace_glDisableVertexAttribArrayARB},
    {"glProgramStringARB", &retrace_glProgramStringARB},
    {"glBindProgramARB", &retrace_glBindProgramARB},
    {"glDeleteProgramsARB", &retrace_glDeleteProgramsARB},
    {"glGenProgramsARB", &retrace_glGenProgramsARB},
    {"glProgramEnvParameter4dARB", &retrace_glProgramEnvParameter4dARB},
    {"glProgramEnvParameter4dvARB", &retrace_glProgramEnvParameter4dvARB},
    {"glProgramEnvParameter4fARB", &retrace_glProgramEnvParameter4fARB},
    {"glProgramEnvParameter4fvARB", &retrace_glProgramEnvParameter4fvARB},
    {"glProgramLocalParameter4dARB", &retrace_glProgramLocalParameter4dARB},
    {"glProgramLocalParameter4dvARB", &retrace_glProgramLocalParameter4dvARB},
    {"glProgramLocalParameter4fARB", &retrace_glProgramLocalParameter4fARB},
    {"glProgramLocalParameter4fvARB", &retrace_glProgramLocalParameter4fvARB},
    {"glGetProgramEnvParameterdvARB", &retrace::ignore},
    {"glGetProgramEnvParameterfvARB", &retrace::ignore},
    {"glGetProgramLocalParameterdvARB", &retrace::ignore},
    {"glGetProgramLocalParameterfvARB", &retrace::ignore},
    {"glGetProgramivARB", &retrace::ignore},
    {"glGetProgramStringARB", &retrace::ignore},
    {"glGetVertexAttribdvARB", &retrace::ignore},
    {"glGetVertexAttribfvARB", &retrace::ignore},
    {"glGetVertexAttribivARB", &retrace::ignore},
    {"glGetVertexAttribPointervARB", &retrace::ignore},
    {"glIsProgramARB", &retrace::ignore},
    {"glBindBufferARB", &retrace_glBindBufferARB},
    {"glDeleteBuffersARB", &retrace_glDeleteBuffersARB},
    {"glGenBuffersARB", &retrace_glGenBuffersARB},
    {"glIsBufferARB", &retrace::ignore},
    {"glBufferDataARB", &retrace_glBufferDataARB},
    {"glBufferSubDataARB", &retrace_glBufferSubDataARB},
    {"glGetBufferSubDataARB", &retrace::ignore},
    {"glMapBufferARB", &retrace_glMapBufferARB},
    {"glUnmapBufferARB", &retrace_glUnmapBufferARB},
    {"glGetBufferParameterivARB", &retrace::ignore},
    {"glGetBufferPointervARB", &retrace::ignore},
    {"glGenQueriesARB", &retrace_glGenQueriesARB},
    {"glDeleteQueriesARB", &retrace_glDeleteQueriesARB},
    {"glIsQueryARB", &retrace::ignore},
    {"glBeginQueryARB", &retrace_glBeginQueryARB},
    {"glEndQueryARB", &retrace_glEndQueryARB},
    {"glGetQueryivARB", &retrace::ignore},
    {"glGetQueryObjectivARB", &retrace::ignore},
    {"glGetQueryObjectuivARB", &retrace::ignore},
    {"glDeleteObjectARB", &retrace_glDeleteObjectARB},
    {"glGetHandleARB", &retrace::ignore},
    {"glDetachObjectARB", &retrace_glDetachObjectARB},
    {"glCreateShaderObjectARB", &retrace_glCreateShaderObjectARB},
    {"glShaderSourceARB", &retrace_glShaderSourceARB},
    {"glCompileShaderARB", &retrace_glCompileShaderARB},
    {"glCreateProgramObjectARB", &retrace_glCreateProgramObjectARB},
    {"glAttachObjectARB", &retrace_glAttachObjectARB},
    {"glLinkProgramARB", &retrace_glLinkProgramARB},
    {"glUseProgramObjectARB", &retrace_glUseProgramObjectARB},
    {"glValidateProgramARB", &retrace_glValidateProgramARB},
    {"glUniform1fARB", &retrace_glUniform1fARB},
    {"glUniform2fARB", &retrace_glUniform2fARB},
    {"glUniform3fARB", &retrace_glUniform3fARB},
    {"glUniform4fARB", &retrace_glUniform4fARB},
    {"glUniform1iARB", &retrace_glUniform1iARB},
    {"glUniform2iARB", &retrace_glUniform2iARB},
    {"glUniform3iARB", &retrace_glUniform3iARB},
    {"glUniform4iARB", &retrace_glUniform4iARB},
    {"glUniform1fvARB", &retrace_glUniform1fvARB},
    {"glUniform2fvARB", &retrace_glUniform2fvARB},
    {"glUniform3fvARB", &retrace_glUniform3fvARB},
    {"glUniform4fvARB", &retrace_glUniform4fvARB},
    {"glUniform1ivARB", &retrace_glUniform1ivARB},
    {"glUniform2ivARB", &retrace_glUniform2ivARB},
    {"glUniform3ivARB", &retrace_glUniform3ivARB},
    {"glUniform4ivARB", &retrace_glUniform4ivARB},
    {"glUniformMatrix2fvARB", &retrace_glUniformMatrix2fvARB},
    {"glUniformMatrix3fvARB", &retrace_glUniformMatrix3fvARB},
    {"glUniformMatrix4fvARB", &retrace_glUniformMatrix4fvARB},
    {"glGetObjectParameterfvARB", &retrace::ignore},
    {"glGetObjectParameterivARB", &retrace::ignore},
    {"glGetInfoLogARB", &retrace::ignore},
    {"glGetAttachedObjectsARB", &retrace::ignore},
    {"glGetUniformLocationARB", &retrace_glGetUniformLocationARB},
    {"glGetActiveUniformARB", &retrace::ignore},
    {"glGetUniformfvARB", &retrace::ignore},
    {"glGetUniformivARB", &retrace::ignore},
    {"glGetShaderSourceARB", &retrace::ignore},
    {"glBindAttribLocationARB", &retrace_glBindAttribLocationARB},
    {"glGetActiveAttribARB", &retrace::ignore},
    {"glGetAttribLocationARB", &retrace_glGetAttribLocationARB},
    {"glDrawBuffersARB", &retrace_glDrawBuffersARB},
    {"glClampColorARB", &retrace_glClampColorARB},
    {"glDrawArraysInstancedARB", &retrace_glDrawArraysInstancedARB},
    {"glDrawElementsInstancedARB", &retrace_glDrawElementsInstancedARB},
    {"glIsRenderbuffer", &retrace::ignore},
    {"glBindRenderbuffer", &retrace_glBindRenderbuffer},
    {"glDeleteRenderbuffers", &retrace_glDeleteRenderbuffers},
    {"glGenRenderbuffers", &retrace_glGenRenderbuffers},
    {"glRenderbufferStorage", &retrace_glRenderbufferStorage},
    {"glGetRenderbufferParameteriv", &retrace::ignore},
    {"glIsFramebuffer", &retrace::ignore},
    {"glBindFramebuffer", &retrace_glBindFramebuffer},
    {"glDeleteFramebuffers", &retrace_glDeleteFramebuffers},
    {"glGenFramebuffers", &retrace_glGenFramebuffers},
    {"glCheckFramebufferStatus", &retrace_glCheckFramebufferStatus},
    {"glFramebufferTexture1D", &retrace_glFramebufferTexture1D},
    {"glFramebufferTexture2D", &retrace_glFramebufferTexture2D},
    {"glFramebufferTexture3D", &retrace_glFramebufferTexture3D},
    {"glFramebufferRenderbuffer", &retrace_glFramebufferRenderbuffer},
    {"glGetFramebufferAttachmentParameteriv", &retrace::ignore},
    {"glGenerateMipmap", &retrace_glGenerateMipmap},
    {"glBlitFramebuffer", &retrace_glBlitFramebuffer},
    {"glRenderbufferStorageMultisample", &retrace_glRenderbufferStorageMultisample},
    {"glFramebufferTextureLayer", &retrace_glFramebufferTextureLayer},
    {"glProgramParameteriARB", &retrace_glProgramParameteriARB},
    {"glFramebufferTextureARB", &retrace_glFramebufferTextureARB},
    {"glFramebufferTextureLayerARB", &retrace_glFramebufferTextureLayerARB},
    {"glFramebufferTextureFaceARB", &retrace_glFramebufferTextureFaceARB},
    {"glVertexAttribDivisorARB", &retrace_glVertexAttribDivisorARB},
    {"glMapBufferRange", &retrace_glMapBufferRange},
    {"glFlushMappedBufferRange", &retrace_glFlushMappedBufferRange},
    {"glTexBufferARB", &retrace_glTexBufferARB},
    {"glBindVertexArray", &retrace_glBindVertexArray},
    {"glDeleteVertexArrays", &retrace_glDeleteVertexArrays},
    {"glGenVertexArrays", &retrace_glGenVertexArrays},
    {"glIsVertexArray", &retrace::ignore},
    {"glGetUniformIndices", &retrace::ignore},
    {"glGetActiveUniformsiv", &retrace::ignore},
    {"glGetActiveUniformName", &retrace::ignore},
    {"glGetUniformBlockIndex", &retrace_glGetUniformBlockIndex},
    {"glGetActiveUniformBlockiv", &retrace::ignore},
    {"glGetActiveUniformBlockName", &retrace::ignore},
    {"glUniformBlockBinding", &retrace_glUniformBlockBinding},
    {"glCopyBufferSubData", &retrace_glCopyBufferSubData},
    {"glDrawElementsBaseVertex", &retrace_glDrawElementsBaseVertex},
    {"glDrawRangeElementsBaseVertex", &retrace_glDrawRangeElementsBaseVertex},
    {"glDrawElementsInstancedBaseVertex", &retrace_glDrawElementsInstancedBaseVertex},
    {"glMultiDrawElementsBaseVertex", &retrace_glMultiDrawElementsBaseVertex},
    {"glProvokingVertex", &retrace_glProvokingVertex},
    {"glFenceSync", &retrace_glFenceSync},
    {"glIsSync", &retrace::ignore},
    {"glDeleteSync", &retrace_glDeleteSync},
    {"glClientWaitSync", &retrace_glClientWaitSync},
    {"glWaitSync", &retrace_glWaitSync},
    {"glGetInteger64v", &retrace::ignore},
    {"glGetSynciv", &retrace::ignore},
    {"glTexImage2DMultisample", &retrace_glTexImage2DMultisample},
    {"glTexImage3DMultisample", &retrace_glTexImage3DMultisample},
    {"glGetMultisamplefv", &retrace::ignore},
    {"glSampleMaski", &retrace_glSampleMaski},
    {"glBlendEquationiARB", &retrace_glBlendEquationiARB},
    {"glBlendEquationSeparateiARB", &retrace_glBlendEquationSeparateiARB},
    {"glBlendFunciARB", &retrace_glBlendFunciARB},
    {"glBlendFuncSeparateiARB", &retrace_glBlendFuncSeparateiARB},
    {"glMinSampleShadingARB", &retrace_glMinSampleShadingARB},
    {"glNamedStringARB", &retrace_glNamedStringARB},
    {"glDeleteNamedStringARB", &retrace_glDeleteNamedStringARB},
    {"glCompileShaderIncludeARB", &retrace_glCompileShaderIncludeARB},
    {"glIsNamedStringARB", &retrace::ignore},
    {"glGetNamedStringARB", &retrace::ignore},
    {"glGetNamedStringivARB", &retrace::ignore},
    {"glBindFragDataLocationIndexed", &retrace_glBindFragDataLocationIndexed},
    {"glGetFragDataIndex", &retrace::ignore},
    {"glGenSamplers", &retrace_glGenSamplers},
    {"glDeleteSamplers", &retrace_glDeleteSamplers},
    {"glIsSampler", &retrace::ignore},
    {"glBindSampler", &retrace_glBindSampler},
    {"glSamplerParameteri", &retrace_glSamplerParameteri},
    {"glSamplerParameteriv", &retrace_glSamplerParameteriv},
    {"glSamplerParameterf", &retrace_glSamplerParameterf},
    {"glSamplerParameterfv", &retrace_glSamplerParameterfv},
    {"glSamplerParameterIiv", &retrace_glSamplerParameterIiv},
    {"glSamplerParameterIuiv", &retrace_glSamplerParameterIuiv},
    {"glGetSamplerParameteriv", &retrace::ignore},
    {"glGetSamplerParameterIiv", &retrace::ignore},
    {"glGetSamplerParameterfv", &retrace::ignore},
    {"glGetSamplerParameterIuiv", &retrace::ignore},
    {"glQueryCounter", &retrace_glQueryCounter},
    {"glGetQueryObjecti64v", &retrace::ignore},
    {"glGetQueryObjectui64v", &retrace::ignore},
    {"glVertexP2ui", &retrace_glVertexP2ui},
    {"glVertexP2uiv", &retrace_glVertexP2uiv},
    {"glVertexP3ui", &retrace_glVertexP3ui},
    {"glVertexP3uiv", &retrace_glVertexP3uiv},
    {"glVertexP4ui", &retrace_glVertexP4ui},
    {"glVertexP4uiv", &retrace_glVertexP4uiv},
    {"glTexCoordP1ui", &retrace_glTexCoordP1ui},
    {"glTexCoordP1uiv", &retrace_glTexCoordP1uiv},
    {"glTexCoordP2ui", &retrace_glTexCoordP2ui},
    {"glTexCoordP2uiv", &retrace_glTexCoordP2uiv},
    {"glTexCoordP3ui", &retrace_glTexCoordP3ui},
    {"glTexCoordP3uiv", &retrace_glTexCoordP3uiv},
    {"glTexCoordP4ui", &retrace_glTexCoordP4ui},
    {"glTexCoordP4uiv", &retrace_glTexCoordP4uiv},
    {"glMultiTexCoordP1ui", &retrace_glMultiTexCoordP1ui},
    {"glMultiTexCoordP1uiv", &retrace_glMultiTexCoordP1uiv},
    {"glMultiTexCoordP2ui", &retrace_glMultiTexCoordP2ui},
    {"glMultiTexCoordP2uiv", &retrace_glMultiTexCoordP2uiv},
    {"glMultiTexCoordP3ui", &retrace_glMultiTexCoordP3ui},
    {"glMultiTexCoordP3uiv", &retrace_glMultiTexCoordP3uiv},
    {"glMultiTexCoordP4ui", &retrace_glMultiTexCoordP4ui},
    {"glMultiTexCoordP4uiv", &retrace_glMultiTexCoordP4uiv},
    {"glNormalP3ui", &retrace_glNormalP3ui},
    {"glNormalP3uiv", &retrace_glNormalP3uiv},
    {"glColorP3ui", &retrace_glColorP3ui},
    {"glColorP3uiv", &retrace_glColorP3uiv},
    {"glColorP4ui", &retrace_glColorP4ui},
    {"glColorP4uiv", &retrace_glColorP4uiv},
    {"glSecondaryColorP3ui", &retrace_glSecondaryColorP3ui},
    {"glSecondaryColorP3uiv", &retrace_glSecondaryColorP3uiv},
    {"glVertexAttribP1ui", &retrace_glVertexAttribP1ui},
    {"glVertexAttribP1uiv", &retrace_glVertexAttribP1uiv},
    {"glVertexAttribP2ui", &retrace_glVertexAttribP2ui},
    {"glVertexAttribP2uiv", &retrace_glVertexAttribP2uiv},
    {"glVertexAttribP3ui", &retrace_glVertexAttribP3ui},
    {"glVertexAttribP3uiv", &retrace_glVertexAttribP3uiv},
    {"glVertexAttribP4ui", &retrace_glVertexAttribP4ui},
    {"glVertexAttribP4uiv", &retrace_glVertexAttribP4uiv},
    {"glDrawArraysIndirect", &retrace_glDrawArraysIndirect},
    {"glDrawElementsIndirect", &retrace_glDrawElementsIndirect},
    {"glUniform1d", &retrace_glUniform1d},
    {"glUniform2d", &retrace_glUniform2d},
    {"glUniform3d", &retrace_glUniform3d},
    {"glUniform4d", &retrace_glUniform4d},
    {"glUniform1dv", &retrace_glUniform1dv},
    {"glUniform2dv", &retrace_glUniform2dv},
    {"glUniform3dv", &retrace_glUniform3dv},
    {"glUniform4dv", &retrace_glUniform4dv},
    {"glUniformMatrix2dv", &retrace_glUniformMatrix2dv},
    {"glUniformMatrix3dv", &retrace_glUniformMatrix3dv},
    {"glUniformMatrix4dv", &retrace_glUniformMatrix4dv},
    {"glUniformMatrix2x3dv", &retrace_glUniformMatrix2x3dv},
    {"glUniformMatrix2x4dv", &retrace_glUniformMatrix2x4dv},
    {"glUniformMatrix3x2dv", &retrace_glUniformMatrix3x2dv},
    {"glUniformMatrix3x4dv", &retrace_glUniformMatrix3x4dv},
    {"glUniformMatrix4x2dv", &retrace_glUniformMatrix4x2dv},
    {"glUniformMatrix4x3dv", &retrace_glUniformMatrix4x3dv},
    {"glGetUniformdv", &retrace::ignore},
    {"glGetSubroutineUniformLocation", &retrace_glGetSubroutineUniformLocation},
    {"glGetSubroutineIndex", &retrace_glGetSubroutineIndex},
    {"glGetActiveSubroutineUniformiv", &retrace::ignore},
    {"glGetActiveSubroutineUniformName", &retrace::ignore},
    {"glGetActiveSubroutineName", &retrace::ignore},
    {"glUniformSubroutinesuiv", &retrace_glUniformSubroutinesuiv},
    {"glGetUniformSubroutineuiv", &retrace::ignore},
    {"glGetProgramStageiv", &retrace::ignore},
    {"glPatchParameteri", &retrace_glPatchParameteri},
    {"glPatchParameterfv", &retrace_glPatchParameterfv},
    {"glBindTransformFeedback", &retrace_glBindTransformFeedback},
    {"glDeleteTransformFeedbacks", &retrace_glDeleteTransformFeedbacks},
    {"glGenTransformFeedbacks", &retrace_glGenTransformFeedbacks},
    {"glIsTransformFeedback", &retrace::ignore},
    {"glPauseTransformFeedback", &retrace_glPauseTransformFeedback},
    {"glResumeTransformFeedback", &retrace_glResumeTransformFeedback},
    {"glDrawTransformFeedback", &retrace_glDrawTransformFeedback},
    {"glDrawTransformFeedbackStream", &retrace_glDrawTransformFeedbackStream},
    {"glBeginQueryIndexed", &retrace_glBeginQueryIndexed},
    {"glEndQueryIndexed", &retrace_glEndQueryIndexed},
    {"glGetQueryIndexediv", &retrace::ignore},
    {"glReleaseShaderCompiler", &retrace_glReleaseShaderCompiler},
    {"glShaderBinary", &retrace_glShaderBinary},
    {"glGetShaderPrecisionFormat", &retrace::ignore},
    {"glDepthRangef", &retrace_glDepthRangef},
    {"glClearDepthf", &retrace_glClearDepthf},
    {"glGetProgramBinary", &retrace::ignore},
    {"glProgramBinary", &retrace_glProgramBinary},
    {"glProgramParameteri", &retrace_glProgramParameteri},
    {"glUseProgramStages", &retrace_glUseProgramStages},
    {"glActiveShaderProgram", &retrace_glActiveShaderProgram},
    {"glCreateShaderProgramv", &retrace_glCreateShaderProgramv},
    {"glBindProgramPipeline", &retrace_glBindProgramPipeline},
    {"glDeleteProgramPipelines", &retrace_glDeleteProgramPipelines},
    {"glGenProgramPipelines", &retrace_glGenProgramPipelines},
    {"glIsProgramPipeline", &retrace::ignore},
    {"glGetProgramPipelineiv", &retrace::ignore},
    {"glProgramUniform1i", &retrace_glProgramUniform1i},
    {"glProgramUniform1iv", &retrace_glProgramUniform1iv},
    {"glProgramUniform1f", &retrace_glProgramUniform1f},
    {"glProgramUniform1fv", &retrace_glProgramUniform1fv},
    {"glProgramUniform1d", &retrace_glProgramUniform1d},
    {"glProgramUniform1dv", &retrace_glProgramUniform1dv},
    {"glProgramUniform1ui", &retrace_glProgramUniform1ui},
    {"glProgramUniform1uiv", &retrace_glProgramUniform1uiv},
    {"glProgramUniform2i", &retrace_glProgramUniform2i},
    {"glProgramUniform2iv", &retrace_glProgramUniform2iv},
    {"glProgramUniform2f", &retrace_glProgramUniform2f},
    {"glProgramUniform2fv", &retrace_glProgramUniform2fv},
    {"glProgramUniform2d", &retrace_glProgramUniform2d},
    {"glProgramUniform2dv", &retrace_glProgramUniform2dv},
    {"glProgramUniform2ui", &retrace_glProgramUniform2ui},
    {"glProgramUniform2uiv", &retrace_glProgramUniform2uiv},
    {"glProgramUniform3i", &retrace_glProgramUniform3i},
    {"glProgramUniform3iv", &retrace_glProgramUniform3iv},
    {"glProgramUniform3f", &retrace_glProgramUniform3f},
    {"glProgramUniform3fv", &retrace_glProgramUniform3fv},
    {"glProgramUniform3d", &retrace_glProgramUniform3d},
    {"glProgramUniform3dv", &retrace_glProgramUniform3dv},
    {"glProgramUniform3ui", &retrace_glProgramUniform3ui},
    {"glProgramUniform3uiv", &retrace_glProgramUniform3uiv},
    {"glProgramUniform4i", &retrace_glProgramUniform4i},
    {"glProgramUniform4iv", &retrace_glProgramUniform4iv},
    {"glProgramUniform4f", &retrace_glProgramUniform4f},
    {"glProgramUniform4fv", &retrace_glProgramUniform4fv},
    {"glProgramUniform4d", &retrace_glProgramUniform4d},
    {"glProgramUniform4dv", &retrace_glProgramUniform4dv},
    {"glProgramUniform4ui", &retrace_glProgramUniform4ui},
    {"glProgramUniform4uiv", &retrace_glProgramUniform4uiv},
    {"glProgramUniformMatrix2fv", &retrace_glProgramUniformMatrix2fv},
    {"glProgramUniformMatrix3fv", &retrace_glProgramUniformMatrix3fv},
    {"glProgramUniformMatrix4fv", &retrace_glProgramUniformMatrix4fv},
    {"glProgramUniformMatrix2dv", &retrace_glProgramUniformMatrix2dv},
    {"glProgramUniformMatrix3dv", &retrace_glProgramUniformMatrix3dv},
    {"glProgramUniformMatrix4dv", &retrace_glProgramUniformMatrix4dv},
    {"glProgramUniformMatrix2x3fv", &retrace_glProgramUniformMatrix2x3fv},
    {"glProgramUniformMatrix3x2fv", &retrace_glProgramUniformMatrix3x2fv},
    {"glProgramUniformMatrix2x4fv", &retrace_glProgramUniformMatrix2x4fv},
    {"glProgramUniformMatrix4x2fv", &retrace_glProgramUniformMatrix4x2fv},
    {"glProgramUniformMatrix3x4fv", &retrace_glProgramUniformMatrix3x4fv},
    {"glProgramUniformMatrix4x3fv", &retrace_glProgramUniformMatrix4x3fv},
    {"glProgramUniformMatrix2x3dv", &retrace_glProgramUniformMatrix2x3dv},
    {"glProgramUniformMatrix3x2dv", &retrace_glProgramUniformMatrix3x2dv},
    {"glProgramUniformMatrix2x4dv", &retrace_glProgramUniformMatrix2x4dv},
    {"glProgramUniformMatrix4x2dv", &retrace_glProgramUniformMatrix4x2dv},
    {"glProgramUniformMatrix3x4dv", &retrace_glProgramUniformMatrix3x4dv},
    {"glProgramUniformMatrix4x3dv", &retrace_glProgramUniformMatrix4x3dv},
    {"glValidateProgramPipeline", &retrace_glValidateProgramPipeline},
    {"glGetProgramPipelineInfoLog", &retrace::ignore},
    {"glVertexAttribL1d", &retrace_glVertexAttribL1d},
    {"glVertexAttribL2d", &retrace_glVertexAttribL2d},
    {"glVertexAttribL3d", &retrace_glVertexAttribL3d},
    {"glVertexAttribL4d", &retrace_glVertexAttribL4d},
    {"glVertexAttribL1dv", &retrace_glVertexAttribL1dv},
    {"glVertexAttribL2dv", &retrace_glVertexAttribL2dv},
    {"glVertexAttribL3dv", &retrace_glVertexAttribL3dv},
    {"glVertexAttribL4dv", &retrace_glVertexAttribL4dv},
    {"glVertexAttribLPointer", &retrace_glVertexAttribLPointer},
    {"glGetVertexAttribLdv", &retrace::ignore},
    {"glViewportArrayv", &retrace_glViewportArrayv},
    {"glViewportIndexedf", &retrace_glViewportIndexedf},
    {"glViewportIndexedfv", &retrace_glViewportIndexedfv},
    {"glScissorArrayv", &retrace_glScissorArrayv},
    {"glScissorIndexed", &retrace_glScissorIndexed},
    {"glScissorIndexedv", &retrace_glScissorIndexedv},
    {"glDepthRangeArrayv", &retrace_glDepthRangeArrayv},
    {"glDepthRangeIndexed", &retrace_glDepthRangeIndexed},
    {"glGetFloati_v", &retrace::ignore},
    {"glGetDoublei_v", &retrace::ignore},
    {"glDebugMessageControlARB", &retrace_glDebugMessageControlARB},
    {"glDebugMessageInsertARB", &retrace_glDebugMessageInsertARB},
    {"glDebugMessageCallbackARB", &retrace::ignore},
    {"glGetDebugMessageLogARB", &retrace::ignore},
    {"glGetGraphicsResetStatusARB", &retrace::ignore},
    {"glGetnMapdvARB", &retrace::ignore},
    {"glGetnMapfvARB", &retrace::ignore},
    {"glGetnMapivARB", &retrace::ignore},
    {"glGetnPixelMapfvARB", &retrace_glGetnPixelMapfvARB},
    {"glGetnPixelMapuivARB", &retrace_glGetnPixelMapuivARB},
    {"glGetnPixelMapusvARB", &retrace_glGetnPixelMapusvARB},
    {"glGetnPolygonStippleARB", &retrace_glGetnPolygonStippleARB},
    {"glGetnColorTableARB", &retrace::ignore},
    {"glGetnConvolutionFilterARB", &retrace_glGetnConvolutionFilterARB},
    {"glGetnSeparableFilterARB", &retrace_glGetnSeparableFilterARB},
    {"glGetnHistogramARB", &retrace_glGetnHistogramARB},
    {"glGetnMinmaxARB", &retrace_glGetnMinmaxARB},
    {"glGetnTexImageARB", &retrace_glGetnTexImageARB},
    {"glReadnPixelsARB", &retrace_glReadnPixelsARB},
    {"glGetnCompressedTexImageARB", &retrace_glGetnCompressedTexImageARB},
    {"glGetnUniformfvARB", &retrace::ignore},
    {"glGetnUniformivARB", &retrace::ignore},
    {"glGetnUniformuivARB", &retrace::ignore},
    {"glGetnUniformdvARB", &retrace::ignore},
    {"glDrawArraysInstancedBaseInstance", &retrace_glDrawArraysInstancedBaseInstance},
    {"glDrawElementsInstancedBaseInstance", &retrace_glDrawElementsInstancedBaseInstance},
    {"glDrawElementsInstancedBaseVertexBaseInstance", &retrace_glDrawElementsInstancedBaseVertexBaseInstance},
    {"glDrawTransformFeedbackInstanced", &retrace_glDrawTransformFeedbackInstanced},
    {"glDrawTransformFeedbackStreamInstanced", &retrace_glDrawTransformFeedbackStreamInstanced},
    {"glGetInternalformativ", &retrace::ignore},
    {"glGetActiveAtomicCounterBufferiv", &retrace::ignore},
    {"glBindImageTexture", &retrace_glBindImageTexture},
    {"glMemoryBarrier", &retrace_glMemoryBarrier},
    {"glTexStorage1D", &retrace_glTexStorage1D},
    {"glTexStorage2D", &retrace_glTexStorage2D},
    {"glTexStorage3D", &retrace_glTexStorage3D},
    {"glTextureStorage1DEXT", &retrace_glTextureStorage1DEXT},
    {"glTextureStorage2DEXT", &retrace_glTextureStorage2DEXT},
    {"glTextureStorage3DEXT", &retrace_glTextureStorage3DEXT},
    {"glDebugMessageControl", &retrace_glDebugMessageControl},
    {"glDebugMessageInsert", &retrace_glDebugMessageInsert},
    {"glDebugMessageCallback", &retrace::ignore},
    {"glGetDebugMessageLog", &retrace::ignore},
    {"glPushDebugGroup", &retrace_glPushDebugGroup},
    {"glPopDebugGroup", &retrace_glPopDebugGroup},
    {"glObjectLabel", &retrace_glObjectLabel},
    {"glGetObjectLabel", &retrace::ignore},
    {"glObjectPtrLabel", &retrace_glObjectPtrLabel},
    {"glGetObjectPtrLabel", &retrace::ignore},
    {"glClearBufferData", &retrace_glClearBufferData},
    {"glClearBufferSubData", &retrace_glClearBufferSubData},
    {"glClearNamedBufferDataEXT", &retrace_glClearNamedBufferDataEXT},
    {"glClearNamedBufferSubDataEXT", &retrace_glClearNamedBufferSubDataEXT},
    {"glDispatchCompute", &retrace_glDispatchCompute},
    {"glDispatchComputeIndirect", &retrace_glDispatchComputeIndirect},
    {"glCopyImageSubData", &retrace_glCopyImageSubData},
    {"glTextureView", &retrace_glTextureView},
    {"glBindVertexBuffer", &retrace_glBindVertexBuffer},
    {"glVertexAttribFormat", &retrace_glVertexAttribFormat},
    {"glVertexAttribIFormat", &retrace_glVertexAttribIFormat},
    {"glVertexAttribLFormat", &retrace_glVertexAttribLFormat},
    {"glVertexAttribBinding", &retrace_glVertexAttribBinding},
    {"glVertexBindingDivisor", &retrace_glVertexBindingDivisor},
    {"glVertexArrayBindVertexBufferEXT", &retrace_glVertexArrayBindVertexBufferEXT},
    {"glVertexArrayVertexAttribFormatEXT", &retrace_glVertexArrayVertexAttribFormatEXT},
    {"glVertexArrayVertexAttribIFormatEXT", &retrace_glVertexArrayVertexAttribIFormatEXT},
    {"glVertexArrayVertexAttribLFormatEXT", &retrace_glVertexArrayVertexAttribLFormatEXT},
    {"glVertexArrayVertexAttribBindingEXT", &retrace_glVertexArrayVertexAttribBindingEXT},
    {"glVertexArrayVertexBindingDivisorEXT", &retrace_glVertexArrayVertexBindingDivisorEXT},
    {"glFramebufferParameteri", &retrace_glFramebufferParameteri},
    {"glGetFramebufferParameteriv", &retrace::ignore},
    {"glNamedFramebufferParameteriEXT", &retrace_glNamedFramebufferParameteriEXT},
    {"glGetNamedFramebufferParameterivEXT", &retrace::ignore},
    {"glGetInternalformati64v", &retrace::ignore},
    {"glInvalidateTexSubImage", &retrace_glInvalidateTexSubImage},
    {"glInvalidateTexImage", &retrace_glInvalidateTexImage},
    {"glInvalidateBufferSubData", &retrace_glInvalidateBufferSubData},
    {"glInvalidateBufferData", &retrace_glInvalidateBufferData},
    {"glInvalidateFramebuffer", &retrace_glInvalidateFramebuffer},
    {"glInvalidateSubFramebuffer", &retrace_glInvalidateSubFramebuffer},
    {"glMultiDrawArraysIndirect", &retrace_glMultiDrawArraysIndirect},
    {"glMultiDrawElementsIndirect", &retrace_glMultiDrawElementsIndirect},
    {"glGetProgramInterfaceiv", &retrace::ignore},
    {"glGetProgramResourceIndex", &retrace::ignore},
    {"glGetProgramResourceName", &retrace::ignore},
    {"glGetProgramResourceiv", &retrace::ignore},
    {"glGetProgramResourceLocation", &retrace::ignore},
    {"glGetProgramResourceLocationIndex", &retrace::ignore},
    {"glShaderStorageBlockBinding", &retrace_glShaderStorageBlockBinding},
    {"glTexBufferRange", &retrace_glTexBufferRange},
    {"glTextureBufferRangeEXT", &retrace_glTextureBufferRangeEXT},
    {"glTexStorage2DMultisample", &retrace_glTexStorage2DMultisample},
    {"glTexStorage3DMultisample", &retrace_glTexStorage3DMultisample},
    {"glTextureStorage2DMultisampleEXT", &retrace_glTextureStorage2DMultisampleEXT},
    {"glTextureStorage3DMultisampleEXT", &retrace_glTextureStorage3DMultisampleEXT},
    {"glBlendColorEXT", &retrace_glBlendColorEXT},
    {"glPolygonOffsetEXT", &retrace_glPolygonOffsetEXT},
    {"glTexImage3DEXT", &retrace_glTexImage3DEXT},
    {"glTexSubImage3DEXT", &retrace_glTexSubImage3DEXT},
    {"glGetTexFilterFuncSGIS", &retrace::ignore},
    {"glTexFilterFuncSGIS", &retrace_glTexFilterFuncSGIS},
    {"glTexSubImage1DEXT", &retrace_glTexSubImage1DEXT},
    {"glTexSubImage2DEXT", &retrace_glTexSubImage2DEXT},
    {"glCopyTexImage1DEXT", &retrace_glCopyTexImage1DEXT},
    {"glCopyTexImage2DEXT", &retrace_glCopyTexImage2DEXT},
    {"glCopyTexSubImage1DEXT", &retrace_glCopyTexSubImage1DEXT},
    {"glCopyTexSubImage2DEXT", &retrace_glCopyTexSubImage2DEXT},
    {"glCopyTexSubImage3DEXT", &retrace_glCopyTexSubImage3DEXT},
    {"glGetHistogramEXT", &retrace::ignore},
    {"glGetHistogramParameterfvEXT", &retrace::ignore},
    {"glGetHistogramParameterivEXT", &retrace::ignore},
    {"glGetMinmaxEXT", &retrace::ignore},
    {"glGetMinmaxParameterfvEXT", &retrace::ignore},
    {"glGetMinmaxParameterivEXT", &retrace::ignore},
    {"glHistogramEXT", &retrace_glHistogramEXT},
    {"glMinmaxEXT", &retrace_glMinmaxEXT},
    {"glResetHistogramEXT", &retrace_glResetHistogramEXT},
    {"glResetMinmaxEXT", &retrace_glResetMinmaxEXT},
    {"glConvolutionFilter1DEXT", &retrace_glConvolutionFilter1DEXT},
    {"glConvolutionFilter2DEXT", &retrace_glConvolutionFilter2DEXT},
    {"glConvolutionParameterfEXT", &retrace_glConvolutionParameterfEXT},
    {"glConvolutionParameterfvEXT", &retrace_glConvolutionParameterfvEXT},
    {"glConvolutionParameteriEXT", &retrace_glConvolutionParameteriEXT},
    {"glConvolutionParameterivEXT", &retrace_glConvolutionParameterivEXT},
    {"glCopyConvolutionFilter1DEXT", &retrace_glCopyConvolutionFilter1DEXT},
    {"glCopyConvolutionFilter2DEXT", &retrace_glCopyConvolutionFilter2DEXT},
    {"glGetConvolutionFilterEXT", &retrace::ignore},
    {"glGetConvolutionParameterfvEXT", &retrace::ignore},
    {"glGetConvolutionParameterivEXT", &retrace::ignore},
    {"glGetSeparableFilterEXT", &retrace::ignore},
    {"glSeparableFilter2DEXT", &retrace_glSeparableFilter2DEXT},
    {"glColorTableSGI", &retrace_glColorTableSGI},
    {"glColorTableParameterfvSGI", &retrace_glColorTableParameterfvSGI},
    {"glColorTableParameterivSGI", &retrace_glColorTableParameterivSGI},
    {"glCopyColorTableSGI", &retrace_glCopyColorTableSGI},
    {"glGetColorTableSGI", &retrace::ignore},
    {"glGetColorTableParameterfvSGI", &retrace::ignore},
    {"glGetColorTableParameterivSGI", &retrace::ignore},
    {"glPixelTexGenSGIX", &retrace_glPixelTexGenSGIX},
    {"glPixelTexGenParameteriSGIS", &retrace_glPixelTexGenParameteriSGIS},
    {"glPixelTexGenParameterivSGIS", &retrace_glPixelTexGenParameterivSGIS},
    {"glPixelTexGenParameterfSGIS", &retrace_glPixelTexGenParameterfSGIS},
    {"glPixelTexGenParameterfvSGIS", &retrace_glPixelTexGenParameterfvSGIS},
    {"glGetPixelTexGenParameterivSGIS", &retrace::ignore},
    {"glGetPixelTexGenParameterfvSGIS", &retrace::ignore},
    {"glTexImage4DSGIS", &retrace_glTexImage4DSGIS},
    {"glTexSubImage4DSGIS", &retrace_glTexSubImage4DSGIS},
    {"glAreTexturesResidentEXT", &retrace::ignore},
    {"glBindTextureEXT", &retrace_glBindTextureEXT},
    {"glDeleteTexturesEXT", &retrace_glDeleteTexturesEXT},
    {"glGenTexturesEXT", &retrace_glGenTexturesEXT},
    {"glIsTextureEXT", &retrace::ignore},
    {"glPrioritizeTexturesEXT", &retrace_glPrioritizeTexturesEXT},
    {"glDetailTexFuncSGIS", &retrace_glDetailTexFuncSGIS},
    {"glGetDetailTexFuncSGIS", &retrace::ignore},
    {"glSharpenTexFuncSGIS", &retrace_glSharpenTexFuncSGIS},
    {"glGetSharpenTexFuncSGIS", &retrace::ignore},
    {"glSampleMaskSGIS", &retrace_glSampleMaskSGIS},
    {"glSamplePatternSGIS", &retrace_glSamplePatternSGIS},
    {"glArrayElementEXT", &retrace_glArrayElementEXT},
    {"glColorPointerEXT", &retrace_glColorPointerEXT},
    {"glDrawArraysEXT", &retrace_glDrawArraysEXT},
    {"glEdgeFlagPointerEXT", &retrace_glEdgeFlagPointerEXT},
    {"glGetPointervEXT", &retrace::ignore},
    {"glIndexPointerEXT", &retrace_glIndexPointerEXT},
    {"glNormalPointerEXT", &retrace_glNormalPointerEXT},
    {"glTexCoordPointerEXT", &retrace_glTexCoordPointerEXT},
    {"glVertexPointerEXT", &retrace_glVertexPointerEXT},
    {"glBlendEquationEXT", &retrace_glBlendEquationEXT},
    {"glSpriteParameterfSGIX", &retrace_glSpriteParameterfSGIX},
    {"glSpriteParameterfvSGIX", &retrace_glSpriteParameterfvSGIX},
    {"glSpriteParameteriSGIX", &retrace_glSpriteParameteriSGIX},
    {"glSpriteParameterivSGIX", &retrace_glSpriteParameterivSGIX},
    {"glPointParameterfEXT", &retrace_glPointParameterfEXT},
    {"glPointParameterfvEXT", &retrace_glPointParameterfvEXT},
    {"glPointParameterfSGIS", &retrace_glPointParameterfSGIS},
    {"glPointParameterfvSGIS", &retrace_glPointParameterfvSGIS},
    {"glGetInstrumentsSGIX", &retrace::ignore},
    {"glInstrumentsBufferSGIX", &retrace_glInstrumentsBufferSGIX},
    {"glPollInstrumentsSGIX", &retrace_glPollInstrumentsSGIX},
    {"glReadInstrumentsSGIX", &retrace_glReadInstrumentsSGIX},
    {"glStartInstrumentsSGIX", &retrace_glStartInstrumentsSGIX},
    {"glStopInstrumentsSGIX", &retrace_glStopInstrumentsSGIX},
    {"glFrameZoomSGIX", &retrace_glFrameZoomSGIX},
    {"glTagSampleBufferSGIX", &retrace_glTagSampleBufferSGIX},
    {"glDeformationMap3dSGIX", &retrace_glDeformationMap3dSGIX},
    {"glDeformationMap3fSGIX", &retrace_glDeformationMap3fSGIX},
    {"glDeformSGIX", &retrace_glDeformSGIX},
    {"glLoadIdentityDeformationMapSGIX", &retrace_glLoadIdentityDeformationMapSGIX},
    {"glReferencePlaneSGIX", &retrace_glReferencePlaneSGIX},
    {"glFlushRasterSGIX", &retrace_glFlushRasterSGIX},
    {"glFogFuncSGIS", &retrace_glFogFuncSGIS},
    {"glGetFogFuncSGIS", &retrace::ignore},
    {"glImageTransformParameteriHP", &retrace_glImageTransformParameteriHP},
    {"glImageTransformParameterfHP", &retrace_glImageTransformParameterfHP},
    {"glImageTransformParameterivHP", &retrace_glImageTransformParameterivHP},
    {"glImageTransformParameterfvHP", &retrace_glImageTransformParameterfvHP},
    {"glGetImageTransformParameterivHP", &retrace::ignore},
    {"glGetImageTransformParameterfvHP", &retrace::ignore},
    {"glColorSubTableEXT", &retrace_glColorSubTableEXT},
    {"glCopyColorSubTableEXT", &retrace_glCopyColorSubTableEXT},
    {"glHintPGI", &retrace_glHintPGI},
    {"glColorTableEXT", &retrace_glColorTableEXT},
    {"glGetColorTableEXT", &retrace::ignore},
    {"glGetColorTableParameterivEXT", &retrace::ignore},
    {"glGetColorTableParameterfvEXT", &retrace::ignore},
    {"glGetListParameterfvSGIX", &retrace::ignore},
    {"glGetListParameterivSGIX", &retrace::ignore},
    {"glListParameterfSGIX", &retrace_glListParameterfSGIX},
    {"glListParameterfvSGIX", &retrace_glListParameterfvSGIX},
    {"glListParameteriSGIX", &retrace_glListParameteriSGIX},
    {"glListParameterivSGIX", &retrace_glListParameterivSGIX},
    {"glIndexMaterialEXT", &retrace_glIndexMaterialEXT},
    {"glIndexFuncEXT", &retrace_glIndexFuncEXT},
    {"glLockArraysEXT", &retrace_glLockArraysEXT},
    {"glUnlockArraysEXT", &retrace_glUnlockArraysEXT},
    {"glCullParameterdvEXT", &retrace_glCullParameterdvEXT},
    {"glCullParameterfvEXT", &retrace_glCullParameterfvEXT},
    {"glFragmentColorMaterialSGIX", &retrace_glFragmentColorMaterialSGIX},
    {"glFragmentLightfSGIX", &retrace_glFragmentLightfSGIX},
    {"glFragmentLightfvSGIX", &retrace_glFragmentLightfvSGIX},
    {"glFragmentLightiSGIX", &retrace_glFragmentLightiSGIX},
    {"glFragmentLightivSGIX", &retrace_glFragmentLightivSGIX},
    {"glFragmentLightModelfSGIX", &retrace_glFragmentLightModelfSGIX},
    {"glFragmentLightModelfvSGIX", &retrace_glFragmentLightModelfvSGIX},
    {"glFragmentLightModeliSGIX", &retrace_glFragmentLightModeliSGIX},
    {"glFragmentLightModelivSGIX", &retrace_glFragmentLightModelivSGIX},
    {"glFragmentMaterialfSGIX", &retrace_glFragmentMaterialfSGIX},
    {"glFragmentMaterialfvSGIX", &retrace_glFragmentMaterialfvSGIX},
    {"glFragmentMaterialiSGIX", &retrace_glFragmentMaterialiSGIX},
    {"glFragmentMaterialivSGIX", &retrace_glFragmentMaterialivSGIX},
    {"glGetFragmentLightfvSGIX", &retrace::ignore},
    {"glGetFragmentLightivSGIX", &retrace::ignore},
    {"glGetFragmentMaterialfvSGIX", &retrace::ignore},
    {"glGetFragmentMaterialivSGIX", &retrace::ignore},
    {"glLightEnviSGIX", &retrace_glLightEnviSGIX},
    {"glDrawRangeElementsEXT", &retrace_glDrawRangeElementsEXT},
    {"glApplyTextureEXT", &retrace_glApplyTextureEXT},
    {"glTextureLightEXT", &retrace_glTextureLightEXT},
    {"glTextureMaterialEXT", &retrace_glTextureMaterialEXT},
    {"glAsyncMarkerSGIX", &retrace_glAsyncMarkerSGIX},
    {"glFinishAsyncSGIX", &retrace_glFinishAsyncSGIX},
    {"glPollAsyncSGIX", &retrace_glPollAsyncSGIX},
    {"glGenAsyncMarkersSGIX", &retrace_glGenAsyncMarkersSGIX},
    {"glDeleteAsyncMarkersSGIX", &retrace_glDeleteAsyncMarkersSGIX},
    {"glIsAsyncMarkerSGIX", &retrace::ignore},
    {"glVertexPointervINTEL", &retrace_glVertexPointervINTEL},
    {"glNormalPointervINTEL", &retrace_glNormalPointervINTEL},
    {"glColorPointervINTEL", &retrace_glColorPointervINTEL},
    {"glTexCoordPointervINTEL", &retrace_glTexCoordPointervINTEL},
    {"glPixelTransformParameteriEXT", &retrace_glPixelTransformParameteriEXT},
    {"glPixelTransformParameterfEXT", &retrace_glPixelTransformParameterfEXT},
    {"glPixelTransformParameterivEXT", &retrace_glPixelTransformParameterivEXT},
    {"glPixelTransformParameterfvEXT", &retrace_glPixelTransformParameterfvEXT},
    {"glGetPixelTransformParameterivEXT", &retrace::ignore},
    {"glGetPixelTransformParameterfvEXT", &retrace::ignore},
    {"glSecondaryColor3bEXT", &retrace_glSecondaryColor3bEXT},
    {"glSecondaryColor3bvEXT", &retrace_glSecondaryColor3bvEXT},
    {"glSecondaryColor3dEXT", &retrace_glSecondaryColor3dEXT},
    {"glSecondaryColor3dvEXT", &retrace_glSecondaryColor3dvEXT},
    {"glSecondaryColor3fEXT", &retrace_glSecondaryColor3fEXT},
    {"glSecondaryColor3fvEXT", &retrace_glSecondaryColor3fvEXT},
    {"glSecondaryColor3iEXT", &retrace_glSecondaryColor3iEXT},
    {"glSecondaryColor3ivEXT", &retrace_glSecondaryColor3ivEXT},
    {"glSecondaryColor3sEXT", &retrace_glSecondaryColor3sEXT},
    {"glSecondaryColor3svEXT", &retrace_glSecondaryColor3svEXT},
    {"glSecondaryColor3ubEXT", &retrace_glSecondaryColor3ubEXT},
    {"glSecondaryColor3ubvEXT", &retrace_glSecondaryColor3ubvEXT},
    {"glSecondaryColor3uiEXT", &retrace_glSecondaryColor3uiEXT},
    {"glSecondaryColor3uivEXT", &retrace_glSecondaryColor3uivEXT},
    {"glSecondaryColor3usEXT", &retrace_glSecondaryColor3usEXT},
    {"glSecondaryColor3usvEXT", &retrace_glSecondaryColor3usvEXT},
    {"glSecondaryColorPointerEXT", &retrace_glSecondaryColorPointerEXT},
    {"glTextureNormalEXT", &retrace_glTextureNormalEXT},
    {"glMultiDrawArraysEXT", &retrace_glMultiDrawArraysEXT},
    {"glMultiDrawElementsEXT", &retrace_glMultiDrawElementsEXT},
    {"glFogCoordfEXT", &retrace_glFogCoordfEXT},
    {"glFogCoordfvEXT", &retrace_glFogCoordfvEXT},
    {"glFogCoorddEXT", &retrace_glFogCoorddEXT},
    {"glFogCoorddvEXT", &retrace_glFogCoorddvEXT},
    {"glFogCoordPointerEXT", &retrace_glFogCoordPointerEXT},
    {"glTangent3bEXT", &retrace_glTangent3bEXT},
    {"glTangent3bvEXT", &retrace_glTangent3bvEXT},
    {"glTangent3dEXT", &retrace_glTangent3dEXT},
    {"glTangent3dvEXT", &retrace_glTangent3dvEXT},
    {"glTangent3fEXT", &retrace_glTangent3fEXT},
    {"glTangent3fvEXT", &retrace_glTangent3fvEXT},
    {"glTangent3iEXT", &retrace_glTangent3iEXT},
    {"glTangent3ivEXT", &retrace_glTangent3ivEXT},
    {"glTangent3sEXT", &retrace_glTangent3sEXT},
    {"glTangent3svEXT", &retrace_glTangent3svEXT},
    {"glBinormal3bEXT", &retrace_glBinormal3bEXT},
    {"glBinormal3bvEXT", &retrace_glBinormal3bvEXT},
    {"glBinormal3dEXT", &retrace_glBinormal3dEXT},
    {"glBinormal3dvEXT", &retrace_glBinormal3dvEXT},
    {"glBinormal3fEXT", &retrace_glBinormal3fEXT},
    {"glBinormal3fvEXT", &retrace_glBinormal3fvEXT},
    {"glBinormal3iEXT", &retrace_glBinormal3iEXT},
    {"glBinormal3ivEXT", &retrace_glBinormal3ivEXT},
    {"glBinormal3sEXT", &retrace_glBinormal3sEXT},
    {"glBinormal3svEXT", &retrace_glBinormal3svEXT},
    {"glTangentPointerEXT", &retrace_glTangentPointerEXT},
    {"glBinormalPointerEXT", &retrace_glBinormalPointerEXT},
    {"glFinishTextureSUNX", &retrace_glFinishTextureSUNX},
    {"glGlobalAlphaFactorbSUN", &retrace_glGlobalAlphaFactorbSUN},
    {"glGlobalAlphaFactorsSUN", &retrace_glGlobalAlphaFactorsSUN},
    {"glGlobalAlphaFactoriSUN", &retrace_glGlobalAlphaFactoriSUN},
    {"glGlobalAlphaFactorfSUN", &retrace_glGlobalAlphaFactorfSUN},
    {"glGlobalAlphaFactordSUN", &retrace_glGlobalAlphaFactordSUN},
    {"glGlobalAlphaFactorubSUN", &retrace_glGlobalAlphaFactorubSUN},
    {"glGlobalAlphaFactorusSUN", &retrace_glGlobalAlphaFactorusSUN},
    {"glGlobalAlphaFactoruiSUN", &retrace_glGlobalAlphaFactoruiSUN},
    {"glReplacementCodeuiSUN", &retrace_glReplacementCodeuiSUN},
    {"glReplacementCodeusSUN", &retrace_glReplacementCodeusSUN},
    {"glReplacementCodeubSUN", &retrace_glReplacementCodeubSUN},
    {"glReplacementCodeuivSUN", &retrace_glReplacementCodeuivSUN},
    {"glReplacementCodeusvSUN", &retrace_glReplacementCodeusvSUN},
    {"glReplacementCodeubvSUN", &retrace_glReplacementCodeubvSUN},
    {"glReplacementCodePointerSUN", &retrace_glReplacementCodePointerSUN},
    {"glColor4ubVertex2fSUN", &retrace_glColor4ubVertex2fSUN},
    {"glColor4ubVertex2fvSUN", &retrace_glColor4ubVertex2fvSUN},
    {"glColor4ubVertex3fSUN", &retrace_glColor4ubVertex3fSUN},
    {"glColor4ubVertex3fvSUN", &retrace_glColor4ubVertex3fvSUN},
    {"glColor3fVertex3fSUN", &retrace_glColor3fVertex3fSUN},
    {"glColor3fVertex3fvSUN", &retrace_glColor3fVertex3fvSUN},
    {"glNormal3fVertex3fSUN", &retrace_glNormal3fVertex3fSUN},
    {"glNormal3fVertex3fvSUN", &retrace_glNormal3fVertex3fvSUN},
    {"glColor4fNormal3fVertex3fSUN", &retrace_glColor4fNormal3fVertex3fSUN},
    {"glColor4fNormal3fVertex3fvSUN", &retrace_glColor4fNormal3fVertex3fvSUN},
    {"glTexCoord2fVertex3fSUN", &retrace_glTexCoord2fVertex3fSUN},
    {"glTexCoord2fVertex3fvSUN", &retrace_glTexCoord2fVertex3fvSUN},
    {"glTexCoord4fVertex4fSUN", &retrace_glTexCoord4fVertex4fSUN},
    {"glTexCoord4fVertex4fvSUN", &retrace_glTexCoord4fVertex4fvSUN},
    {"glTexCoord2fColor4ubVertex3fSUN", &retrace_glTexCoord2fColor4ubVertex3fSUN},
    {"glTexCoord2fColor4ubVertex3fvSUN", &retrace_glTexCoord2fColor4ubVertex3fvSUN},
    {"glTexCoord2fColor3fVertex3fSUN", &retrace_glTexCoord2fColor3fVertex3fSUN},
    {"glTexCoord2fColor3fVertex3fvSUN", &retrace_glTexCoord2fColor3fVertex3fvSUN},
    {"glTexCoord2fNormal3fVertex3fSUN", &retrace_glTexCoord2fNormal3fVertex3fSUN},
    {"glTexCoord2fNormal3fVertex3fvSUN", &retrace_glTexCoord2fNormal3fVertex3fvSUN},
    {"glTexCoord2fColor4fNormal3fVertex3fSUN", &retrace_glTexCoord2fColor4fNormal3fVertex3fSUN},
    {"glTexCoord2fColor4fNormal3fVertex3fvSUN", &retrace_glTexCoord2fColor4fNormal3fVertex3fvSUN},
    {"glTexCoord4fColor4fNormal3fVertex4fSUN", &retrace_glTexCoord4fColor4fNormal3fVertex4fSUN},
    {"glTexCoord4fColor4fNormal3fVertex4fvSUN", &retrace_glTexCoord4fColor4fNormal3fVertex4fvSUN},
    {"glReplacementCodeuiVertex3fSUN", &retrace_glReplacementCodeuiVertex3fSUN},
    {"glReplacementCodeuiVertex3fvSUN", &retrace_glReplacementCodeuiVertex3fvSUN},
    {"glReplacementCodeuiColor4ubVertex3fSUN", &retrace_glReplacementCodeuiColor4ubVertex3fSUN},
    {"glReplacementCodeuiColor4ubVertex3fvSUN", &retrace_glReplacementCodeuiColor4ubVertex3fvSUN},
    {"glReplacementCodeuiColor3fVertex3fSUN", &retrace_glReplacementCodeuiColor3fVertex3fSUN},
    {"glReplacementCodeuiColor3fVertex3fvSUN", &retrace_glReplacementCodeuiColor3fVertex3fvSUN},
    {"glReplacementCodeuiNormal3fVertex3fSUN", &retrace_glReplacementCodeuiNormal3fVertex3fSUN},
    {"glReplacementCodeuiNormal3fVertex3fvSUN", &retrace_glReplacementCodeuiNormal3fVertex3fvSUN},
    {"glReplacementCodeuiColor4fNormal3fVertex3fSUN", &retrace_glReplacementCodeuiColor4fNormal3fVertex3fSUN},
    {"glReplacementCodeuiColor4fNormal3fVertex3fvSUN", &retrace_glReplacementCodeuiColor4fNormal3fVertex3fvSUN},
    {"glReplacementCodeuiTexCoord2fVertex3fSUN", &retrace_glReplacementCodeuiTexCoord2fVertex3fSUN},
    {"glReplacementCodeuiTexCoord2fVertex3fvSUN", &retrace_glReplacementCodeuiTexCoord2fVertex3fvSUN},
    {"glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN", &retrace_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN},
    {"glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN", &retrace_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN},
    {"glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN", &retrace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN},
    {"glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN", &retrace_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN},
    {"glBlendFuncSeparateEXT", &retrace_glBlendFuncSeparateEXT},
    {"glBlendFuncSeparateINGR", &retrace_glBlendFuncSeparateINGR},
    {"glVertexWeightfEXT", &retrace_glVertexWeightfEXT},
    {"glVertexWeightfvEXT", &retrace_glVertexWeightfvEXT},
    {"glVertexWeightPointerEXT", &retrace_glVertexWeightPointerEXT},
    {"glFlushVertexArrayRangeNV", &retrace_glFlushVertexArrayRangeNV},
    {"glVertexArrayRangeNV", &retrace_glVertexArrayRangeNV},
    {"glCombinerParameterfvNV", &retrace_glCombinerParameterfvNV},
    {"glCombinerParameterfNV", &retrace_glCombinerParameterfNV},
    {"glCombinerParameterivNV", &retrace_glCombinerParameterivNV},
    {"glCombinerParameteriNV", &retrace_glCombinerParameteriNV},
    {"glCombinerInputNV", &retrace_glCombinerInputNV},
    {"glCombinerOutputNV", &retrace_glCombinerOutputNV},
    {"glFinalCombinerInputNV", &retrace_glFinalCombinerInputNV},
    {"glGetCombinerInputParameterfvNV", &retrace::ignore},
    {"glGetCombinerInputParameterivNV", &retrace::ignore},
    {"glGetCombinerOutputParameterfvNV", &retrace::ignore},
    {"glGetCombinerOutputParameterivNV", &retrace::ignore},
    {"glGetFinalCombinerInputParameterfvNV", &retrace::ignore},
    {"glGetFinalCombinerInputParameterivNV", &retrace::ignore},
    {"glGenPathsNV", &retrace_glGenPathsNV},
    {"glDeletePathsNV", &retrace_glDeletePathsNV},
    {"glIsPathNV", &retrace_glIsPathNV},
    {"glPathCommandsNV", &retrace_glPathCommandsNV},
    {"glPathCoordsNV", &retrace_glPathCoordsNV},
    {"glPathSubCommandsNV", &retrace_glPathSubCommandsNV},
    {"glPathSubCoordsNV", &retrace_glPathSubCoordsNV},
    {"glPathStringNV", &retrace_glPathStringNV},
    {"glPathGlyphsNV", &retrace_glPathGlyphsNV},
    {"glPathGlyphRangeNV", &retrace_glPathGlyphRangeNV},
    {"glWeightPathsNV", &retrace_glWeightPathsNV},
    {"glCopyPathNV", &retrace_glCopyPathNV},
    {"glInterpolatePathsNV", &retrace_glInterpolatePathsNV},
    {"glTransformPathNV", &retrace_glTransformPathNV},
    {"glPathParameterivNV", &retrace_glPathParameterivNV},
    {"glPathParameteriNV", &retrace_glPathParameteriNV},
    {"glPathParameterfvNV", &retrace_glPathParameterfvNV},
    {"glPathParameterfNV", &retrace_glPathParameterfNV},
    {"glPathDashArrayNV", &retrace_glPathDashArrayNV},
    {"glPathStencilFuncNV", &retrace_glPathStencilFuncNV},
    {"glPathStencilDepthOffsetNV", &retrace_glPathStencilDepthOffsetNV},
    {"glStencilFillPathNV", &retrace_glStencilFillPathNV},
    {"glStencilStrokePathNV", &retrace_glStencilStrokePathNV},
    {"glStencilFillPathInstancedNV", &retrace_glStencilFillPathInstancedNV},
    {"glStencilStrokePathInstancedNV", &retrace_glStencilStrokePathInstancedNV},
    {"glPathCoverDepthFuncNV", &retrace_glPathCoverDepthFuncNV},
    {"glPathColorGenNV", &retrace_glPathColorGenNV},
    {"glPathTexGenNV", &retrace_glPathTexGenNV},
    {"glPathFogGenNV", &retrace_glPathFogGenNV},
    {"glCoverFillPathNV", &retrace_glCoverFillPathNV},
    {"glCoverStrokePathNV", &retrace_glCoverStrokePathNV},
    {"glCoverFillPathInstancedNV", &retrace_glCoverFillPathInstancedNV},
    {"glCoverStrokePathInstancedNV", &retrace_glCoverStrokePathInstancedNV},
    {"glGetPathParameterivNV", &retrace::ignore},
    {"glGetPathParameterfvNV", &retrace::ignore},
    {"glGetPathCommandsNV", &retrace::ignore},
    {"glGetPathCoordsNV", &retrace::ignore},
    {"glGetPathDashArrayNV", &retrace::ignore},
    {"glGetPathMetricsNV", &retrace::ignore},
    {"glGetPathMetricRangeNV", &retrace::ignore},
    {"glGetPathSpacingNV", &retrace_glGetPathSpacingNV},
    {"glGetPathColorGenivNV", &retrace::ignore},
    {"glGetPathColorGenfvNV", &retrace::ignore},
    {"glGetPathTexGenivNV", &retrace::ignore},
    {"glGetPathTexGenfvNV", &retrace::ignore},
    {"glIsPointInFillPathNV", &retrace::ignore},
    {"glIsPointInStrokePathNV", &retrace::ignore},
    {"glGetPathLengthNV", &retrace_glGetPathLengthNV},
    {"glPointAlongPathNV", &retrace::ignore},
    {"glResizeBuffersMESA", &retrace_glResizeBuffersMESA},
    {"glWindowPos2dMESA", &retrace_glWindowPos2dMESA},
    {"glWindowPos2dvMESA", &retrace_glWindowPos2dvMESA},
    {"glWindowPos2fMESA", &retrace_glWindowPos2fMESA},
    {"glWindowPos2fvMESA", &retrace_glWindowPos2fvMESA},
    {"glWindowPos2iMESA", &retrace_glWindowPos2iMESA},
    {"glWindowPos2ivMESA", &retrace_glWindowPos2ivMESA},
    {"glWindowPos2sMESA", &retrace_glWindowPos2sMESA},
    {"glWindowPos2svMESA", &retrace_glWindowPos2svMESA},
    {"glWindowPos3dMESA", &retrace_glWindowPos3dMESA},
    {"glWindowPos3dvMESA", &retrace_glWindowPos3dvMESA},
    {"glWindowPos3fMESA", &retrace_glWindowPos3fMESA},
    {"glWindowPos3fvMESA", &retrace_glWindowPos3fvMESA},
    {"glWindowPos3iMESA", &retrace_glWindowPos3iMESA},
    {"glWindowPos3ivMESA", &retrace_glWindowPos3ivMESA},
    {"glWindowPos3sMESA", &retrace_glWindowPos3sMESA},
    {"glWindowPos3svMESA", &retrace_glWindowPos3svMESA},
    {"glWindowPos4dMESA", &retrace_glWindowPos4dMESA},
    {"glWindowPos4dvMESA", &retrace_glWindowPos4dvMESA},
    {"glWindowPos4fMESA", &retrace_glWindowPos4fMESA},
    {"glWindowPos4fvMESA", &retrace_glWindowPos4fvMESA},
    {"glWindowPos4iMESA", &retrace_glWindowPos4iMESA},
    {"glWindowPos4ivMESA", &retrace_glWindowPos4ivMESA},
    {"glWindowPos4sMESA", &retrace_glWindowPos4sMESA},
    {"glWindowPos4svMESA", &retrace_glWindowPos4svMESA},
    {"glMultiModeDrawArraysIBM", &retrace_glMultiModeDrawArraysIBM},
    {"glMultiModeDrawElementsIBM", &retrace_glMultiModeDrawElementsIBM},
    {"glColorPointerListIBM", &retrace_glColorPointerListIBM},
    {"glSecondaryColorPointerListIBM", &retrace_glSecondaryColorPointerListIBM},
    {"glEdgeFlagPointerListIBM", &retrace_glEdgeFlagPointerListIBM},
    {"glFogCoordPointerListIBM", &retrace_glFogCoordPointerListIBM},
    {"glIndexPointerListIBM", &retrace_glIndexPointerListIBM},
    {"glNormalPointerListIBM", &retrace_glNormalPointerListIBM},
    {"glTexCoordPointerListIBM", &retrace_glTexCoordPointerListIBM},
    {"glVertexPointerListIBM", &retrace_glVertexPointerListIBM},
    {"glTbufferMask3DFX", &retrace_glTbufferMask3DFX},
    {"glSampleMaskEXT", &retrace_glSampleMaskEXT},
    {"glSamplePatternEXT", &retrace_glSamplePatternEXT},
    {"glTextureColorMaskSGIS", &retrace_glTextureColorMaskSGIS},
    {"glIglooInterfaceSGIX", &retrace_glIglooInterfaceSGIX},
    {"glDeleteFencesNV", &retrace_glDeleteFencesNV},
    {"glGenFencesNV", &retrace_glGenFencesNV},
    {"glIsFenceNV", &retrace::ignore},
    {"glTestFenceNV", &retrace_glTestFenceNV},
    {"glGetFenceivNV", &retrace::ignore},
    {"glFinishFenceNV", &retrace_glFinishFenceNV},
    {"glSetFenceNV", &retrace_glSetFenceNV},
    {"glMapControlPointsNV", &retrace_glMapControlPointsNV},
    {"glMapParameterivNV", &retrace_glMapParameterivNV},
    {"glMapParameterfvNV", &retrace_glMapParameterfvNV},
    {"glGetMapControlPointsNV", &retrace::ignore},
    {"glGetMapParameterivNV", &retrace::ignore},
    {"glGetMapParameterfvNV", &retrace::ignore},
    {"glGetMapAttribParameterivNV", &retrace::ignore},
    {"glGetMapAttribParameterfvNV", &retrace::ignore},
    {"glEvalMapsNV", &retrace_glEvalMapsNV},
    {"glCombinerStageParameterfvNV", &retrace_glCombinerStageParameterfvNV},
    {"glGetCombinerStageParameterfvNV", &retrace::ignore},
    {"glAreProgramsResidentNV", &retrace::ignore},
    {"glBindProgramNV", &retrace_glBindProgramNV},
    {"glDeleteProgramsNV", &retrace_glDeleteProgramsNV},
    {"glExecuteProgramNV", &retrace_glExecuteProgramNV},
    {"glGenProgramsNV", &retrace_glGenProgramsNV},
    {"glGetProgramParameterdvNV", &retrace::ignore},
    {"glGetProgramParameterfvNV", &retrace::ignore},
    {"glGetProgramivNV", &retrace::ignore},
    {"glGetProgramStringNV", &retrace::ignore},
    {"glGetTrackMatrixivNV", &retrace::ignore},
    {"glGetVertexAttribdvNV", &retrace::ignore},
    {"glGetVertexAttribfvNV", &retrace::ignore},
    {"glGetVertexAttribivNV", &retrace::ignore},
    {"glGetVertexAttribPointervNV", &retrace::ignore},
    {"glIsProgramNV", &retrace::ignore},
    {"glLoadProgramNV", &retrace_glLoadProgramNV},
    {"glProgramParameter4dNV", &retrace_glProgramParameter4dNV},
    {"glProgramParameter4dvNV", &retrace_glProgramParameter4dvNV},
    {"glProgramParameter4fNV", &retrace_glProgramParameter4fNV},
    {"glProgramParameter4fvNV", &retrace_glProgramParameter4fvNV},
    {"glProgramParameters4dvNV", &retrace_glProgramParameters4dvNV},
    {"glProgramParameters4fvNV", &retrace_glProgramParameters4fvNV},
    {"glRequestResidentProgramsNV", &retrace_glRequestResidentProgramsNV},
    {"glTrackMatrixNV", &retrace_glTrackMatrixNV},
    {"glVertexAttribPointerNV", &retrace_glVertexAttribPointerNV},
    {"glVertexAttrib1dNV", &retrace_glVertexAttrib1dNV},
    {"glVertexAttrib1dvNV", &retrace_glVertexAttrib1dvNV},
    {"glVertexAttrib1fNV", &retrace_glVertexAttrib1fNV},
    {"glVertexAttrib1fvNV", &retrace_glVertexAttrib1fvNV},
    {"glVertexAttrib1sNV", &retrace_glVertexAttrib1sNV},
    {"glVertexAttrib1svNV", &retrace_glVertexAttrib1svNV},
    {"glVertexAttrib2dNV", &retrace_glVertexAttrib2dNV},
    {"glVertexAttrib2dvNV", &retrace_glVertexAttrib2dvNV},
    {"glVertexAttrib2fNV", &retrace_glVertexAttrib2fNV},
    {"glVertexAttrib2fvNV", &retrace_glVertexAttrib2fvNV},
    {"glVertexAttrib2sNV", &retrace_glVertexAttrib2sNV},
    {"glVertexAttrib2svNV", &retrace_glVertexAttrib2svNV},
    {"glVertexAttrib3dNV", &retrace_glVertexAttrib3dNV},
    {"glVertexAttrib3dvNV", &retrace_glVertexAttrib3dvNV},
    {"glVertexAttrib3fNV", &retrace_glVertexAttrib3fNV},
    {"glVertexAttrib3fvNV", &retrace_glVertexAttrib3fvNV},
    {"glVertexAttrib3sNV", &retrace_glVertexAttrib3sNV},
    {"glVertexAttrib3svNV", &retrace_glVertexAttrib3svNV},
    {"glVertexAttrib4dNV", &retrace_glVertexAttrib4dNV},
    {"glVertexAttrib4dvNV", &retrace_glVertexAttrib4dvNV},
    {"glVertexAttrib4fNV", &retrace_glVertexAttrib4fNV},
    {"glVertexAttrib4fvNV", &retrace_glVertexAttrib4fvNV},
    {"glVertexAttrib4sNV", &retrace_glVertexAttrib4sNV},
    {"glVertexAttrib4svNV", &retrace_glVertexAttrib4svNV},
    {"glVertexAttrib4ubNV", &retrace_glVertexAttrib4ubNV},
    {"glVertexAttrib4ubvNV", &retrace_glVertexAttrib4ubvNV},
    {"glVertexAttribs1dvNV", &retrace_glVertexAttribs1dvNV},
    {"glVertexAttribs1fvNV", &retrace_glVertexAttribs1fvNV},
    {"glVertexAttribs1svNV", &retrace_glVertexAttribs1svNV},
    {"glVertexAttribs2dvNV", &retrace_glVertexAttribs2dvNV},
    {"glVertexAttribs2fvNV", &retrace_glVertexAttribs2fvNV},
    {"glVertexAttribs2svNV", &retrace_glVertexAttribs2svNV},
    {"glVertexAttribs3dvNV", &retrace_glVertexAttribs3dvNV},
    {"glVertexAttribs3fvNV", &retrace_glVertexAttribs3fvNV},
    {"glVertexAttribs3svNV", &retrace_glVertexAttribs3svNV},
    {"glVertexAttribs4dvNV", &retrace_glVertexAttribs4dvNV},
    {"glVertexAttribs4fvNV", &retrace_glVertexAttribs4fvNV},
    {"glVertexAttribs4svNV", &retrace_glVertexAttribs4svNV},
    {"glVertexAttribs4ubvNV", &retrace_glVertexAttribs4ubvNV},
    {"glTexBumpParameterivATI", &retrace_glTexBumpParameterivATI},
    {"glTexBumpParameterfvATI", &retrace_glTexBumpParameterfvATI},
    {"glGetTexBumpParameterivATI", &retrace::ignore},
    {"glGetTexBumpParameterfvATI", &retrace::ignore},
    {"glGenFragmentShadersATI", &retrace_glGenFragmentShadersATI},
    {"glBindFragmentShaderATI", &retrace_glBindFragmentShaderATI},
    {"glDeleteFragmentShaderATI", &retrace_glDeleteFragmentShaderATI},
    {"glBeginFragmentShaderATI", &retrace_glBeginFragmentShaderATI},
    {"glEndFragmentShaderATI", &retrace_glEndFragmentShaderATI},
    {"glPassTexCoordATI", &retrace_glPassTexCoordATI},
    {"glSampleMapATI", &retrace_glSampleMapATI},
    {"glColorFragmentOp1ATI", &retrace_glColorFragmentOp1ATI},
    {"glColorFragmentOp2ATI", &retrace_glColorFragmentOp2ATI},
    {"glColorFragmentOp3ATI", &retrace_glColorFragmentOp3ATI},
    {"glAlphaFragmentOp1ATI", &retrace_glAlphaFragmentOp1ATI},
    {"glAlphaFragmentOp2ATI", &retrace_glAlphaFragmentOp2ATI},
    {"glAlphaFragmentOp3ATI", &retrace_glAlphaFragmentOp3ATI},
    {"glSetFragmentShaderConstantATI", &retrace_glSetFragmentShaderConstantATI},
    {"glPNTrianglesiATI", &retrace_glPNTrianglesiATI},
    {"glPNTrianglesfATI", &retrace_glPNTrianglesfATI},
    {"glNewObjectBufferATI", &retrace_glNewObjectBufferATI},
    {"glIsObjectBufferATI", &retrace::ignore},
    {"glUpdateObjectBufferATI", &retrace_glUpdateObjectBufferATI},
    {"glGetObjectBufferfvATI", &retrace::ignore},
    {"glGetObjectBufferivATI", &retrace::ignore},
    {"glFreeObjectBufferATI", &retrace_glFreeObjectBufferATI},
    {"glArrayObjectATI", &retrace_glArrayObjectATI},
    {"glGetArrayObjectfvATI", &retrace::ignore},
    {"glGetArrayObjectivATI", &retrace::ignore},
    {"glVariantArrayObjectATI", &retrace_glVariantArrayObjectATI},
    {"glGetVariantArrayObjectfvATI", &retrace::ignore},
    {"glGetVariantArrayObjectivATI", &retrace::ignore},
    {"glBeginVertexShaderEXT", &retrace_glBeginVertexShaderEXT},
    {"glEndVertexShaderEXT", &retrace_glEndVertexShaderEXT},
    {"glBindVertexShaderEXT", &retrace_glBindVertexShaderEXT},
    {"glGenVertexShadersEXT", &retrace_glGenVertexShadersEXT},
    {"glDeleteVertexShaderEXT", &retrace_glDeleteVertexShaderEXT},
    {"glShaderOp1EXT", &retrace_glShaderOp1EXT},
    {"glShaderOp2EXT", &retrace_glShaderOp2EXT},
    {"glShaderOp3EXT", &retrace_glShaderOp3EXT},
    {"glSwizzleEXT", &retrace_glSwizzleEXT},
    {"glWriteMaskEXT", &retrace_glWriteMaskEXT},
    {"glInsertComponentEXT", &retrace_glInsertComponentEXT},
    {"glExtractComponentEXT", &retrace_glExtractComponentEXT},
    {"glGenSymbolsEXT", &retrace_glGenSymbolsEXT},
    {"glSetInvariantEXT", &retrace_glSetInvariantEXT},
    {"glSetLocalConstantEXT", &retrace_glSetLocalConstantEXT},
    {"glVariantbvEXT", &retrace_glVariantbvEXT},
    {"glVariantsvEXT", &retrace_glVariantsvEXT},
    {"glVariantivEXT", &retrace_glVariantivEXT},
    {"glVariantfvEXT", &retrace_glVariantfvEXT},
    {"glVariantdvEXT", &retrace_glVariantdvEXT},
    {"glVariantubvEXT", &retrace_glVariantubvEXT},
    {"glVariantusvEXT", &retrace_glVariantusvEXT},
    {"glVariantuivEXT", &retrace_glVariantuivEXT},
    {"glVariantPointerEXT", &retrace_glVariantPointerEXT},
    {"glEnableVariantClientStateEXT", &retrace_glEnableVariantClientStateEXT},
    {"glDisableVariantClientStateEXT", &retrace_glDisableVariantClientStateEXT},
    {"glBindLightParameterEXT", &retrace_glBindLightParameterEXT},
    {"glBindMaterialParameterEXT", &retrace_glBindMaterialParameterEXT},
    {"glBindTexGenParameterEXT", &retrace_glBindTexGenParameterEXT},
    {"glBindTextureUnitParameterEXT", &retrace_glBindTextureUnitParameterEXT},
    {"glBindParameterEXT", &retrace_glBindParameterEXT},
    {"glIsVariantEnabledEXT", &retrace::ignore},
    {"glGetVariantBooleanvEXT", &retrace::ignore},
    {"glGetVariantIntegervEXT", &retrace::ignore},
    {"glGetVariantFloatvEXT", &retrace::ignore},
    {"glGetVariantPointervEXT", &retrace::ignore},
    {"glGetInvariantBooleanvEXT", &retrace::ignore},
    {"glGetInvariantIntegervEXT", &retrace::ignore},
    {"glGetInvariantFloatvEXT", &retrace::ignore},
    {"glGetLocalConstantBooleanvEXT", &retrace::ignore},
    {"glGetLocalConstantIntegervEXT", &retrace::ignore},
    {"glGetLocalConstantFloatvEXT", &retrace::ignore},
    {"glVertexStream1sATI", &retrace_glVertexStream1sATI},
    {"glVertexStream1svATI", &retrace_glVertexStream1svATI},
    {"glVertexStream1iATI", &retrace_glVertexStream1iATI},
    {"glVertexStream1ivATI", &retrace_glVertexStream1ivATI},
    {"glVertexStream1fATI", &retrace_glVertexStream1fATI},
    {"glVertexStream1fvATI", &retrace_glVertexStream1fvATI},
    {"glVertexStream1dATI", &retrace_glVertexStream1dATI},
    {"glVertexStream1dvATI", &retrace_glVertexStream1dvATI},
    {"glVertexStream2sATI", &retrace_glVertexStream2sATI},
    {"glVertexStream2svATI", &retrace_glVertexStream2svATI},
    {"glVertexStream2iATI", &retrace_glVertexStream2iATI},
    {"glVertexStream2ivATI", &retrace_glVertexStream2ivATI},
    {"glVertexStream2fATI", &retrace_glVertexStream2fATI},
    {"glVertexStream2fvATI", &retrace_glVertexStream2fvATI},
    {"glVertexStream2dATI", &retrace_glVertexStream2dATI},
    {"glVertexStream2dvATI", &retrace_glVertexStream2dvATI},
    {"glVertexStream3sATI", &retrace_glVertexStream3sATI},
    {"glVertexStream3svATI", &retrace_glVertexStream3svATI},
    {"glVertexStream3iATI", &retrace_glVertexStream3iATI},
    {"glVertexStream3ivATI", &retrace_glVertexStream3ivATI},
    {"glVertexStream3fATI", &retrace_glVertexStream3fATI},
    {"glVertexStream3fvATI", &retrace_glVertexStream3fvATI},
    {"glVertexStream3dATI", &retrace_glVertexStream3dATI},
    {"glVertexStream3dvATI", &retrace_glVertexStream3dvATI},
    {"glVertexStream4sATI", &retrace_glVertexStream4sATI},
    {"glVertexStream4svATI", &retrace_glVertexStream4svATI},
    {"glVertexStream4iATI", &retrace_glVertexStream4iATI},
    {"glVertexStream4ivATI", &retrace_glVertexStream4ivATI},
    {"glVertexStream4fATI", &retrace_glVertexStream4fATI},
    {"glVertexStream4fvATI", &retrace_glVertexStream4fvATI},
    {"glVertexStream4dATI", &retrace_glVertexStream4dATI},
    {"glVertexStream4dvATI", &retrace_glVertexStream4dvATI},
    {"glNormalStream3bATI", &retrace_glNormalStream3bATI},
    {"glNormalStream3bvATI", &retrace_glNormalStream3bvATI},
    {"glNormalStream3sATI", &retrace_glNormalStream3sATI},
    {"glNormalStream3svATI", &retrace_glNormalStream3svATI},
    {"glNormalStream3iATI", &retrace_glNormalStream3iATI},
    {"glNormalStream3ivATI", &retrace_glNormalStream3ivATI},
    {"glNormalStream3fATI", &retrace_glNormalStream3fATI},
    {"glNormalStream3fvATI", &retrace_glNormalStream3fvATI},
    {"glNormalStream3dATI", &retrace_glNormalStream3dATI},
    {"glNormalStream3dvATI", &retrace_glNormalStream3dvATI},
    {"glClientActiveVertexStreamATI", &retrace_glClientActiveVertexStreamATI},
    {"glVertexBlendEnviATI", &retrace_glVertexBlendEnviATI},
    {"glVertexBlendEnvfATI", &retrace_glVertexBlendEnvfATI},
    {"glElementPointerATI", &retrace_glElementPointerATI},
    {"glDrawElementArrayATI", &retrace_glDrawElementArrayATI},
    {"glDrawRangeElementArrayATI", &retrace_glDrawRangeElementArrayATI},
    {"glDrawMeshArraysSUN", &retrace_glDrawMeshArraysSUN},
    {"glGenOcclusionQueriesNV", &retrace_glGenOcclusionQueriesNV},
    {"glDeleteOcclusionQueriesNV", &retrace_glDeleteOcclusionQueriesNV},
    {"glIsOcclusionQueryNV", &retrace::ignore},
    {"glBeginOcclusionQueryNV", &retrace_glBeginOcclusionQueryNV},
    {"glEndOcclusionQueryNV", &retrace_glEndOcclusionQueryNV},
    {"glGetOcclusionQueryivNV", &retrace::ignore},
    {"glGetOcclusionQueryuivNV", &retrace::ignore},
    {"glPointParameteriNV", &retrace_glPointParameteriNV},
    {"glPointParameterivNV", &retrace_glPointParameterivNV},
    {"glActiveStencilFaceEXT", &retrace_glActiveStencilFaceEXT},
    {"glElementPointerAPPLE", &retrace_glElementPointerAPPLE},
    {"glDrawElementArrayAPPLE", &retrace_glDrawElementArrayAPPLE},
    {"glDrawRangeElementArrayAPPLE", &retrace_glDrawRangeElementArrayAPPLE},
    {"glMultiDrawElementArrayAPPLE", &retrace_glMultiDrawElementArrayAPPLE},
    {"glMultiDrawRangeElementArrayAPPLE", &retrace_glMultiDrawRangeElementArrayAPPLE},
    {"glGenFencesAPPLE", &retrace_glGenFencesAPPLE},
    {"glDeleteFencesAPPLE", &retrace_glDeleteFencesAPPLE},
    {"glSetFenceAPPLE", &retrace_glSetFenceAPPLE},
    {"glIsFenceAPPLE", &retrace::ignore},
    {"glTestFenceAPPLE", &retrace_glTestFenceAPPLE},
    {"glFinishFenceAPPLE", &retrace_glFinishFenceAPPLE},
    {"glTestObjectAPPLE", &retrace_glTestObjectAPPLE},
    {"glFinishObjectAPPLE", &retrace_glFinishObjectAPPLE},
    {"glBindVertexArrayAPPLE", &retrace_glBindVertexArrayAPPLE},
    {"glDeleteVertexArraysAPPLE", &retrace_glDeleteVertexArraysAPPLE},
    {"glGenVertexArraysAPPLE", &retrace_glGenVertexArraysAPPLE},
    {"glIsVertexArrayAPPLE", &retrace::ignore},
    {"glVertexArrayRangeAPPLE", &retrace_glVertexArrayRangeAPPLE},
    {"glFlushVertexArrayRangeAPPLE", &retrace_glFlushVertexArrayRangeAPPLE},
    {"glVertexArrayParameteriAPPLE", &retrace_glVertexArrayParameteriAPPLE},
    {"glFlushRenderAPPLE", &retrace_glFlushRenderAPPLE},
    {"glFinishRenderAPPLE", &retrace_glFinishRenderAPPLE},
    {"glSwapAPPLE", &retrace_glSwapAPPLE},
    {"glDrawBuffersATI", &retrace_glDrawBuffersATI},
    {"glProgramNamedParameter4fNV", &retrace_glProgramNamedParameter4fNV},
    {"glProgramNamedParameter4dNV", &retrace_glProgramNamedParameter4dNV},
    {"glProgramNamedParameter4fvNV", &retrace_glProgramNamedParameter4fvNV},
    {"glProgramNamedParameter4dvNV", &retrace_glProgramNamedParameter4dvNV},
    {"glGetProgramNamedParameterdvNV", &retrace::ignore},
    {"glGetProgramNamedParameterfvNV", &retrace::ignore},
    {"glVertex2hNV", &retrace_glVertex2hNV},
    {"glVertex2hvNV", &retrace_glVertex2hvNV},
    {"glVertex3hNV", &retrace_glVertex3hNV},
    {"glVertex3hvNV", &retrace_glVertex3hvNV},
    {"glVertex4hNV", &retrace_glVertex4hNV},
    {"glVertex4hvNV", &retrace_glVertex4hvNV},
    {"glNormal3hNV", &retrace_glNormal3hNV},
    {"glNormal3hvNV", &retrace_glNormal3hvNV},
    {"glColor3hNV", &retrace_glColor3hNV},
    {"glColor3hvNV", &retrace_glColor3hvNV},
    {"glColor4hNV", &retrace_glColor4hNV},
    {"glColor4hvNV", &retrace_glColor4hvNV},
    {"glTexCoord1hNV", &retrace_glTexCoord1hNV},
    {"glTexCoord1hvNV", &retrace_glTexCoord1hvNV},
    {"glTexCoord2hNV", &retrace_glTexCoord2hNV},
    {"glTexCoord2hvNV", &retrace_glTexCoord2hvNV},
    {"glTexCoord3hNV", &retrace_glTexCoord3hNV},
    {"glTexCoord3hvNV", &retrace_glTexCoord3hvNV},
    {"glTexCoord4hNV", &retrace_glTexCoord4hNV},
    {"glTexCoord4hvNV", &retrace_glTexCoord4hvNV},
    {"glMultiTexCoord1hNV", &retrace_glMultiTexCoord1hNV},
    {"glMultiTexCoord1hvNV", &retrace_glMultiTexCoord1hvNV},
    {"glMultiTexCoord2hNV", &retrace_glMultiTexCoord2hNV},
    {"glMultiTexCoord2hvNV", &retrace_glMultiTexCoord2hvNV},
    {"glMultiTexCoord3hNV", &retrace_glMultiTexCoord3hNV},
    {"glMultiTexCoord3hvNV", &retrace_glMultiTexCoord3hvNV},
    {"glMultiTexCoord4hNV", &retrace_glMultiTexCoord4hNV},
    {"glMultiTexCoord4hvNV", &retrace_glMultiTexCoord4hvNV},
    {"glFogCoordhNV", &retrace_glFogCoordhNV},
    {"glFogCoordhvNV", &retrace_glFogCoordhvNV},
    {"glSecondaryColor3hNV", &retrace_glSecondaryColor3hNV},
    {"glSecondaryColor3hvNV", &retrace_glSecondaryColor3hvNV},
    {"glVertexWeighthNV", &retrace_glVertexWeighthNV},
    {"glVertexWeighthvNV", &retrace_glVertexWeighthvNV},
    {"glVertexAttrib1hNV", &retrace_glVertexAttrib1hNV},
    {"glVertexAttrib1hvNV", &retrace_glVertexAttrib1hvNV},
    {"glVertexAttrib2hNV", &retrace_glVertexAttrib2hNV},
    {"glVertexAttrib2hvNV", &retrace_glVertexAttrib2hvNV},
    {"glVertexAttrib3hNV", &retrace_glVertexAttrib3hNV},
    {"glVertexAttrib3hvNV", &retrace_glVertexAttrib3hvNV},
    {"glVertexAttrib4hNV", &retrace_glVertexAttrib4hNV},
    {"glVertexAttrib4hvNV", &retrace_glVertexAttrib4hvNV},
    {"glVertexAttribs1hvNV", &retrace_glVertexAttribs1hvNV},
    {"glVertexAttribs2hvNV", &retrace_glVertexAttribs2hvNV},
    {"glVertexAttribs3hvNV", &retrace_glVertexAttribs3hvNV},
    {"glVertexAttribs4hvNV", &retrace_glVertexAttribs4hvNV},
    {"glPixelDataRangeNV", &retrace_glPixelDataRangeNV},
    {"glFlushPixelDataRangeNV", &retrace_glFlushPixelDataRangeNV},
    {"glPrimitiveRestartNV", &retrace_glPrimitiveRestartNV},
    {"glPrimitiveRestartIndexNV", &retrace_glPrimitiveRestartIndexNV},
    {"glMapObjectBufferATI", &retrace_glMapObjectBufferATI},
    {"glUnmapObjectBufferATI", &retrace_glUnmapObjectBufferATI},
    {"glStencilOpSeparateATI", &retrace_glStencilOpSeparateATI},
    {"glStencilFuncSeparateATI", &retrace_glStencilFuncSeparateATI},
    {"glVertexAttribArrayObjectATI", &retrace_glVertexAttribArrayObjectATI},
    {"glGetVertexAttribArrayObjectfvATI", &retrace::ignore},
    {"glGetVertexAttribArrayObjectivATI", &retrace::ignore},
    {"glDepthBoundsEXT", &retrace_glDepthBoundsEXT},
    {"glBlendEquationSeparateEXT", &retrace_glBlendEquationSeparateEXT},
    {"glIsRenderbufferEXT", &retrace::ignore},
    {"glBindRenderbufferEXT", &retrace_glBindRenderbufferEXT},
    {"glDeleteRenderbuffersEXT", &retrace_glDeleteRenderbuffersEXT},
    {"glGenRenderbuffersEXT", &retrace_glGenRenderbuffersEXT},
    {"glRenderbufferStorageEXT", &retrace_glRenderbufferStorageEXT},
    {"glGetRenderbufferParameterivEXT", &retrace::ignore},
    {"glIsFramebufferEXT", &retrace::ignore},
    {"glBindFramebufferEXT", &retrace_glBindFramebufferEXT},
    {"glDeleteFramebuffersEXT", &retrace_glDeleteFramebuffersEXT},
    {"glGenFramebuffersEXT", &retrace_glGenFramebuffersEXT},
    {"glCheckFramebufferStatusEXT", &retrace_glCheckFramebufferStatusEXT},
    {"glFramebufferTexture1DEXT", &retrace_glFramebufferTexture1DEXT},
    {"glFramebufferTexture2DEXT", &retrace_glFramebufferTexture2DEXT},
    {"glFramebufferTexture3DEXT", &retrace_glFramebufferTexture3DEXT},
    {"glFramebufferRenderbufferEXT", &retrace_glFramebufferRenderbufferEXT},
    {"glGetFramebufferAttachmentParameterivEXT", &retrace::ignore},
    {"glGenerateMipmapEXT", &retrace_glGenerateMipmapEXT},
    {"glStringMarkerGREMEDY", &retrace_glStringMarkerGREMEDY},
    {"glStencilClearTagEXT", &retrace_glStencilClearTagEXT},
    {"glBlitFramebufferEXT", &retrace_glBlitFramebufferEXT},
    {"glRenderbufferStorageMultisampleEXT", &retrace_glRenderbufferStorageMultisampleEXT},
    {"glGetQueryObjecti64vEXT", &retrace::ignore},
    {"glGetQueryObjectui64vEXT", &retrace::ignore},
    {"glProgramEnvParameters4fvEXT", &retrace_glProgramEnvParameters4fvEXT},
    {"glProgramLocalParameters4fvEXT", &retrace_glProgramLocalParameters4fvEXT},
    {"glBufferParameteriAPPLE", &retrace_glBufferParameteriAPPLE},
    {"glFlushMappedBufferRangeAPPLE", &retrace_glFlushMappedBufferRangeAPPLE},
    {"glProgramLocalParameterI4iNV", &retrace_glProgramLocalParameterI4iNV},
    {"glProgramLocalParameterI4ivNV", &retrace_glProgramLocalParameterI4ivNV},
    {"glProgramLocalParametersI4ivNV", &retrace_glProgramLocalParametersI4ivNV},
    {"glProgramLocalParameterI4uiNV", &retrace_glProgramLocalParameterI4uiNV},
    {"glProgramLocalParameterI4uivNV", &retrace_glProgramLocalParameterI4uivNV},
    {"glProgramLocalParametersI4uivNV", &retrace_glProgramLocalParametersI4uivNV},
    {"glProgramEnvParameterI4iNV", &retrace_glProgramEnvParameterI4iNV},
    {"glProgramEnvParameterI4ivNV", &retrace_glProgramEnvParameterI4ivNV},
    {"glProgramEnvParametersI4ivNV", &retrace_glProgramEnvParametersI4ivNV},
    {"glProgramEnvParameterI4uiNV", &retrace_glProgramEnvParameterI4uiNV},
    {"glProgramEnvParameterI4uivNV", &retrace_glProgramEnvParameterI4uivNV},
    {"glProgramEnvParametersI4uivNV", &retrace_glProgramEnvParametersI4uivNV},
    {"glGetProgramLocalParameterIivNV", &retrace::ignore},
    {"glGetProgramLocalParameterIuivNV", &retrace::ignore},
    {"glGetProgramEnvParameterIivNV", &retrace::ignore},
    {"glGetProgramEnvParameterIuivNV", &retrace::ignore},
    {"glProgramVertexLimitNV", &retrace_glProgramVertexLimitNV},
    {"glFramebufferTextureEXT", &retrace_glFramebufferTextureEXT},
    {"glFramebufferTextureLayerEXT", &retrace_glFramebufferTextureLayerEXT},
    {"glFramebufferTextureFaceEXT", &retrace_glFramebufferTextureFaceEXT},
    {"glProgramParameteriEXT", &retrace_glProgramParameteriEXT},
    {"glVertexAttribI1iEXT", &retrace_glVertexAttribI1iEXT},
    {"glVertexAttribI2iEXT", &retrace_glVertexAttribI2iEXT},
    {"glVertexAttribI3iEXT", &retrace_glVertexAttribI3iEXT},
    {"glVertexAttribI4iEXT", &retrace_glVertexAttribI4iEXT},
    {"glVertexAttribI1uiEXT", &retrace_glVertexAttribI1uiEXT},
    {"glVertexAttribI2uiEXT", &retrace_glVertexAttribI2uiEXT},
    {"glVertexAttribI3uiEXT", &retrace_glVertexAttribI3uiEXT},
    {"glVertexAttribI4uiEXT", &retrace_glVertexAttribI4uiEXT},
    {"glVertexAttribI1ivEXT", &retrace_glVertexAttribI1ivEXT},
    {"glVertexAttribI2ivEXT", &retrace_glVertexAttribI2ivEXT},
    {"glVertexAttribI3ivEXT", &retrace_glVertexAttribI3ivEXT},
    {"glVertexAttribI4ivEXT", &retrace_glVertexAttribI4ivEXT},
    {"glVertexAttribI1uivEXT", &retrace_glVertexAttribI1uivEXT},
    {"glVertexAttribI2uivEXT", &retrace_glVertexAttribI2uivEXT},
    {"glVertexAttribI3uivEXT", &retrace_glVertexAttribI3uivEXT},
    {"glVertexAttribI4uivEXT", &retrace_glVertexAttribI4uivEXT},
    {"glVertexAttribI4bvEXT", &retrace_glVertexAttribI4bvEXT},
    {"glVertexAttribI4svEXT", &retrace_glVertexAttribI4svEXT},
    {"glVertexAttribI4ubvEXT", &retrace_glVertexAttribI4ubvEXT},
    {"glVertexAttribI4usvEXT", &retrace_glVertexAttribI4usvEXT},
    {"glVertexAttribIPointerEXT", &retrace_glVertexAttribIPointerEXT},
    {"glGetVertexAttribIivEXT", &retrace::ignore},
    {"glGetVertexAttribIuivEXT", &retrace::ignore},
    {"glGetUniformuivEXT", &retrace::ignore},
    {"glBindFragDataLocationEXT", &retrace_glBindFragDataLocationEXT},
    {"glGetFragDataLocationEXT", &retrace_glGetFragDataLocationEXT},
    {"glUniform1uiEXT", &retrace_glUniform1uiEXT},
    {"glUniform2uiEXT", &retrace_glUniform2uiEXT},
    {"glUniform3uiEXT", &retrace_glUniform3uiEXT},
    {"glUniform4uiEXT", &retrace_glUniform4uiEXT},
    {"glUniform1uivEXT", &retrace_glUniform1uivEXT},
    {"glUniform2uivEXT", &retrace_glUniform2uivEXT},
    {"glUniform3uivEXT", &retrace_glUniform3uivEXT},
    {"glUniform4uivEXT", &retrace_glUniform4uivEXT},
    {"glDrawArraysInstancedEXT", &retrace_glDrawArraysInstancedEXT},
    {"glDrawElementsInstancedEXT", &retrace_glDrawElementsInstancedEXT},
    {"glTexBufferEXT", &retrace_glTexBufferEXT},
    {"glDepthRangedNV", &retrace_glDepthRangedNV},
    {"glClearDepthdNV", &retrace_glClearDepthdNV},
    {"glDepthBoundsdNV", &retrace_glDepthBoundsdNV},
    {"glRenderbufferStorageMultisampleCoverageNV", &retrace_glRenderbufferStorageMultisampleCoverageNV},
    {"glProgramBufferParametersfvNV", &retrace_glProgramBufferParametersfvNV},
    {"glProgramBufferParametersIivNV", &retrace_glProgramBufferParametersIivNV},
    {"glProgramBufferParametersIuivNV", &retrace_glProgramBufferParametersIuivNV},
    {"glColorMaskIndexedEXT", &retrace_glColorMaskIndexedEXT},
    {"glGetBooleanIndexedvEXT", &retrace::ignore},
    {"glGetIntegerIndexedvEXT", &retrace::ignore},
    {"glEnableIndexedEXT", &retrace_glEnableIndexedEXT},
    {"glDisableIndexedEXT", &retrace_glDisableIndexedEXT},
    {"glIsEnabledIndexedEXT", &retrace::ignore},
    {"glBeginTransformFeedbackNV", &retrace_glBeginTransformFeedbackNV},
    {"glEndTransformFeedbackNV", &retrace_glEndTransformFeedbackNV},
    {"glTransformFeedbackAttribsNV", &retrace_glTransformFeedbackAttribsNV},
    {"glBindBufferRangeNV", &retrace_glBindBufferRangeNV},
    {"glBindBufferOffsetNV", &retrace_glBindBufferOffsetNV},
    {"glBindBufferBaseNV", &retrace_glBindBufferBaseNV},
    {"glTransformFeedbackVaryingsNV", &retrace_glTransformFeedbackVaryingsNV},
    {"glActiveVaryingNV", &retrace_glActiveVaryingNV},
    {"glGetVaryingLocationNV", &retrace_glGetVaryingLocationNV},
    {"glGetActiveVaryingNV", &retrace::ignore},
    {"glGetTransformFeedbackVaryingNV", &retrace::ignore},
    {"glTransformFeedbackStreamAttribsNV", &retrace_glTransformFeedbackStreamAttribsNV},
    {"glUniformBufferEXT", &retrace_glUniformBufferEXT},
    {"glGetUniformBufferSizeEXT", &retrace_glGetUniformBufferSizeEXT},
    {"glGetUniformOffsetEXT", &retrace_glGetUniformOffsetEXT},
    {"glTexParameterIivEXT", &retrace_glTexParameterIivEXT},
    {"glTexParameterIuivEXT", &retrace_glTexParameterIuivEXT},
    {"glGetTexParameterIivEXT", &retrace::ignore},
    {"glGetTexParameterIuivEXT", &retrace::ignore},
    {"glClearColorIiEXT", &retrace_glClearColorIiEXT},
    {"glClearColorIuiEXT", &retrace_glClearColorIuiEXT},
    {"glFrameTerminatorGREMEDY", &retrace_glFrameTerminatorGREMEDY},
    {"glBeginConditionalRenderNV", &retrace_glBeginConditionalRenderNV},
    {"glEndConditionalRenderNV", &retrace_glEndConditionalRenderNV},
    {"glPresentFrameKeyedNV", &retrace_glPresentFrameKeyedNV},
    {"glPresentFrameDualFillNV", &retrace_glPresentFrameDualFillNV},
    {"glGetVideoivNV", &retrace::ignore},
    {"glGetVideouivNV", &retrace::ignore},
    {"glGetVideoi64vNV", &retrace::ignore},
    {"glGetVideoui64vNV", &retrace::ignore},
    {"glBeginTransformFeedbackEXT", &retrace_glBeginTransformFeedbackEXT},
    {"glEndTransformFeedbackEXT", &retrace_glEndTransformFeedbackEXT},
    {"glBindBufferRangeEXT", &retrace_glBindBufferRangeEXT},
    {"glBindBufferOffsetEXT", &retrace_glBindBufferOffsetEXT},
    {"glBindBufferBaseEXT", &retrace_glBindBufferBaseEXT},
    {"glTransformFeedbackVaryingsEXT", &retrace_glTransformFeedbackVaryingsEXT},
    {"glGetTransformFeedbackVaryingEXT", &retrace::ignore},
    {"glClientAttribDefaultEXT", &retrace_glClientAttribDefaultEXT},
    {"glPushClientAttribDefaultEXT", &retrace_glPushClientAttribDefaultEXT},
    {"glMatrixLoadfEXT", &retrace_glMatrixLoadfEXT},
    {"glMatrixLoaddEXT", &retrace_glMatrixLoaddEXT},
    {"glMatrixMultfEXT", &retrace_glMatrixMultfEXT},
    {"glMatrixMultdEXT", &retrace_glMatrixMultdEXT},
    {"glMatrixLoadIdentityEXT", &retrace_glMatrixLoadIdentityEXT},
    {"glMatrixRotatefEXT", &retrace_glMatrixRotatefEXT},
    {"glMatrixRotatedEXT", &retrace_glMatrixRotatedEXT},
    {"glMatrixScalefEXT", &retrace_glMatrixScalefEXT},
    {"glMatrixScaledEXT", &retrace_glMatrixScaledEXT},
    {"glMatrixTranslatefEXT", &retrace_glMatrixTranslatefEXT},
    {"glMatrixTranslatedEXT", &retrace_glMatrixTranslatedEXT},
    {"glMatrixFrustumEXT", &retrace_glMatrixFrustumEXT},
    {"glMatrixOrthoEXT", &retrace_glMatrixOrthoEXT},
    {"glMatrixPopEXT", &retrace_glMatrixPopEXT},
    {"glMatrixPushEXT", &retrace_glMatrixPushEXT},
    {"glMatrixLoadTransposefEXT", &retrace_glMatrixLoadTransposefEXT},
    {"glMatrixLoadTransposedEXT", &retrace_glMatrixLoadTransposedEXT},
    {"glMatrixMultTransposefEXT", &retrace_glMatrixMultTransposefEXT},
    {"glMatrixMultTransposedEXT", &retrace_glMatrixMultTransposedEXT},
    {"glTextureParameterfEXT", &retrace_glTextureParameterfEXT},
    {"glTextureParameterfvEXT", &retrace_glTextureParameterfvEXT},
    {"glTextureParameteriEXT", &retrace_glTextureParameteriEXT},
    {"glTextureParameterivEXT", &retrace_glTextureParameterivEXT},
    {"glTextureImage1DEXT", &retrace_glTextureImage1DEXT},
    {"glTextureImage2DEXT", &retrace_glTextureImage2DEXT},
    {"glTextureSubImage1DEXT", &retrace_glTextureSubImage1DEXT},
    {"glTextureSubImage2DEXT", &retrace_glTextureSubImage2DEXT},
    {"glCopyTextureImage1DEXT", &retrace_glCopyTextureImage1DEXT},
    {"glCopyTextureImage2DEXT", &retrace_glCopyTextureImage2DEXT},
    {"glCopyTextureSubImage1DEXT", &retrace_glCopyTextureSubImage1DEXT},
    {"glCopyTextureSubImage2DEXT", &retrace_glCopyTextureSubImage2DEXT},
    {"glGetTextureImageEXT", &retrace_glGetTextureImageEXT},
    {"glGetTextureParameterfvEXT", &retrace::ignore},
    {"glGetTextureParameterivEXT", &retrace::ignore},
    {"glGetTextureLevelParameterfvEXT", &retrace::ignore},
    {"glGetTextureLevelParameterivEXT", &retrace::ignore},
    {"glTextureImage3DEXT", &retrace_glTextureImage3DEXT},
    {"glTextureSubImage3DEXT", &retrace_glTextureSubImage3DEXT},
    {"glCopyTextureSubImage3DEXT", &retrace_glCopyTextureSubImage3DEXT},
    {"glMultiTexParameterfEXT", &retrace_glMultiTexParameterfEXT},
    {"glMultiTexParameterfvEXT", &retrace_glMultiTexParameterfvEXT},
    {"glMultiTexParameteriEXT", &retrace_glMultiTexParameteriEXT},
    {"glMultiTexParameterivEXT", &retrace_glMultiTexParameterivEXT},
    {"glMultiTexImage1DEXT", &retrace_glMultiTexImage1DEXT},
    {"glMultiTexImage2DEXT", &retrace_glMultiTexImage2DEXT},
    {"glMultiTexSubImage1DEXT", &retrace_glMultiTexSubImage1DEXT},
    {"glMultiTexSubImage2DEXT", &retrace_glMultiTexSubImage2DEXT},
    {"glCopyMultiTexImage1DEXT", &retrace_glCopyMultiTexImage1DEXT},
    {"glCopyMultiTexImage2DEXT", &retrace_glCopyMultiTexImage2DEXT},
    {"glCopyMultiTexSubImage1DEXT", &retrace_glCopyMultiTexSubImage1DEXT},
    {"glCopyMultiTexSubImage2DEXT", &retrace_glCopyMultiTexSubImage2DEXT},
    {"glGetMultiTexImageEXT", &retrace_glGetMultiTexImageEXT},
    {"glGetMultiTexParameterfvEXT", &retrace::ignore},
    {"glGetMultiTexParameterivEXT", &retrace::ignore},
    {"glGetMultiTexLevelParameterfvEXT", &retrace::ignore},
    {"glGetMultiTexLevelParameterivEXT", &retrace::ignore},
    {"glMultiTexImage3DEXT", &retrace_glMultiTexImage3DEXT},
    {"glMultiTexSubImage3DEXT", &retrace_glMultiTexSubImage3DEXT},
    {"glCopyMultiTexSubImage3DEXT", &retrace_glCopyMultiTexSubImage3DEXT},
    {"glBindMultiTextureEXT", &retrace_glBindMultiTextureEXT},
    {"glEnableClientStateIndexedEXT", &retrace_glEnableClientStateIndexedEXT},
    {"glDisableClientStateIndexedEXT", &retrace_glDisableClientStateIndexedEXT},
    {"glEnableClientStateiEXT", &retrace_glEnableClientStateiEXT},
    {"glDisableClientStateiEXT", &retrace_glDisableClientStateiEXT},
    {"glMultiTexCoordPointerEXT", &retrace_glMultiTexCoordPointerEXT},
    {"glMultiTexEnvfEXT", &retrace_glMultiTexEnvfEXT},
    {"glMultiTexEnvfvEXT", &retrace_glMultiTexEnvfvEXT},
    {"glMultiTexEnviEXT", &retrace_glMultiTexEnviEXT},
    {"glMultiTexEnvivEXT", &retrace_glMultiTexEnvivEXT},
    {"glMultiTexGendEXT", &retrace_glMultiTexGendEXT},
    {"glMultiTexGendvEXT", &retrace_glMultiTexGendvEXT},
    {"glMultiTexGenfEXT", &retrace_glMultiTexGenfEXT},
    {"glMultiTexGenfvEXT", &retrace_glMultiTexGenfvEXT},
    {"glMultiTexGeniEXT", &retrace_glMultiTexGeniEXT},
    {"glMultiTexGenivEXT", &retrace_glMultiTexGenivEXT},
    {"glGetMultiTexEnvfvEXT", &retrace::ignore},
    {"glGetMultiTexEnvivEXT", &retrace::ignore},
    {"glGetMultiTexGendvEXT", &retrace::ignore},
    {"glGetMultiTexGenfvEXT", &retrace::ignore},
    {"glGetMultiTexGenivEXT", &retrace::ignore},
    {"glGetFloatIndexedvEXT", &retrace::ignore},
    {"glGetDoubleIndexedvEXT", &retrace::ignore},
    {"glGetPointerIndexedvEXT", &retrace::ignore},
    {"glGetFloati_vEXT", &retrace::ignore},
    {"glGetDoublei_vEXT", &retrace::ignore},
    {"glGetPointeri_vEXT", &retrace::ignore},
    {"glCompressedTextureImage3DEXT", &retrace_glCompressedTextureImage3DEXT},
    {"glCompressedTextureImage2DEXT", &retrace_glCompressedTextureImage2DEXT},
    {"glCompressedTextureImage1DEXT", &retrace_glCompressedTextureImage1DEXT},
    {"glCompressedTextureSubImage3DEXT", &retrace_glCompressedTextureSubImage3DEXT},
    {"glCompressedTextureSubImage2DEXT", &retrace_glCompressedTextureSubImage2DEXT},
    {"glCompressedTextureSubImage1DEXT", &retrace_glCompressedTextureSubImage1DEXT},
    {"glGetCompressedTextureImageEXT", &retrace_glGetCompressedTextureImageEXT},
    {"glCompressedMultiTexImage3DEXT", &retrace_glCompressedMultiTexImage3DEXT},
    {"glCompressedMultiTexImage2DEXT", &retrace_glCompressedMultiTexImage2DEXT},
    {"glCompressedMultiTexImage1DEXT", &retrace_glCompressedMultiTexImage1DEXT},
    {"glCompressedMultiTexSubImage3DEXT", &retrace_glCompressedMultiTexSubImage3DEXT},
    {"glCompressedMultiTexSubImage2DEXT", &retrace_glCompressedMultiTexSubImage2DEXT},
    {"glCompressedMultiTexSubImage1DEXT", &retrace_glCompressedMultiTexSubImage1DEXT},
    {"glGetCompressedMultiTexImageEXT", &retrace_glGetCompressedMultiTexImageEXT},
    {"glNamedProgramStringEXT", &retrace_glNamedProgramStringEXT},
    {"glNamedProgramLocalParameter4dEXT", &retrace_glNamedProgramLocalParameter4dEXT},
    {"glNamedProgramLocalParameter4dvEXT", &retrace_glNamedProgramLocalParameter4dvEXT},
    {"glNamedProgramLocalParameter4fEXT", &retrace_glNamedProgramLocalParameter4fEXT},
    {"glNamedProgramLocalParameter4fvEXT", &retrace_glNamedProgramLocalParameter4fvEXT},
    {"glGetNamedProgramLocalParameterdvEXT", &retrace::ignore},
    {"glGetNamedProgramLocalParameterfvEXT", &retrace::ignore},
    {"glGetNamedProgramivEXT", &retrace::ignore},
    {"glGetNamedProgramStringEXT", &retrace::ignore},
    {"glNamedProgramLocalParameters4fvEXT", &retrace_glNamedProgramLocalParameters4fvEXT},
    {"glNamedProgramLocalParameterI4iEXT", &retrace_glNamedProgramLocalParameterI4iEXT},
    {"glNamedProgramLocalParameterI4ivEXT", &retrace_glNamedProgramLocalParameterI4ivEXT},
    {"glNamedProgramLocalParametersI4ivEXT", &retrace_glNamedProgramLocalParametersI4ivEXT},
    {"glNamedProgramLocalParameterI4uiEXT", &retrace_glNamedProgramLocalParameterI4uiEXT},
    {"glNamedProgramLocalParameterI4uivEXT", &retrace_glNamedProgramLocalParameterI4uivEXT},
    {"glNamedProgramLocalParametersI4uivEXT", &retrace_glNamedProgramLocalParametersI4uivEXT},
    {"glGetNamedProgramLocalParameterIivEXT", &retrace::ignore},
    {"glGetNamedProgramLocalParameterIuivEXT", &retrace::ignore},
    {"glTextureParameterIivEXT", &retrace_glTextureParameterIivEXT},
    {"glTextureParameterIuivEXT", &retrace_glTextureParameterIuivEXT},
    {"glGetTextureParameterIivEXT", &retrace::ignore},
    {"glGetTextureParameterIuivEXT", &retrace::ignore},
    {"glMultiTexParameterIivEXT", &retrace_glMultiTexParameterIivEXT},
    {"glMultiTexParameterIuivEXT", &retrace_glMultiTexParameterIuivEXT},
    {"glGetMultiTexParameterIivEXT", &retrace::ignore},
    {"glGetMultiTexParameterIuivEXT", &retrace::ignore},
    {"glProgramUniform1fEXT", &retrace_glProgramUniform1fEXT},
    {"glProgramUniform2fEXT", &retrace_glProgramUniform2fEXT},
    {"glProgramUniform3fEXT", &retrace_glProgramUniform3fEXT},
    {"glProgramUniform4fEXT", &retrace_glProgramUniform4fEXT},
    {"glProgramUniform1iEXT", &retrace_glProgramUniform1iEXT},
    {"glProgramUniform2iEXT", &retrace_glProgramUniform2iEXT},
    {"glProgramUniform3iEXT", &retrace_glProgramUniform3iEXT},
    {"glProgramUniform4iEXT", &retrace_glProgramUniform4iEXT},
    {"glProgramUniform1fvEXT", &retrace_glProgramUniform1fvEXT},
    {"glProgramUniform2fvEXT", &retrace_glProgramUniform2fvEXT},
    {"glProgramUniform3fvEXT", &retrace_glProgramUniform3fvEXT},
    {"glProgramUniform4fvEXT", &retrace_glProgramUniform4fvEXT},
    {"glProgramUniform1ivEXT", &retrace_glProgramUniform1ivEXT},
    {"glProgramUniform2ivEXT", &retrace_glProgramUniform2ivEXT},
    {"glProgramUniform3ivEXT", &retrace_glProgramUniform3ivEXT},
    {"glProgramUniform4ivEXT", &retrace_glProgramUniform4ivEXT},
    {"glProgramUniformMatrix2fvEXT", &retrace_glProgramUniformMatrix2fvEXT},
    {"glProgramUniformMatrix3fvEXT", &retrace_glProgramUniformMatrix3fvEXT},
    {"glProgramUniformMatrix4fvEXT", &retrace_glProgramUniformMatrix4fvEXT},
    {"glProgramUniformMatrix2x3fvEXT", &retrace_glProgramUniformMatrix2x3fvEXT},
    {"glProgramUniformMatrix3x2fvEXT", &retrace_glProgramUniformMatrix3x2fvEXT},
    {"glProgramUniformMatrix2x4fvEXT", &retrace_glProgramUniformMatrix2x4fvEXT},
    {"glProgramUniformMatrix4x2fvEXT", &retrace_glProgramUniformMatrix4x2fvEXT},
    {"glProgramUniformMatrix3x4fvEXT", &retrace_glProgramUniformMatrix3x4fvEXT},
    {"glProgramUniformMatrix4x3fvEXT", &retrace_glProgramUniformMatrix4x3fvEXT},
    {"glProgramUniform1uiEXT", &retrace_glProgramUniform1uiEXT},
    {"glProgramUniform2uiEXT", &retrace_glProgramUniform2uiEXT},
    {"glProgramUniform3uiEXT", &retrace_glProgramUniform3uiEXT},
    {"glProgramUniform4uiEXT", &retrace_glProgramUniform4uiEXT},
    {"glProgramUniform1uivEXT", &retrace_glProgramUniform1uivEXT},
    {"glProgramUniform2uivEXT", &retrace_glProgramUniform2uivEXT},
    {"glProgramUniform3uivEXT", &retrace_glProgramUniform3uivEXT},
    {"glProgramUniform4uivEXT", &retrace_glProgramUniform4uivEXT},
    {"glNamedBufferDataEXT", &retrace_glNamedBufferDataEXT},
    {"glNamedBufferSubDataEXT", &retrace_glNamedBufferSubDataEXT},
    {"glMapNamedBufferEXT", &retrace_glMapNamedBufferEXT},
    {"glUnmapNamedBufferEXT", &retrace_glUnmapNamedBufferEXT},
    {"glMapNamedBufferRangeEXT", &retrace_glMapNamedBufferRangeEXT},
    {"glFlushMappedNamedBufferRangeEXT", &retrace_glFlushMappedNamedBufferRangeEXT},
    {"glNamedCopyBufferSubDataEXT", &retrace_glNamedCopyBufferSubDataEXT},
    {"glGetNamedBufferParameterivEXT", &retrace::ignore},
    {"glGetNamedBufferPointervEXT", &retrace::ignore},
    {"glGetNamedBufferSubDataEXT", &retrace::ignore},
    {"glTextureBufferEXT", &retrace_glTextureBufferEXT},
    {"glMultiTexBufferEXT", &retrace_glMultiTexBufferEXT},
    {"glNamedRenderbufferStorageEXT", &retrace_glNamedRenderbufferStorageEXT},
    {"glGetNamedRenderbufferParameterivEXT", &retrace::ignore},
    {"glCheckNamedFramebufferStatusEXT", &retrace_glCheckNamedFramebufferStatusEXT},
    {"glNamedFramebufferTexture1DEXT", &retrace_glNamedFramebufferTexture1DEXT},
    {"glNamedFramebufferTexture2DEXT", &retrace_glNamedFramebufferTexture2DEXT},
    {"glNamedFramebufferTexture3DEXT", &retrace_glNamedFramebufferTexture3DEXT},
    {"glNamedFramebufferRenderbufferEXT", &retrace_glNamedFramebufferRenderbufferEXT},
    {"glGetNamedFramebufferAttachmentParameterivEXT", &retrace::ignore},
    {"glGenerateTextureMipmapEXT", &retrace_glGenerateTextureMipmapEXT},
    {"glGenerateMultiTexMipmapEXT", &retrace_glGenerateMultiTexMipmapEXT},
    {"glFramebufferDrawBufferEXT", &retrace_glFramebufferDrawBufferEXT},
    {"glFramebufferDrawBuffersEXT", &retrace_glFramebufferDrawBuffersEXT},
    {"glFramebufferReadBufferEXT", &retrace_glFramebufferReadBufferEXT},
    {"glGetFramebufferParameterivEXT", &retrace::ignore},
    {"glNamedRenderbufferStorageMultisampleEXT", &retrace_glNamedRenderbufferStorageMultisampleEXT},
    {"glNamedRenderbufferStorageMultisampleCoverageEXT", &retrace_glNamedRenderbufferStorageMultisampleCoverageEXT},
    {"glNamedFramebufferTextureEXT", &retrace_glNamedFramebufferTextureEXT},
    {"glNamedFramebufferTextureLayerEXT", &retrace_glNamedFramebufferTextureLayerEXT},
    {"glNamedFramebufferTextureFaceEXT", &retrace_glNamedFramebufferTextureFaceEXT},
    {"glTextureRenderbufferEXT", &retrace_glTextureRenderbufferEXT},
    {"glMultiTexRenderbufferEXT", &retrace_glMultiTexRenderbufferEXT},
    {"glProgramUniform1dEXT", &retrace_glProgramUniform1dEXT},
    {"glProgramUniform2dEXT", &retrace_glProgramUniform2dEXT},
    {"glProgramUniform3dEXT", &retrace_glProgramUniform3dEXT},
    {"glProgramUniform4dEXT", &retrace_glProgramUniform4dEXT},
    {"glProgramUniform1dvEXT", &retrace_glProgramUniform1dvEXT},
    {"glProgramUniform2dvEXT", &retrace_glProgramUniform2dvEXT},
    {"glProgramUniform3dvEXT", &retrace_glProgramUniform3dvEXT},
    {"glProgramUniform4dvEXT", &retrace_glProgramUniform4dvEXT},
    {"glProgramUniformMatrix2dvEXT", &retrace_glProgramUniformMatrix2dvEXT},
    {"glProgramUniformMatrix3dvEXT", &retrace_glProgramUniformMatrix3dvEXT},
    {"glProgramUniformMatrix4dvEXT", &retrace_glProgramUniformMatrix4dvEXT},
    {"glProgramUniformMatrix2x3dvEXT", &retrace_glProgramUniformMatrix2x3dvEXT},
    {"glProgramUniformMatrix2x4dvEXT", &retrace_glProgramUniformMatrix2x4dvEXT},
    {"glProgramUniformMatrix3x2dvEXT", &retrace_glProgramUniformMatrix3x2dvEXT},
    {"glProgramUniformMatrix3x4dvEXT", &retrace_glProgramUniformMatrix3x4dvEXT},
    {"glProgramUniformMatrix4x2dvEXT", &retrace_glProgramUniformMatrix4x2dvEXT},
    {"glProgramUniformMatrix4x3dvEXT", &retrace_glProgramUniformMatrix4x3dvEXT},
    {"glVertexArrayVertexOffsetEXT", &retrace_glVertexArrayVertexOffsetEXT},
    {"glVertexArrayColorOffsetEXT", &retrace_glVertexArrayColorOffsetEXT},
    {"glVertexArrayEdgeFlagOffsetEXT", &retrace_glVertexArrayEdgeFlagOffsetEXT},
    {"glVertexArrayIndexOffsetEXT", &retrace_glVertexArrayIndexOffsetEXT},
    {"glVertexArrayNormalOffsetEXT", &retrace_glVertexArrayNormalOffsetEXT},
    {"glVertexArrayTexCoordOffsetEXT", &retrace_glVertexArrayTexCoordOffsetEXT},
    {"glVertexArrayMultiTexCoordOffsetEXT", &retrace_glVertexArrayMultiTexCoordOffsetEXT},
    {"glVertexArrayFogCoordOffsetEXT", &retrace_glVertexArrayFogCoordOffsetEXT},
    {"glVertexArraySecondaryColorOffsetEXT", &retrace_glVertexArraySecondaryColorOffsetEXT},
    {"glVertexArrayVertexAttribOffsetEXT", &retrace_glVertexArrayVertexAttribOffsetEXT},
    {"glVertexArrayVertexAttribIOffsetEXT", &retrace_glVertexArrayVertexAttribIOffsetEXT},
    {"glEnableVertexArrayEXT", &retrace_glEnableVertexArrayEXT},
    {"glDisableVertexArrayEXT", &retrace_glDisableVertexArrayEXT},
    {"glEnableVertexArrayAttribEXT", &retrace_glEnableVertexArrayAttribEXT},
    {"glDisableVertexArrayAttribEXT", &retrace_glDisableVertexArrayAttribEXT},
    {"glGetVertexArrayIntegervEXT", &retrace::ignore},
    {"glGetVertexArrayPointervEXT", &retrace::ignore},
    {"glGetVertexArrayIntegeri_vEXT", &retrace::ignore},
    {"glGetVertexArrayPointeri_vEXT", &retrace::ignore},
    {"glGetMultisamplefvNV", &retrace::ignore},
    {"glSampleMaskIndexedNV", &retrace_glSampleMaskIndexedNV},
    {"glTexRenderbufferNV", &retrace_glTexRenderbufferNV},
    {"glBindTransformFeedbackNV", &retrace_glBindTransformFeedbackNV},
    {"glDeleteTransformFeedbacksNV", &retrace_glDeleteTransformFeedbacksNV},
    {"glGenTransformFeedbacksNV", &retrace_glGenTransformFeedbacksNV},
    {"glIsTransformFeedbackNV", &retrace::ignore},
    {"glPauseTransformFeedbackNV", &retrace_glPauseTransformFeedbackNV},
    {"glResumeTransformFeedbackNV", &retrace_glResumeTransformFeedbackNV},
    {"glDrawTransformFeedbackNV", &retrace_glDrawTransformFeedbackNV},
    {"glGetPerfMonitorGroupsAMD", &retrace::ignore},
    {"glGetPerfMonitorCountersAMD", &retrace::ignore},
    {"glGetPerfMonitorGroupStringAMD", &retrace::ignore},
    {"glGetPerfMonitorCounterStringAMD", &retrace::ignore},
    {"glGetPerfMonitorCounterInfoAMD", &retrace::ignore},
    {"glGenPerfMonitorsAMD", &retrace_glGenPerfMonitorsAMD},
    {"glDeletePerfMonitorsAMD", &retrace_glDeletePerfMonitorsAMD},
    {"glSelectPerfMonitorCountersAMD", &retrace_glSelectPerfMonitorCountersAMD},
    {"glBeginPerfMonitorAMD", &retrace_glBeginPerfMonitorAMD},
    {"glEndPerfMonitorAMD", &retrace_glEndPerfMonitorAMD},
    {"glGetPerfMonitorCounterDataAMD", &retrace::ignore},
    {"glTessellationFactorAMD", &retrace_glTessellationFactorAMD},
    {"glTessellationModeAMD", &retrace_glTessellationModeAMD},
    {"glProvokingVertexEXT", &retrace_glProvokingVertexEXT},
    {"glBlendFuncIndexedAMD", &retrace_glBlendFuncIndexedAMD},
    {"glBlendFuncSeparateIndexedAMD", &retrace_glBlendFuncSeparateIndexedAMD},
    {"glBlendEquationIndexedAMD", &retrace_glBlendEquationIndexedAMD},
    {"glBlendEquationSeparateIndexedAMD", &retrace_glBlendEquationSeparateIndexedAMD},
    {"glTextureRangeAPPLE", &retrace_glTextureRangeAPPLE},
    {"glGetTexParameterPointervAPPLE", &retrace::ignore},
    {"glEnableVertexAttribAPPLE", &retrace_glEnableVertexAttribAPPLE},
    {"glDisableVertexAttribAPPLE", &retrace_glDisableVertexAttribAPPLE},
    {"glIsVertexAttribEnabledAPPLE", &retrace::ignore},
    {"glMapVertexAttrib1dAPPLE", &retrace_glMapVertexAttrib1dAPPLE},
    {"glMapVertexAttrib1fAPPLE", &retrace_glMapVertexAttrib1fAPPLE},
    {"glMapVertexAttrib2dAPPLE", &retrace_glMapVertexAttrib2dAPPLE},
    {"glMapVertexAttrib2fAPPLE", &retrace_glMapVertexAttrib2fAPPLE},
    {"glObjectPurgeableAPPLE", &retrace_glObjectPurgeableAPPLE},
    {"glObjectUnpurgeableAPPLE", &retrace_glObjectUnpurgeableAPPLE},
    {"glGetObjectParameterivAPPLE", &retrace::ignore},
    {"glBeginVideoCaptureNV", &retrace_glBeginVideoCaptureNV},
    {"glBindVideoCaptureStreamBufferNV", &retrace_glBindVideoCaptureStreamBufferNV},
    {"glBindVideoCaptureStreamTextureNV", &retrace_glBindVideoCaptureStreamTextureNV},
    {"glEndVideoCaptureNV", &retrace_glEndVideoCaptureNV},
    {"glGetVideoCaptureivNV", &retrace::ignore},
    {"glGetVideoCaptureStreamivNV", &retrace::ignore},
    {"glGetVideoCaptureStreamfvNV", &retrace::ignore},
    {"glGetVideoCaptureStreamdvNV", &retrace::ignore},
    {"glVideoCaptureNV", &retrace_glVideoCaptureNV},
    {"glVideoCaptureStreamParameterivNV", &retrace_glVideoCaptureStreamParameterivNV},
    {"glVideoCaptureStreamParameterfvNV", &retrace_glVideoCaptureStreamParameterfvNV},
    {"glVideoCaptureStreamParameterdvNV", &retrace_glVideoCaptureStreamParameterdvNV},
    {"glCopyImageSubDataNV", &retrace_glCopyImageSubDataNV},
    {"glUseShaderProgramEXT", &retrace_glUseShaderProgramEXT},
    {"glActiveProgramEXT", &retrace_glActiveProgramEXT},
    {"glCreateShaderProgramEXT", &retrace_glCreateShaderProgramEXT},
    {"glMakeBufferResidentNV", &retrace_glMakeBufferResidentNV},
    {"glMakeBufferNonResidentNV", &retrace_glMakeBufferNonResidentNV},
    {"glIsBufferResidentNV", &retrace::ignore},
    {"glMakeNamedBufferResidentNV", &retrace_glMakeNamedBufferResidentNV},
    {"glMakeNamedBufferNonResidentNV", &retrace_glMakeNamedBufferNonResidentNV},
    {"glIsNamedBufferResidentNV", &retrace::ignore},
    {"glGetBufferParameterui64vNV", &retrace::ignore},
    {"glGetNamedBufferParameterui64vNV", &retrace::ignore},
    {"glGetIntegerui64vNV", &retrace::ignore},
    {"glUniformui64NV", &retrace_glUniformui64NV},
    {"glUniformui64vNV", &retrace_glUniformui64vNV},
    {"glGetUniformui64vNV", &retrace::ignore},
    {"glProgramUniformui64NV", &retrace_glProgramUniformui64NV},
    {"glProgramUniformui64vNV", &retrace_glProgramUniformui64vNV},
    {"glBufferAddressRangeNV", &retrace_glBufferAddressRangeNV},
    {"glVertexFormatNV", &retrace_glVertexFormatNV},
    {"glNormalFormatNV", &retrace_glNormalFormatNV},
    {"glColorFormatNV", &retrace_glColorFormatNV},
    {"glIndexFormatNV", &retrace_glIndexFormatNV},
    {"glTexCoordFormatNV", &retrace_glTexCoordFormatNV},
    {"glEdgeFlagFormatNV", &retrace_glEdgeFlagFormatNV},
    {"glSecondaryColorFormatNV", &retrace_glSecondaryColorFormatNV},
    {"glFogCoordFormatNV", &retrace_glFogCoordFormatNV},
    {"glVertexAttribFormatNV", &retrace_glVertexAttribFormatNV},
    {"glVertexAttribIFormatNV", &retrace_glVertexAttribIFormatNV},
    {"glGetIntegerui64i_vNV", &retrace::ignore},
    {"glTextureBarrierNV", &retrace_glTextureBarrierNV},
    {"glBindImageTextureEXT", &retrace_glBindImageTextureEXT},
    {"glMemoryBarrierEXT", &retrace_glMemoryBarrierEXT},
    {"glVertexAttribL1dEXT", &retrace_glVertexAttribL1dEXT},
    {"glVertexAttribL2dEXT", &retrace_glVertexAttribL2dEXT},
    {"glVertexAttribL3dEXT", &retrace_glVertexAttribL3dEXT},
    {"glVertexAttribL4dEXT", &retrace_glVertexAttribL4dEXT},
    {"glVertexAttribL1dvEXT", &retrace_glVertexAttribL1dvEXT},
    {"glVertexAttribL2dvEXT", &retrace_glVertexAttribL2dvEXT},
    {"glVertexAttribL3dvEXT", &retrace_glVertexAttribL3dvEXT},
    {"glVertexAttribL4dvEXT", &retrace_glVertexAttribL4dvEXT},
    {"glVertexAttribLPointerEXT", &retrace_glVertexAttribLPointerEXT},
    {"glGetVertexAttribLdvEXT", &retrace::ignore},
    {"glVertexArrayVertexAttribLOffsetEXT", &retrace_glVertexArrayVertexAttribLOffsetEXT},
    {"glProgramSubroutineParametersuivNV", &retrace_glProgramSubroutineParametersuivNV},
    {"glGetProgramSubroutineParameteruivNV", &retrace::ignore},
    {"glUniform1i64NV", &retrace_glUniform1i64NV},
    {"glUniform2i64NV", &retrace_glUniform2i64NV},
    {"glUniform3i64NV", &retrace_glUniform3i64NV},
    {"glUniform4i64NV", &retrace_glUniform4i64NV},
    {"glUniform1i64vNV", &retrace_glUniform1i64vNV},
    {"glUniform2i64vNV", &retrace_glUniform2i64vNV},
    {"glUniform3i64vNV", &retrace_glUniform3i64vNV},
    {"glUniform4i64vNV", &retrace_glUniform4i64vNV},
    {"glUniform1ui64NV", &retrace_glUniform1ui64NV},
    {"glUniform2ui64NV", &retrace_glUniform2ui64NV},
    {"glUniform3ui64NV", &retrace_glUniform3ui64NV},
    {"glUniform4ui64NV", &retrace_glUniform4ui64NV},
    {"glUniform1ui64vNV", &retrace_glUniform1ui64vNV},
    {"glUniform2ui64vNV", &retrace_glUniform2ui64vNV},
    {"glUniform3ui64vNV", &retrace_glUniform3ui64vNV},
    {"glUniform4ui64vNV", &retrace_glUniform4ui64vNV},
    {"glGetUniformi64vNV", &retrace::ignore},
    {"glProgramUniform1i64NV", &retrace_glProgramUniform1i64NV},
    {"glProgramUniform2i64NV", &retrace_glProgramUniform2i64NV},
    {"glProgramUniform3i64NV", &retrace_glProgramUniform3i64NV},
    {"glProgramUniform4i64NV", &retrace_glProgramUniform4i64NV},
    {"glProgramUniform1i64vNV", &retrace_glProgramUniform1i64vNV},
    {"glProgramUniform2i64vNV", &retrace_glProgramUniform2i64vNV},
    {"glProgramUniform3i64vNV", &retrace_glProgramUniform3i64vNV},
    {"glProgramUniform4i64vNV", &retrace_glProgramUniform4i64vNV},
    {"glProgramUniform1ui64NV", &retrace_glProgramUniform1ui64NV},
    {"glProgramUniform2ui64NV", &retrace_glProgramUniform2ui64NV},
    {"glProgramUniform3ui64NV", &retrace_glProgramUniform3ui64NV},
    {"glProgramUniform4ui64NV", &retrace_glProgramUniform4ui64NV},
    {"glProgramUniform1ui64vNV", &retrace_glProgramUniform1ui64vNV},
    {"glProgramUniform2ui64vNV", &retrace_glProgramUniform2ui64vNV},
    {"glProgramUniform3ui64vNV", &retrace_glProgramUniform3ui64vNV},
    {"glProgramUniform4ui64vNV", &retrace_glProgramUniform4ui64vNV},
    {"glVertexAttribL1i64NV", &retrace_glVertexAttribL1i64NV},
    {"glVertexAttribL2i64NV", &retrace_glVertexAttribL2i64NV},
    {"glVertexAttribL3i64NV", &retrace_glVertexAttribL3i64NV},
    {"glVertexAttribL4i64NV", &retrace_glVertexAttribL4i64NV},
    {"glVertexAttribL1i64vNV", &retrace_glVertexAttribL1i64vNV},
    {"glVertexAttribL2i64vNV", &retrace_glVertexAttribL2i64vNV},
    {"glVertexAttribL3i64vNV", &retrace_glVertexAttribL3i64vNV},
    {"glVertexAttribL4i64vNV", &retrace_glVertexAttribL4i64vNV},
    {"glVertexAttribL1ui64NV", &retrace_glVertexAttribL1ui64NV},
    {"glVertexAttribL2ui64NV", &retrace_glVertexAttribL2ui64NV},
    {"glVertexAttribL3ui64NV", &retrace_glVertexAttribL3ui64NV},
    {"glVertexAttribL4ui64NV", &retrace_glVertexAttribL4ui64NV},
    {"glVertexAttribL1ui64vNV", &retrace_glVertexAttribL1ui64vNV},
    {"glVertexAttribL2ui64vNV", &retrace_glVertexAttribL2ui64vNV},
    {"glVertexAttribL3ui64vNV", &retrace_glVertexAttribL3ui64vNV},
    {"glVertexAttribL4ui64vNV", &retrace_glVertexAttribL4ui64vNV},
    {"glGetVertexAttribLi64vNV", &retrace::ignore},
    {"glGetVertexAttribLui64vNV", &retrace::ignore},
    {"glVertexAttribLFormatNV", &retrace_glVertexAttribLFormatNV},
    {"glGenNamesAMD", &retrace_glGenNamesAMD},
    {"glDeleteNamesAMD", &retrace_glDeleteNamesAMD},
    {"glIsNameAMD", &retrace::ignore},
    {"glDebugMessageEnableAMD", &retrace_glDebugMessageEnableAMD},
    {"glDebugMessageInsertAMD", &retrace_glDebugMessageInsertAMD},
    {"glDebugMessageCallbackAMD", &retrace::ignore},
    {"glGetDebugMessageLogAMD", &retrace::ignore},
    {"glTexImage2DMultisampleCoverageNV", &retrace_glTexImage2DMultisampleCoverageNV},
    {"glTexImage3DMultisampleCoverageNV", &retrace_glTexImage3DMultisampleCoverageNV},
    {"glTextureImage2DMultisampleNV", &retrace_glTextureImage2DMultisampleNV},
    {"glTextureImage3DMultisampleNV", &retrace_glTextureImage3DMultisampleNV},
    {"glTextureImage2DMultisampleCoverageNV", &retrace_glTextureImage2DMultisampleCoverageNV},
    {"glTextureImage3DMultisampleCoverageNV", &retrace_glTextureImage3DMultisampleCoverageNV},
    {"glSetMultisamplefvAMD", &retrace_glSetMultisamplefvAMD},
    {"glImportSyncEXT", &retrace_glImportSyncEXT},
    {"glMultiDrawArraysIndirectAMD", &retrace_glMultiDrawArraysIndirectAMD},
    {"glMultiDrawElementsIndirectAMD", &retrace_glMultiDrawElementsIndirectAMD},
    {"glStencilOpValueAMD", &retrace_glStencilOpValueAMD},
    {"glGetTextureHandleNV", &retrace_glGetTextureHandleNV},
    {"glGetTextureSamplerHandleNV", &retrace_glGetTextureSamplerHandleNV},
    {"glMakeTextureHandleResidentNV", &retrace_glMakeTextureHandleResidentNV},
    {"glMakeTextureHandleNonResidentNV", &retrace_glMakeTextureHandleNonResidentNV},
    {"glGetImageHandleNV", &retrace_glGetImageHandleNV},
    {"glMakeImageHandleResidentNV", &retrace_glMakeImageHandleResidentNV},
    {"glMakeImageHandleNonResidentNV", &retrace_glMakeImageHandleNonResidentNV},
    {"glUniformHandleui64NV", &retrace_glUniformHandleui64NV},
    {"glUniformHandleui64vNV", &retrace_glUniformHandleui64vNV},
    {"glProgramUniformHandleui64NV", &retrace_glProgramUniformHandleui64NV},
    {"glProgramUniformHandleui64vNV", &retrace_glProgramUniformHandleui64vNV},
    {"glIsTextureHandleResidentNV", &retrace::ignore},
    {"glIsImageHandleResidentNV", &retrace::ignore},
    {"glBeginConditionalRenderNVX", &retrace_glBeginConditionalRenderNVX},
    {"glEndConditionalRenderNVX", &retrace_glEndConditionalRenderNVX},
    {"glTexStorageSparseAMD", &retrace_glTexStorageSparseAMD},
    {"glTextureStorageSparseAMD", &retrace_glTextureStorageSparseAMD},
    {"glDrawTextureNV", &retrace_glDrawTextureNV},
    {"glNewBufferRegion", &retrace_glNewBufferRegion},
    {"glDeleteBufferRegion", &retrace_glDeleteBufferRegion},
    {"glReadBufferRegion", &retrace_glReadBufferRegion},
    {"glDrawBufferRegion", &retrace_glDrawBufferRegion},
    {"glBufferRegionEnabled", &retrace::ignore},
    {"glAddSwapHintRectWIN", &retrace_glAddSwapHintRectWIN},
    {"glFrustumf", &retrace_glFrustumf},
    {"glOrthof", &retrace_glOrthof},
    {"glClipPlanef", &retrace_glClipPlanef},
    {"glGetClipPlanef", &retrace::ignore},
    {"glAlphaFuncx", &retrace_glAlphaFuncx},
    {"glClearColorx", &retrace_glClearColorx},
    {"glClearDepthx", &retrace_glClearDepthx},
    {"glColor4x", &retrace_glColor4x},
    {"glDepthRangex", &retrace_glDepthRangex},
    {"glFogx", &retrace_glFogx},
    {"glFogxv", &retrace_glFogxv},
    {"glFrustumx", &retrace_glFrustumx},
    {"glLightModelx", &retrace_glLightModelx},
    {"glLightModelxv", &retrace_glLightModelxv},
    {"glLightx", &retrace_glLightx},
    {"glLightxv", &retrace_glLightxv},
    {"glLineWidthx", &retrace_glLineWidthx},
    {"glLoadMatrixx", &retrace_glLoadMatrixx},
    {"glMaterialx", &retrace_glMaterialx},
    {"glMaterialxv", &retrace_glMaterialxv},
    {"glMultMatrixx", &retrace_glMultMatrixx},
    {"glMultiTexCoord4x", &retrace_glMultiTexCoord4x},
    {"glNormal3x", &retrace_glNormal3x},
    {"glOrthox", &retrace_glOrthox},
    {"glPointSizex", &retrace_glPointSizex},
    {"glPolygonOffsetx", &retrace_glPolygonOffsetx},
    {"glRotatex", &retrace_glRotatex},
    {"glSampleCoveragex", &retrace_glSampleCoveragex},
    {"glScalex", &retrace_glScalex},
    {"glTexEnvx", &retrace_glTexEnvx},
    {"glTexEnvxv", &retrace_glTexEnvxv},
    {"glTexParameterx", &retrace_glTexParameterx},
    {"glTranslatex", &retrace_glTranslatex},
    {"glClipPlanex", &retrace_glClipPlanex},
    {"glGetClipPlanex", &retrace::ignore},
    {"glGetFixedv", &retrace::ignore},
    {"glGetLightxv", &retrace::ignore},
    {"glGetMaterialxv", &retrace::ignore},
    {"glGetTexEnvxv", &retrace::ignore},
    {"glGetTexParameterxv", &retrace::ignore},
    {"glPointParameterx", &retrace_glPointParameterx},
    {"glPointParameterxv", &retrace_glPointParameterxv},
    {"glTexParameterxv", &retrace_glTexParameterxv},
    {"glBlendEquationSeparateOES", &retrace_glBlendEquationSeparateOES},
    {"glBlendFuncSeparateOES", &retrace_glBlendFuncSeparateOES},
    {"glBlendEquationOES", &retrace_glBlendEquationOES},
    {"glIsRenderbufferOES", &retrace::ignore},
    {"glBindRenderbufferOES", &retrace_glBindRenderbufferOES},
    {"glDeleteRenderbuffersOES", &retrace_glDeleteRenderbuffersOES},
    {"glGenRenderbuffersOES", &retrace_glGenRenderbuffersOES},
    {"glRenderbufferStorageOES", &retrace_glRenderbufferStorageOES},
    {"glGetRenderbufferParameterivOES", &retrace::ignore},
    {"glIsFramebufferOES", &retrace::ignore},
    {"glBindFramebufferOES", &retrace_glBindFramebufferOES},
    {"glDeleteFramebuffersOES", &retrace_glDeleteFramebuffersOES},
    {"glGenFramebuffersOES", &retrace_glGenFramebuffersOES},
    {"glCheckFramebufferStatusOES", &retrace_glCheckFramebufferStatusOES},
    {"glFramebufferTexture2DOES", &retrace_glFramebufferTexture2DOES},
    {"glFramebufferRenderbufferOES", &retrace_glFramebufferRenderbufferOES},
    {"glGetFramebufferAttachmentParameterivOES", &retrace::ignore},
    {"glGenerateMipmapOES", &retrace_glGenerateMipmapOES},
    {"glCurrentPaletteMatrixOES", &retrace_glCurrentPaletteMatrixOES},
    {"glLoadPaletteFromModelViewMatrixOES", &retrace_glLoadPaletteFromModelViewMatrixOES},
    {"glMatrixIndexPointerOES", &retrace_glMatrixIndexPointerOES},
    {"glWeightPointerOES", &retrace_glWeightPointerOES},
    {"glPointSizePointerOES", &retrace_glPointSizePointerOES},
    {"glQueryMatrixxOES", &retrace_glQueryMatrixxOES},
    {"glTexGenfOES", &retrace_glTexGenfOES},
    {"glTexGenfvOES", &retrace_glTexGenfvOES},
    {"glTexGeniOES", &retrace_glTexGeniOES},
    {"glTexGenivOES", &retrace_glTexGenivOES},
    {"glTexGenxOES", &retrace_glTexGenxOES},
    {"glTexGenxvOES", &retrace_glTexGenxvOES},
    {"glGetTexGenfvOES", &retrace::ignore},
    {"glGetTexGenivOES", &retrace::ignore},
    {"glGetTexGenxvOES", &retrace::ignore},
    {"glGetBufferPointervOES", &retrace::ignore},
    {"glMapBufferOES", &retrace_glMapBufferOES},
    {"glUnmapBufferOES", &retrace_glUnmapBufferOES},
    {"glTexImage3DOES", &retrace_glTexImage3DOES},
    {"glTexSubImage3DOES", &retrace_glTexSubImage3DOES},
    {"glCopyTexSubImage3DOES", &retrace_glCopyTexSubImage3DOES},
    {"glCompressedTexImage3DOES", &retrace_glCompressedTexImage3DOES},
    {"glCompressedTexSubImage3DOES", &retrace_glCompressedTexSubImage3DOES},
    {"glFramebufferTexture3DOES", &retrace_glFramebufferTexture3DOES},
    {"glGetProgramBinaryOES", &retrace::ignore},
    {"glProgramBinaryOES", &retrace_glProgramBinaryOES},
    {"glDrawTexfOES", &retrace_glDrawTexfOES},
    {"glDrawTexfvOES", &retrace_glDrawTexfvOES},
    {"glDrawTexiOES", &retrace_glDrawTexiOES},
    {"glDrawTexivOES", &retrace_glDrawTexivOES},
    {"glDrawTexsOES", &retrace_glDrawTexsOES},
    {"glDrawTexsvOES", &retrace_glDrawTexsvOES},
    {"glDiscardFramebufferEXT", &retrace_glDiscardFramebufferEXT},
    {"glBindVertexArrayOES", &retrace_glBindVertexArrayOES},
    {"glDeleteVertexArraysOES", &retrace_glDeleteVertexArraysOES},
    {"glGenVertexArraysOES", &retrace_glGenVertexArraysOES},
    {"glIsVertexArrayOES", &retrace::ignore},
    {"glCoverageMaskNV", &retrace_glCoverageMaskNV},
    {"glCoverageOperationNV", &retrace_glCoverageOperationNV},
    {"glRenderbufferStorageMultisampleIMG", &retrace_glRenderbufferStorageMultisampleIMG},
    {"glFramebufferTexture2DMultisampleIMG", &retrace_glFramebufferTexture2DMultisampleIMG},
    {"glRenderbufferStorageMultisampleAPPLE", &retrace_glRenderbufferStorageMultisampleAPPLE},
    {"glResolveMultisampleFramebufferAPPLE", &retrace_glResolveMultisampleFramebufferAPPLE},
    {"glBlitFramebufferANGLE", &retrace_glBlitFramebufferANGLE},
    {"glRenderbufferStorageMultisampleANGLE", &retrace_glRenderbufferStorageMultisampleANGLE},
    {"glDrawBuffersNV", &retrace_glDrawBuffersNV},
    {"glReadBufferNV", &retrace_glReadBufferNV},
    {"glLabelObjectEXT", &retrace_glLabelObjectEXT},
    {"glGetObjectLabelEXT", &retrace::ignore},
    {"glInsertEventMarkerEXT", &retrace::ignore},
    {"glPushGroupMarkerEXT", &retrace::ignore},
    {"glPopGroupMarkerEXT", &retrace::ignore},
    {"glGenQueriesEXT", &retrace_glGenQueriesEXT},
    {"glDeleteQueriesEXT", &retrace_glDeleteQueriesEXT},
    {"glIsQueryEXT", &retrace::ignore},
    {"glBeginQueryEXT", &retrace_glBeginQueryEXT},
    {"glEndQueryEXT", &retrace_glEndQueryEXT},
    {"glGetQueryivEXT", &retrace::ignore},
    {"glGetQueryObjectuivEXT", &retrace::ignore},
    {"glUseProgramStagesEXT", &retrace_glUseProgramStagesEXT},
    {"glActiveShaderProgramEXT", &retrace_glActiveShaderProgramEXT},
    {"glCreateShaderProgramvEXT", &retrace_glCreateShaderProgramvEXT},
    {"glBindProgramPipelineEXT", &retrace_glBindProgramPipelineEXT},
    {"glDeleteProgramPipelinesEXT", &retrace_glDeleteProgramPipelinesEXT},
    {"glGenProgramPipelinesEXT", &retrace_glGenProgramPipelinesEXT},
    {"glIsProgramPipelineEXT", &retrace::ignore},
    {"glGetProgramPipelineivEXT", &retrace::ignore},
    {"glValidateProgramPipelineEXT", &retrace_glValidateProgramPipelineEXT},
    {"glGetProgramPipelineInfoLogEXT", &retrace::ignore},
    {"glFramebufferTexture2DMultisampleEXT", &retrace_glFramebufferTexture2DMultisampleEXT},
    {"glTexStorage1DEXT", &retrace_glTexStorage1DEXT},
    {"glTexStorage2DEXT", &retrace_glTexStorage2DEXT},
    {"glTexStorage3DEXT", &retrace_glTexStorage3DEXT},
    {NULL, NULL}
};

